"data.Issue Id","Project","Tags","Summary","Reporter","Created","Updated","Resolved","Priority","Type","Fix versions","Assignee","Subsystem","Affected versions","Fixed in build","State","Planned for","Tester","Verified","Triaged","Available in","Included in builds","Latest Affected","Zendesk mentions","Linked Support Tickets","Support","Security Severity","Description","Votes"
"IDEA-322957","IntelliJ IDEA","ij-perf-2023,slow-operations-edt","T: DirectoryIndexImpl.getInfoForFile","Exception Analyzer","19/06/2023 14:04","23/11/2023 18:37",,"Major","Exception",,"Tagir.Valeev","Java. Refactorings","2021.3.3 (213.7172.25)",,"Open","Not specified","No tester","No","Yes","Not specified","241.1433","2023.2","No zendesk mentions",,"sergei.riabinin","Unknown","### Exception Analyzer issue
 [EA-765399](https://jb-web.exa.aws.intellij.net/issue/765399)
 ### Properties
 * __Reports count__: 12049  (22-11-2023)(+2 since 16-11-2023)
 * __Since__: 212.5080.55
 * __Until__: 241.190
 
### Stacktrace
~~~stacktrace
java.lang.Throwable: Slow operations are prohibited on EDT. See SlowOperations.assertSlowOperationsAreAllowed javadoc.
	at com.intellij.openapi.diagnostic.Logger.error(Logger.java:182)
	at com.intellij.util.SlowOperations.assertSlowOperationsAreAllowed(SlowOperations.java:102)
	at com.intellij.util.indexing.FileBasedIndexImpl.ensureUpToDate(FileBasedIndexImpl.java:784)
	at com.intellij.psi.stubs.StubIndexImpl.getContainingIds(StubIndexImpl.java:514)
	at com.intellij.psi.stubs.StubIndexImpl.processElements(StubIndexImpl.java:318)
	at com.intellij.psi.stubs.StubIndex.getElements(StubIndex.java:100)
	at com.intellij.psi.stubs.StubIndex.getElements(StubIndex.java:88)
	at com.intellij.psi.impl.java.stubs.index.JavaFullClassNameIndex.get(JavaFullClassNameIndex.java:30)
	at com.intellij.psi.impl.file.impl.JavaFileManagerImpl.doFindClasses(JavaFileManagerImpl.java:84)
	at com.intellij.psi.impl.file.impl.JavaFileManagerImpl.findClass(JavaFileManagerImpl.java:110)
	at com.intellij.psi.impl.PsiElementFinderImpl.findClass(PsiElementFinderImpl.java:40)
	at com.intellij.psi.impl.JavaPsiFacadeImpl.doFindClass(JavaPsiFacadeImpl.java:91)
	at com.intellij.psi.impl.JavaPsiFacadeImpl.findClass(JavaPsiFacadeImpl.java:69)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.resolve(PsiJavaCodeReferenceElementImpl.java:446)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.access$100(PsiJavaCodeReferenceElementImpl.java:44)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl$OurGenericsResolver.resolve(PsiJavaCodeReferenceElementImpl.java:381)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl$OurGenericsResolver.resolve(PsiJavaCodeReferenceElementImpl.java:374)
	at com.intellij.psi.impl.source.resolve.ResolveCache.lambda$resolveWithCaching$2(ResolveCache.java:184)
	at com.intellij.openapi.util.Computable.get(Computable.java:18)
	at com.intellij.psi.impl.source.resolve.ResolveCache.lambda$loggingResolver$4(ResolveCache.java:260)
	at com.intellij.openapi.util.RecursionManager$1.computePreventingRecursion(RecursionManager.java:114)
	at com.intellij.openapi.util.RecursionGuard.doPreventingRecursion(RecursionGuard.java:44)
	at com.intellij.openapi.util.RecursionManager.doPreventingRecursion(RecursionManager.java:68)
	at com.intellij.psi.impl.source.resolve.ResolveCache.resolve(ResolveCache.java:237)
	at com.intellij.psi.impl.source.resolve.ResolveCache.resolveWithCaching(ResolveCache.java:184)
	at com.intellij.psi.impl.PsiImplUtil.multiResolveImpl(PsiImplUtil.java:789)
	at com.intellij.psi.impl.PsiImplUtil.multiResolveImpl(PsiImplUtil.java:781)
	at com.intellij.psi.impl.PsiImplUtil.multiResolveImpl(PsiImplUtil.java:757)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.multiResolve(PsiJavaCodeReferenceElementImpl.java:429)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.advancedResolve(PsiJavaCodeReferenceElementImpl.java:423)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.resolve(PsiJavaCodeReferenceElementImpl.java:358)
	at com.intellij.psi.impl.source.PsiImportStatementBaseImpl.resolve(PsiImportStatementBaseImpl.java:64)
	at com.intellij.psi.impl.source.PsiJavaFileBaseImpl.findExplicitDeclarations(PsiJavaFileBaseImpl.java:351)
	at com.intellij.psi.impl.source.PsiJavaFileBaseImpl.lambda$getExplicitlyEnumeratedDeclarations$0(PsiJavaFileBaseImpl.java:334)
	at com.intellij.openapi.util.NotNullLazyValue$3.compute(NotNullLazyValue.java:99)
	at com.intellij.openapi.util.NotNullLazyValue$3.getValue(NotNullLazyValue.java:84)
	at com.intellij.psi.impl.source.PsiJavaFileBaseImpl.lambda$getExplicitlyEnumeratedDeclarations$1(PsiJavaFileBaseImpl.java:336)
	at com.intellij.util.containers.ContainerUtil.process(ContainerUtil.java:757)
	at com.intellij.psi.impl.source.PsiJavaFileBaseImpl.processDeclarations(PsiJavaFileBaseImpl.java:291)
	at com.intellij.psi.scope.util.PsiScopesUtil.treeWalkUp(PsiScopesUtil.java:61)
	at com.intellij.psi.scope.util.PsiScopesUtil.treeWalkUp(PsiScopesUtil.java:40)
	at com.intellij.psi.scope.util.PsiScopesUtil.resolveAndWalk(PsiScopesUtil.java:207)
	at com.intellij.psi.scope.util.PsiScopesUtil.resolveAndWalk(PsiScopesUtil.java:136)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.resolve(PsiJavaCodeReferenceElementImpl.java:495)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.access$100(PsiJavaCodeReferenceElementImpl.java:44)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl$OurGenericsResolver.resolve(PsiJavaCodeReferenceElementImpl.java:381)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl$OurGenericsResolver.resolve(PsiJavaCodeReferenceElementImpl.java:374)
	at com.intellij.psi.impl.source.resolve.ResolveCache.lambda$resolveWithCaching$2(ResolveCache.java:184)
	at com.intellij.openapi.util.Computable.get(Computable.java:18)
	at com.intellij.psi.impl.source.resolve.ResolveCache.lambda$loggingResolver$4(ResolveCache.java:260)
	at com.intellij.openapi.util.RecursionManager$1.computePreventingRecursion(RecursionManager.java:114)
	at com.intellij.openapi.util.RecursionGuard.doPreventingRecursion(RecursionGuard.java:44)
	at com.intellij.openapi.util.RecursionManager.doPreventingRecursion(RecursionManager.java:68)
	at com.intellij.psi.impl.source.resolve.ResolveCache.resolve(ResolveCache.java:237)
	at com.intellij.psi.impl.source.resolve.ResolveCache.resolveWithCaching(ResolveCache.java:184)
	at com.intellij.psi.impl.PsiImplUtil.multiResolveImpl(PsiImplUtil.java:789)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.getCanonicalText(PsiJavaCodeReferenceElementImpl.java:296)
	at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.getCanonicalText(PsiJavaCodeReferenceElementImpl.java:280)
	at com.intellij.psi.impl.source.tree.java.PsiAnnotationImpl.getQualifiedName(PsiAnnotationImpl.java:77)
	at com.intellij.psi.impl.PsiImplUtil.findAnnotation(PsiImplUtil.java:296)
	at com.intellij.psi.impl.source.PsiModifierListImpl.findAnnotation(PsiModifierListImpl.java:311)
	at com.intellij.psi.PsiAnnotationOwner.hasAnnotation(PsiAnnotationOwner.java:44)
	at com.intellij.psi.PsiJvmConversionHelper.hasListAnnotation(PsiJvmConversionHelper.java:58)
	at com.intellij.psi.PsiModifierListOwner.hasAnnotation(PsiModifierListOwner.java:45)
	at com.intellij.psi.PsiJvmModifiersOwner.hasAnnotation(PsiJvmModifiersOwner.java:32)
	at de.plushnikov.intellij.plugin.util.PsiAnnotationSearchUtil.isAnnotatedWith(PsiAnnotationSearchUtil.java:27)
	at de.plushnikov.intellij.plugin.processor.modifier.ValueModifierProcessor.isSupported(ValueModifierProcessor.java:28)
	at de.plushnikov.intellij.plugin.provider.LombokAugmentProvider.transformModifiers(LombokAugmentProvider.java:51)
	at com.intellij.psi.augment.PsiAugmentProvider.lambda$transformModifierProperties$7(PsiAugmentProvider.java:217)
	at com.intellij.psi.augment.PsiAugmentProvider.forEach(PsiAugmentProvider.java:229)
	at com.intellij.psi.augment.PsiAugmentProvider.transformModifierProperties(PsiAugmentProvider.java:216)
	at com.intellij.psi.impl.source.PsiModifierListImpl.calcModifiers(PsiModifierListImpl.java:85)
	at com.intellij.psi.impl.source.PsiModifierListImpl.hasModifierProperty(PsiModifierListImpl.java:73)
	at com.intellij.psi.impl.source.PsiClassImpl.hasModifierProperty(PsiClassImpl.java:175)
	at com.intellij.psi.util.PsiUtil.canBeOverridden(PsiUtil.java:976)
	at com.intellij.java.refactoring.suggested.JavaSuggestedRefactoringAvailability.canHaveOverrides(JavaSuggestedRefactoringAvailability.kt:98)
	at com.intellij.java.refactoring.suggested.JavaSuggestedRefactoringAvailability.detectAvailableRefactoring(JavaSuggestedRefactoringAvailability.kt:69)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeCollector.updateAvailabilityIndicator(SuggestedRefactoringChangeCollector.kt:111)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeCollector.nextSignature(SuggestedRefactoringChangeCollector.kt:41)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeListener$MyDocumentListener.performWhenAllCommitted(SuggestedRefactoringChangeListener.kt:288)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeListener$MyDocumentListener.access$performWhenAllCommitted(SuggestedRefactoringChangeListener.kt:189)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeListener$MyDocumentListener$documentChanged$1.invoke(SuggestedRefactoringChangeListener.kt:250)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeListener$MyDocumentListener$documentChanged$1.invoke(SuggestedRefactoringChangeListener.kt:189)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeListener$sam$java_lang_Runnable$0.run(SuggestedRefactoringChangeListener.kt)
	at com.intellij.psi.impl.PsiDocumentManagerBase$CompositeRunnable.run(PsiDocumentManagerBase.java:648)
	at com.intellij.psi.impl.PsiDocumentManagerBase.runActionsWhenAllCommitted(PsiDocumentManagerBase.java:686)
	at com.intellij.psi.impl.PsiDocumentManagerBase.runAfterCommitActions(PsiDocumentManagerBase.java:670)
	at com.intellij.psi.impl.PsiDocumentManagerBase.finishCommit(PsiDocumentManagerBase.java:361)
	at com.intellij.psi.impl.DocumentCommitThread.lambda$commitUnderProgress$2(DocumentCommitThread.java:146)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$safeTransferToEdt$6(NonBlockingReadActionImpl.java:577)
	at com.intellij.openapi.application.TransactionGuardImpl.runWithWritingAllowed(TransactionGuardImpl.java:214)
	at com.intellij.openapi.application.TransactionGuardImpl.access$200(TransactionGuardImpl.java:21)
	at com.intellij.openapi.application.TransactionGuardImpl$2.run(TransactionGuardImpl.java:196)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:805)
	at com.intellij.openapi.application.impl.ApplicationImpl.lambda$invokeLater$4(ApplicationImpl.java:348)
	at com.intellij.openapi.application.impl.FlushQueue.doRun(FlushQueue.java:82)
	at com.intellij.openapi.application.impl.FlushQueue.runNextEvent(FlushQueue.java:131)
	at com.intellij.openapi.application.impl.FlushQueue.flushNow(FlushQueue.java:47)
	at com.intellij.openapi.application.impl.FlushQueue$FlushNow.run(FlushQueue.java:187)
	at java.desktop/java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:313)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:776)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:727)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:721)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:85)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:746)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:891)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:760)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$6(IdeEventQueue.java:447)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:818)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$7(IdeEventQueue.java:446)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:805)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:492)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)
~~~

","2"
"IDEA-325066","IntelliJ IDEA","","F: ControlFlowAnalyzer.visitIfStatement (Extract method)","Exception Analyzer","12/07/2023 05:42","23/11/2023 07:00",,"Normal","Exception",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Exception Analyzer issue
 [EA-837558](https://jb-web.exa.aws.intellij.net/issue/837558)
 ### Properties
 * __Reports count__: 4  (23-11-2023)(+2 since 13-11-2023)
 * __Since__: 232.4243
 * __Until__: 233.11799.30
 
### Stacktrace
~~~stacktrace
com.intellij.diagnostic.Freeze
	at com.intellij.codeInspection.dataFlow.java.ControlFlowAnalyzer.visitIfStatement(ControlFlowAnalyzer.java:739)
	at com.intellij.psi.impl.source.tree.java.PsiIfStatementImpl.accept(PsiIfStatementImpl.java:194)
	at com.intellij.codeInspection.dataFlow.java.ControlFlowAnalyzer.visitCodeBlock(ControlFlowAnalyzer.java:333)
	at com.intellij.psi.impl.source.tree.java.PsiCodeBlockImpl.accept(PsiCodeBlockImpl.java:212)
	at com.intellij.codeInspection.dataFlow.java.ControlFlowAnalyzer.buildControlFlow(ControlFlowAnalyzer.java:130)
	at com.intellij.codeInspection.dataFlow.java.JavaDataFlowIRProvider.createControlFlow(JavaDataFlowIRProvider.java:14)
	at com.intellij.codeInspection.dataFlow.lang.ir.DataFlowIRProvider.lambda$forElement$1(DataFlowIRProvider.java:52)
	at com.intellij.codeInspection.dataFlow.lang.ir.DataFlowIRProvider$$Lambda$7723/0x00000008033ea108.apply(Unknown Source)
	at java.base@17.0.6/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at com.intellij.codeInspection.dataFlow.lang.ir.DataFlowIRProvider.forElement(DataFlowIRProvider.java:50)
	at com.intellij.codeInspection.dataFlow.java.ControlFlowAnalyzer.buildFlow(ControlFlowAnalyzer.java:2454)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.buildFlow(StandardDataFlowRunner.java:168)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.analyzeMethod(StandardDataFlowRunner.java:149)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.analyzeMethod(StandardDataFlowRunner.java:114)
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer$Companion.inferNullability(CodeFragmentAnalyzer.kt:223)
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer$Companion.inferNullability(CodeFragmentAnalyzer.kt:266)
	at com.intellij.refactoring.extractMethod.newImpl.ExtractMethodAnalyzerKt.findVariableData(ExtractMethodAnalyzer.kt:199)
	at com.intellij.refactoring.extractMethod.newImpl.ExtractMethodAnalyzerKt.findExtractOptions(ExtractMethodAnalyzer.kt:42)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.DuplicatesMethodExtractorKt.findExtractOptions(DuplicatesMethodExtractor.kt:282)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.DuplicatesMethodExtractorKt.access$findExtractOptions(DuplicatesMethodExtractor.kt:1)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.DuplicatesMethodExtractor$Companion.create(DuplicatesMethodExtractor.kt:49)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.DuplicatesMethodExtractorKt.extractInDialog(DuplicatesMethodExtractor.kt:291)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor.restartInDialog(InplaceMethodExtractor.kt:184)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor$afterTemplateStart$2.invoke(InplaceMethodExtractor.kt:162)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor$afterTemplateStart$2.invoke(InplaceMethodExtractor.kt:162)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.ExtractMethodPopupProvider$createPanel$panel$1$3$1.invoke(ExtractMethodPopupProvider.kt:72)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.ExtractMethodPopupProvider$createPanel$panel$1$3$1.invoke(ExtractMethodPopupProvider.kt:72)
	at com.intellij.ui.components.ActionLink._init_$lambda$1(ActionLink.kt:32)
	at com.intellij.ui.components.ActionLink$$Lambda$9121/0x0000000803a2e060.actionPerformed(Unknown Source)
	at java.desktop/javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:1972)
	at java.desktop/javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2313)
	at java.desktop/javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:405)
	at java.desktop/javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:262)
	at java.desktop/javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:279)
	at java.desktop/java.awt.Component.processMouseEvent(Component.java:6657)
	at java.desktop/javax.swing.JComponent.processMouseEvent(JComponent.java:3385)
	at java.desktop/java.awt.Component.processEvent(Component.java:6422)
	at java.desktop/java.awt.Container.processEvent(Container.java:2266)
	at java.desktop/java.awt.Component.dispatchEventImpl(Component.java:5027)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2324)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4954)
	at java.desktop/java.awt.LightweightDispatcher.processMouseEvent(Container.java:4581)
	at java.desktop/java.awt.LightweightDispatcher.dispatchEvent(Container.java:4522)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2310)
	at java.desktop/java.awt.Window.dispatchEventImpl(Window.java:2808)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:791)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:740)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:734)
	at java.base@17.0.6/java.security.AccessController.executePrivileged(AccessController.java:776)
	at java.base@17.0.6/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base@17.0.6/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.base@17.0.6/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:97)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:764)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:762)
	at java.base@17.0.6/java.security.AccessController.executePrivileged(AccessController.java:776)
	at java.base@17.0.6/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base@17.0.6/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:761)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.kt:668)
	at com.intellij.ide.IdeEventQueue.dispatchMouseEvent(IdeEventQueue.kt:616)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.kt:571)
	at com.intellij.ide.IdeEventQueue.access$_dispatchEvent(IdeEventQueue.kt:68)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:352)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:351)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:787)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:351)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:346)
	at com.intellij.ide.IdeEventQueueKt.performActivity$lambda$1(IdeEventQueue.kt:996)
	at com.intellij.ide.IdeEventQueueKt$$Lambda$680/0x00000008007c23d8.run(Unknown Source)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:113)
	at com.intellij.ide.IdeEventQueueKt.performActivity(IdeEventQueue.kt:996)
	at com.intellij.ide.IdeEventQueue.dispatchEvent$lambda$5(IdeEventQueue.kt:346)
	at com.intellij.ide.IdeEventQueue$$Lambda$673/0x00000008007bb860.run(Unknown Source)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:858)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.kt:388)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:207)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:128)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:117)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:105)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:92)

~~~

","0"
"IDEA-338742","IntelliJ IDEA","","Automatic extract delegate refactor error","lizagaadrian","21/11/2023 16:45","21/11/2023 16:46",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2023.2.5 (232.10227.8)",,"Submitted","Not specified","IJ_Java_QA","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","

IU-232.10227.8, JRE 17.0.9+7-b1000.46x64 JetBrains s.r.o., OS Mac OS X(aarch64) v13.2.1, screens 3840.0x2160.0; Retina

```java
2023-11-21 20:43:34,648 [  17079] SEVERE - #c.i.i.p.PluginManager - class com.intellij.psi.impl.source.tree.java.PsiKeywordImpl cannot be cast to class com.intellij.psi.PsiJavaFile (com.intellij.psi.impl.source.tree.java.PsiKeywordImpl and com.intellij.psi.PsiJavaFile are in unnamed module of loader com.intellij.ide.plugins.cl.PluginClassLoader @5b9501f6)
java.lang.ClassCastException: class com.intellij.psi.impl.source.tree.java.PsiKeywordImpl cannot be cast to class com.intellij.psi.PsiJavaFile (com.intellij.psi.impl.source.tree.java.PsiKeywordImpl and com.intellij.psi.PsiJavaFile are in unnamed module of loader com.intellij.ide.plugins.cl.PluginClassLoader @5b9501f6)
	at com.intellij.refactoring.extractclass.ExtractClassProcessor.buildClass(ExtractClassProcessor.java:733)
	at com.intellij.refactoring.extractclass.ExtractClassProcessor.lambda$new$0(ExtractClassProcessor.java:135)
	at com.intellij.openapi.command.WriteCommandAction$BuilderImpl.lambda$compute$3(WriteCommandAction.java:166)
	at com.intellij.openapi.command.WriteCommandAction$BuilderImpl.lambda$doRunWriteCommandAction$1(WriteCommandAction.java:149)
	at com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(ApplicationImpl.java:992)
	at com.intellij.openapi.command.WriteCommandAction$BuilderImpl.lambda$doRunWriteCommandAction$2(WriteCommandAction.java:147)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:219)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:184)
	at com.intellij.openapi.command.WriteCommandAction$BuilderImpl.doRunWriteCommandAction(WriteCommandAction.java:156)
	at com.intellij.openapi.command.WriteCommandAction$BuilderImpl.run(WriteCommandAction.java:123)
	at com.intellij.openapi.command.WriteCommandAction$BuilderImpl.compute(WriteCommandAction.java:166)
	at com.intellij.refactoring.extractclass.ExtractClassProcessor.<init>(ExtractClassProcessor.java:135)
	at com.intellij.refactoring.extractclass.ExtractClassDialog.doAction(ExtractClassDialog.java:142)
	at com.intellij.refactoring.ui.RefactoringDialog.doRefactorAction(RefactoringDialog.java:145)
	at com.intellij.refactoring.ui.RefactoringDialog$RefactorAction.actionPerformed(RefactoringDialog.java:251)
	at java.desktop/javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:1972)
	at com.intellij.openapi.ui.DialogWrapper$3.fireActionPerformed(DialogWrapper.java:785)
	at java.desktop/javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2313)
	at java.desktop/javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:405)
	at java.desktop/javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:262)
	at java.desktop/javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:279)
	at java.desktop/java.awt.Component.processMouseEvent(Component.java:6657)
	at java.desktop/javax.swing.JComponent.processMouseEvent(JComponent.java:3385)
	at java.desktop/java.awt.Component.processEvent(Component.java:6422)
	at java.desktop/java.awt.Container.processEvent(Container.java:2266)
	at java.desktop/java.awt.Component.dispatchEventImpl(Component.java:5027)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2324)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4954)
	at java.desktop/java.awt.LightweightDispatcher.processMouseEvent(Container.java:4581)
	at java.desktop/java.awt.LightweightDispatcher.dispatchEvent(Container.java:4522)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2310)
	at java.desktop/java.awt.Window.dispatchEventImpl(Window.java:2808)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:794)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:739)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:733)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:97)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:766)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:764)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:763)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.kt:690)
	at com.intellij.ide.IdeEventQueue.dispatchMouseEvent(IdeEventQueue.kt:638)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.kt:592)
	at com.intellij.ide.IdeEventQueue.access$_dispatchEvent(IdeEventQueue.kt:67)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:369)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:368)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:787)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:368)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:363)
	at com.intellij.ide.IdeEventQueueKt.performActivity$lambda$1(IdeEventQueue.kt:997)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:105)
	at com.intellij.ide.IdeEventQueueKt.performActivity(IdeEventQueue.kt:997)
	at com.intellij.ide.IdeEventQueue.dispatchEvent$lambda$7(IdeEventQueue.kt:363)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:861)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.kt:405)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:207)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:128)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:121)
	at java.desktop/java.awt.WaitDispatchSupport$2.run(WaitDispatchSupport.java:191)
	at java.desktop/java.awt.WaitDispatchSupport$4.run(WaitDispatchSupport.java:236)
	at java.desktop/java.awt.WaitDispatchSupport$4.run(WaitDispatchSupport.java:234)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:318)
	at java.desktop/java.awt.WaitDispatchSupport.enter(WaitDispatchSupport.java:234)
	at java.desktop/java.awt.Dialog.lambda$show$2(Dialog.java:1081)
	at java.desktop/sun.awt.SunToolkit.performOnMainThreadIfNeeded(SunToolkit.java:2164)
	at java.desktop/java.awt.Dialog.show(Dialog.java:1041)
	at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(DialogWrapperPeerImpl.java:737)
	at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(DialogWrapperPeerImpl.java:462)
	at com.intellij.openapi.ui.DialogWrapper.doShow(DialogWrapper.java:1685)
	at com.intellij.openapi.ui.DialogWrapper.show(DialogWrapper.java:1643)
	at com.intellij.refactoring.ui.RefactoringDialog.show(RefactoringDialog.java:106)
	at com.intellij.refactoring.extractclass.ExtractClassHandler.invoke(ExtractClassHandler.java:55)
	at com.intellij.refactoring.actions.BaseRefactoringAction.performRefactoringAction(BaseRefactoringAction.java:161)
	at com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(BaseRefactoringAction.java:110)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.doPerformActionOrShowPopup(ActionUtil.java:339)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.lambda$performActionDumbAwareWithCallbacks$4(ActionUtil.java:313)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performDumbAwareWithCallbacks(ActionUtil.java:362)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAwareWithCallbacks(ActionUtil.java:313)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.invokeAction(ActionUtil.java:538)
	at com.intellij.ui.popup.ActionPopupStep.performAction(ActionPopupStep.java:266)
	at com.intellij.ui.popup.ActionPopupStep.lambda$onChosen$3(ActionPopupStep.java:243)
	at com.intellij.ui.popup.AbstractPopup.lambda$dispose$18(AbstractPopup.java:1625)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.lambda$doWhenFocusSettlesDown$3(FocusManagerImpl.java:173)
	at com.intellij.util.ui.EdtInvocationManager.invokeLaterIfNeeded(EdtInvocationManager.java:33)
	at com.intellij.ide.IdeEventQueue.ifFocusEventsInTheQueue(IdeEventQueue.kt:210)
	at com.intellij.ide.IdeEventQueue.executeWhenAllFocusEventsLeftTheQueue(IdeEventQueue.kt:176)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:169)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:163)
	at com.intellij.ui.popup.AbstractPopup.dispose(AbstractPopup.java:1623)
	at com.intellij.ui.popup.WizardPopup.dispose(WizardPopup.java:165)
	at com.intellij.ui.popup.list.ListPopupImpl.dispose(ListPopupImpl.java:394)
	at com.intellij.ui.popup.PopupFactoryImpl$ActionGroupPopup.dispose(PopupFactoryImpl.java:293)
	at com.intellij.openapi.util.ObjectTree.runWithTrace(ObjectTree.java:129)
	at com.intellij.openapi.util.ObjectTree.executeAll(ObjectTree.java:161)
	at com.intellij.openapi.util.Disposer.dispose(Disposer.java:262)
	at com.intellij.openapi.util.Disposer.dispose(Disposer.java:250)
	at com.intellij.ui.popup.WizardPopup.disposeAllParents(WizardPopup.java:273)
	at com.intellij.ui.popup.list.ListPopupImpl.disposePopup(ListPopupImpl.java:496)
	at com.intellij.ui.popup.list.ListPopupImpl.handleNextStep(ListPopupImpl.java:523)
	at com.intellij.ui.popup.list.ListPopupImpl._handleSelect(ListPopupImpl.java:483)
	at com.intellij.ui.popup.list.ListPopupImpl.handleSelect(ListPopupImpl.java:429)
	at com.intellij.ui.popup.PopupFactoryImpl$ActionGroupPopup.handleSelect(PopupFactoryImpl.java:305)
	at com.intellij.ui.popup.list.ListPopupImpl$MyMouseListener.mouseReleased(ListPopupImpl.java:699)
	at java.desktop/java.awt.AWTEventMulticaster.mouseReleased(AWTEventMulticaster.java:298)
	at java.desktop/java.awt.Component.processMouseEvent(Component.java:6657)
	at java.desktop/javax.swing.JComponent.processMouseEvent(JComponent.java:3385)
	at com.intellij.ui.popup.list.ListPopupImpl$MyList.processMouseEvent(ListPopupImpl.java:764)
	at java.desktop/java.awt.Component.processEvent(Component.java:6422)
	at java.desktop/java.awt.Container.processEvent(Container.java:2266)
	at java.desktop/java.awt.Component.dispatchEventImpl(Component.java:5027)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2324)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4954)
	at java.desktop/java.awt.LightweightDispatcher.processMouseEvent(Container.java:4581)
	at java.desktop/java.awt.LightweightDispatcher.dispatchEvent(Container.java:4522)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2310)
	at java.desktop/java.awt.Window.dispatchEventImpl(Window.java:2808)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:794)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:739)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:733)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:97)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:766)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:764)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:763)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.kt:690)
	at com.intellij.ide.IdeEventQueue.dispatchMouseEvent(IdeEventQueue.kt:638)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.kt:592)
	at com.intellij.ide.IdeEventQueue.access$_dispatchEvent(IdeEventQueue.kt:67)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:369)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:368)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:787)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:368)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:363)
	at com.intellij.ide.IdeEventQueueKt.performActivity$lambda$1(IdeEventQueue.kt:997)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:113)
	at com.intellij.ide.IdeEventQueueKt.performActivity(IdeEventQueue.kt:997)
	at com.intellij.ide.IdeEventQueue.dispatchEvent$lambda$7(IdeEventQueue.kt:363)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:861)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.kt:405)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:207)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:128)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:117)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:105)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:92)
```","0"
"IDEA-338665","IntelliJ IDEA","","""Move Instance Method"" asks to make method static, then does nothing","Daniel Chýlek","21/11/2023 06:23","21/11/2023 11:39",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2023.3 Beta (233.11799.6)",,"Submitted","Not specified","IJ_Java_QA","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","***What steps will reproduce the issue?***
1. Move a simple instance method to another class, for example:
```java
	public String test() {
		return ""abc"";
	}
```

 When I use the ""Move"" refactoring, I get this dialog:

![](image.png){width=50%}


***What is the expected result?***

I expect ""No"" to close the dialog and let me move the method, and ""Yes"" to make the method static and then let me move it.

***What happens instead?***

If I click ""No"", nothing happens. If I click ""Yes"", it makes the method static and nothing happens.

Note that I ran into this while trying to move a JUnit `@Test` method, in which case IntelliJ should not even ask me if I want to make it static, because `@Test` methods cannot be static and making them static breaks the test.

[idea.log](idea.log)","0"
"IDEA-324021","IntelliJ IDEA","","Improve discoverability and conversion of intentions and refactorings","Alexandr Suhinin","30/06/2023 04:24","20/11/2023 05:30",,"Normal","Meta data.Issue",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"To be discussed","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","**\#Possible solutions**

Clean up intentions/refactorings (actions with low usages or conversion rate):

* remove
* move to rare refactorings plugin (?)","0"
"IDEA-323077","IntelliJ IDEA","","Show only some refactorings in Refactor This by default and fold everything else","Egor Sergeev","20/06/2023 11:26","19/11/2023 15:25",,"Normal","Feature",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Problem

Many refactorings in the Refactor Increase the cognitive load when a user tries to find the proper option. Besides that, it reduces the chances that users may read the description of refactorings, which causes decreasing refactorings usage.

### Evidence

* Java refactorings usage
  ![](Frame 140.png){width=371px}

### Suggested solution

* Collapse rarely used refactorings under the spoiler by default. Show only the following refactorings:
  * Rename
  * Change Signature
  * Introduce Variable, Constant, Field, Parameter, Extract Method
  * Inline
  * Move Members
* Show all refactorings with a shortcut in the Refactor This menu
  * I suggest the same one as for the Refactor This (Ctrl+T)
  * We can automatically unfold when the user focuses Expand option with the keyboard
  * Unfold with speadsearch","0"
"IDEA-334146","IntelliJ IDEA","kotlin-internal-user","Rename refactoring doesn't work in external worksheets with Android plugin enabled","Timur Aliberdov","27/07/2023 11:45","16/11/2023 13:25",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","2024.1","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Create a Kotlin project via New Project Wizard. Open an external worksheet (or create one inside project and move to an excluded directory. E.g.: `build/`):

#### Project structure
![](image.png){width=70%}

#### build/external.ws.kts
```kotlin
fun foo() = 1

val bar = 2

foo()
bar
```

#### Problem description
Check that Android plugin is enabled:

![](image1.png){width=30%}

Try renaming a function `foo`, then a value `bar`. Note that `foo` is renamed successfully but `bar`'s usage is not renamed:

![](image2.png){width=30%}

Now disable Android plugin and repeat. Everything is renamed correctly.

#### Extra information

>IntelliJ IDEA 2023.2 (Community Edition)
>Build #IC-232.8660.185, built on July 26, 2023
>Kotlin: 232-1.9.0-IJ8660.185

Seems like `com.android.tools.idea.lang.proguardR8.ProguardR8UseScopeEnlarger` adds some files to the scope, making it something like `union(LocalSearchScope(worksheetFile), some_android_files)`.
And after that `com.intellij.refactoring.rename.RenameUtil#processUsages` modifies the useScope:
```java
if (!(useScope instanceof LocalSearchScope)) {
    useScope = searchScope.intersectWith(useScope);
}
```","1"
"IDEA-336461","IntelliJ IDEA","","Imports optimizer breaks java file","Hendrik.freytag","27/10/2023 05:05","15/11/2023 18:16",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2023.2.4 (232.10203.2)",,"Open","Not specified","IJ_Java_QA","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","The import optimizer breaks the java file if

* there is a class called Record
* there are more classes in that package that the imports are combined to \*
* the package name starts with import

E.g. following structure

* abc
  * importpackage
    * A.java
    * B.java
    * C.java
    * D.java
    * Record.java
  * Test.java

The Java files in `importpackage` are simple classes and the Test.java looks like this:

```java
package abc;

import abc.importpackage.Record;
import abc.importpackage.*;

public class Test {
    public static void main(String[] args) {
        Record record = null;

        A a = null;
        B b = null;
        C c = null;
        D d = null;
    }
}
```

Then I click on the menu *Code -\> Optimize Imports*

The result is the following broken Java file:

```java
package abc;

import abc.
import abc.importpackage.Record;

public class Test {
    public static void main(String[] args) {
        Record record = null;

        A a = null;
        B b = null;
        C c = null;
        D d = null;
    }
}
```

As you see the import line `import abc.` is broken.

IU-232.10203.10, JRE 17.0.8.1+7-b1000.32x64 JetBrains s.r.o., OS Mac OS X(aarch64) v14.0, screens 2560.0x1440.0

![](image2.png)

![](image.png)

![](image1.png)","0"
"IDEA-338048","IntelliJ IDEA","","'Create class ...' quick-fix shouldn't try to create a class which will satisfy every overload of the method","Andrey Turbanov","14/11/2023 07:13","15/11/2023 09:59",,"Normal","Usability Problem",,"IJ_Java_Developer","Java. Refactorings","2023.2.5 (232.10227.8)",,"Open","Not specified","IJ_Java_QA","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"ivan.pajic","Unknown","***What steps will reproduce the issue?***
1\. Create maven project and add 'com.lmax:disruptor:3.4.4' as a dependency
2\. Create java class:
```
package org.bgi;

import com.lmax.disruptor.dsl.Disruptor;

public class CreateHandler {
    void addHandler(Disruptor<StringBuilder> disruptor) {
        disruptor.handleEventsWith(new MyEventHandler());
    }
}
```
3\.  Invoke quick-fix `Create class 'MyEventHandler'` on red code

***What is the expected result?***
IDEA creates class `MyEventHandler` which doesn't implement any interface OR ask what interface it should implement.

***What happens instead?***
IDEA creates class `MyEventHandler` which implements all 3 possible interfaces
```
package org.bgi;

public class MyEventHandler implements com.lmax.disruptor.EventHandler<? super StringBuilder>,
        com.lmax.disruptor.dsl.EventProcessorFactory<StringBuilder>, com.lmax.disruptor.EventProcessor
{
}
```","0"
"IDEA-260899","IntelliJ IDEA","","Allow just moving files, dumbly","Eugene Petrenko","01/02/2021 08:56","06/11/2023 13:46",,"Major","Usability Problem",,"Roman.Ivanov","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","No matter what I select in the move dialog (move everything from directory X)
The IDE tries to help me (I was not asking for!)
It took too much time in scanning

![](image.png)","3"
"IDEA-335158","IntelliJ IDEA","idea_old_regression","Confusing warning about not-accessible parent member when I perform 'Inline Super Class'","Andrey Turbanov","17/10/2023 13:50","01/11/2023 07:42",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2022.1.4 (221.6008.13), 2023.3 EAP 4 (233.9802.14)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2024.1","No zendesk mentions",,"sergei.riabinin","Unknown","```
package org.ininesuper;

public class AbstractFixSession {
    protected final String cool = ""true"";
}
```

```
package org.ininesuper;

public class AbstractActiveFixSession extends AbstractFixSession<caret> {
}
```

```
package org.ininesuper.server;

import org.ininesuper.AbstractActiveFixSession;

public class ServerFixSession extends AbstractActiveFixSession {
    public void logSomething() {
        if (Math.random() > 0.5) {
            System.out.println(cool);
        }
    }
}
```

***What steps will reproduce the issue?***
1\. Invoke 'Inline Super Class' refactoring for AbstractFixSession
2\. Select `Inline all references and remove the class` and click ""Refactor""

***What is the expected result?***
IDEA inlines the super class without any warnings. Field `cool` is protected and will be accessible in `ServerFixSession` after inlining of `AbstractFixSession`.

***What happens instead?***
IDEA shows confusing warning
![](изображение.png)","0"
"IDEA-332679","IntelliJ IDEA","","Add move/extract class to the floating toolbar","Alexandr Suhinin","18/09/2023 10:18","31/10/2023 04:24",,"Normal","Feature",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","![](image.png){width=70%}","0"
"IDEA-121030","IntelliJ IDEA","patch_welcome","Replace constructor with builder.  Create builder as an inner class.","Yaroslav Bedrov","20/02/2014 05:41","29/10/2023 17:35",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 27 Oct 2023, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/5675844"">#5675844</a></td><td>27 Oct 2023</td><td>Margarita Tyumenkova</td><td>stefax71.bluepine@gmail.com</td><td>Creating a builder</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">I love the functionality to automatically generate a builder for a constructor.  I&#39;m looking for one additional thing: have the option to create the builder as an inner class.</div>
","5"
"IDEA-326498","IntelliJ IDEA","","UI/UX issues with ""Introduce Parameter"" Delegate button/action","Gregory Ledenev","26/07/2023 23:39","27/10/2023 13:14",,"Normal","Usability Problem",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"To be discussed","2023.3","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","1. It is totally unclear what is it for from the first (and second :() sight (see a screenshot). maxDelegate? Why? What is it? Bug? Delegate for what? Then I realized it is clickable! Because it is a button it should be rendered as such making it clear that it is an action, not a label, state, whatever.
2. It is better to have an ""Add"" icon for this button. E.g. ""+ Delegate"" looks more readable.
3. As it is a toggle button it would be better to change icon to indicate its state vs. just changing background. So it would switch between ""+ Delegate"" and ""x Delegate"".
4. Tooltip for that button is unclear. I was forced to click to the button and check results to understand what this action actually does.","1"
"IDEA-334583","IntelliJ IDEA","","Replace 'do while' loop with 'while' loop breaks code","Thomas Singer","11/10/2023 06:11","25/10/2023 07:33",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2021.3.3 (213.7172.25)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","For following code
```java
public TypeList process(String name, Location location, TypeList input) {
				do {
					Type type = input.type();
					if (type != Type.U8) {
						break;
					}

					final TypeList prev = input.prev();
					type = prev.type();
					if (type != Type.U8) {
						break;
					}

					return prev.prev();
				}
				while (false);
				throw new InvalidTypeException(location, name + "" requires 2 "" + Type.U8 + "", but got "" + input);
			}
```
`do` and the `false` in `while (false)` are highlighted. Pressing Alt+Enter on `do` and selecting **Replace 'do while' loop with 'while' loop** will produce following buggy code:
```java
			public TypeList process(String name, Location location, TypeList input) {
				Type type = input.type();
				if (type != Type.U8) {
					break;
				}

				TypeList prev = input.prev();
				type = prev.type();
				if (type != Type.U8) {
					break;
				}

				return prev.prev();
				while (false) {
					type = input.type();
					if (type != Type.U8) {
						break;
					}

					prev = input.prev();
					type = prev.type();
					if (type != Type.U8) {
						break;
					}

					return prev.prev();
				}
				throw new InvalidTypeException(location, name + "" requires 2 "" + Type.U8 + "", but got "" + input);
			}
```

IU-232.9921.47, JRE 17.0.8+7-b1000.22x64 JetBrains s.r.o., OS Windows 10(amd64) v10.0 , screens 7680.0x4320.0","0"
"IDEA-336034","IntelliJ IDEA","","Improvements for 'Inline Parameter'","Sergei Riabinin","24/11/2022 06:56","24/10/2023 11:08",,"Normal","Meta data.Issue",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","artem.miagkov","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Seems that we don't even have a guide/example for it in guide <https://www.jetbrains.com/help/idea/2022.3/inline.html>, so probably we can create a follow up in DOC after this ticket is investigated

https://analytics.jetbrains.com/statistics/query/657358c7426d495ba3f58e9c9ca4d48f?st=group-with-segments&s=metric_users&o=desc
![](Screenshot 2023-10-24 at 16.04.20.png)","0"
"IDEA-335897","IntelliJ IDEA","","Improve ""Inline variable"" refactoring","Sergei Riabinin","23/10/2023 08:13","24/10/2023 09:42",,"Normal","Meta data.Issue",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","https://analytics.jetbrains.com/statistics/query/e44996e492ac4fe7b41cd01465df7a8b?st=group-with-segments&s=metric_users&o=desc

![](Screenshot 2023-10-24 at 14.40.41.png)","0"
"IDEA-335984","IntelliJ IDEA","","Stuck in empty modal window after cancelling the safe-delete search","Tagir Valeev","23/10/2023 13:44","23/10/2023 13:49",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2023.3",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","I've cancelled safe-delete search (probably several times in a row) and stuck in this modal window:

![](image.png)

It can be resized, but cannot be closed: Alt+F4 and Escape don't work and it has no [x] icon; I see Close item in Alt+Space menu, but it does nothing. While UI events are processed, I cannot activate main IDE frame, so it looks like I have to kill it. Nothing was printed in the log during this problem. Here's the IDE start info:

Probably there's a workaround to revive IDE if it's stuck in such a state?

```
2023-10-23 15:28:17,899 [     23]   INFO - #c.i.p.i.b.AppStarter - ------------------------------------------------------ IDE STARTED ------------------------------------------------------
2023-10-23 15:28:17,909 [     33]   INFO - #c.i.p.i.b.AppStarter - JNA library (64-bit) loaded in 0 ms
2023-10-23 15:28:17,911 [     35]   INFO - #c.i.p.i.b.AppStarter - IDE: IntelliJ IDEA (build #IU-233.11213, Sun, 22 Oct 2023 22:51:00 GMT)
2023-10-23 15:28:17,912 [     36]   INFO - #c.i.p.i.b.AppStarter - OS: Windows (10.0)
2023-10-23 15:28:17,913 [     37]   INFO - #c.i.p.i.b.AppStarter - JRE: 17.0.9+7-b1087.3, amd64 (JetBrains s.r.o.)
2023-10-23 15:28:17,913 [     37]   INFO - #c.i.p.i.b.AppStarter - JVM: 17.0.9+7-b1087.3 (OpenJDK 64-Bit Server VM)
2023-10-23 15:28:17,917 [     41]   INFO - #c.i.p.i.b.AppStarter - PID: 22352
2023-10-23 15:28:17,931 [     55]   INFO - #c.i.u.i.PageCacheUtils - File page caching params:
2023-10-23 15:28:17,932 [     56]   INFO - #c.i.u.i.PageCacheUtils - 	DEFAULT_PAGE_SIZE: 10485760
2023-10-23 15:28:17,933 [     57]   INFO - #c.i.u.i.PageCacheUtils - 	Direct memory to use, max: 5221908480
2023-10-23 15:28:17,933 [     57]   INFO - #c.i.u.i.PageCacheUtils - 	FilePageCache: regular + lock-free (LOCK_FREE_PAGE_CACHE_ENABLED:true)
2023-10-23 15:28:17,934 [     58]   INFO - #c.i.u.i.PageCacheUtils - 	NEW_PAGE_CACHE_MEMORY_FRACTION: 0.20000000298023224
2023-10-23 15:28:17,934 [     58]   INFO - #c.i.u.i.PageCacheUtils - 	Regular FilePageCache: 503316478 bytes
2023-10-23 15:28:17,935 [     59]   INFO - #c.i.u.i.PageCacheUtils - 	New     FilePageCache: 125829122 bytes (+ up to 10.0% overflow)
2023-10-23 15:28:17,935 [     59]   INFO - #c.i.u.i.PageCacheUtils - 	DirectByteBuffers pool: 104857600 bytes
2023-10-23 15:28:18,015 [    139]   INFO - #c.i.p.i.b.AppStarter - JVM options: [exit, -XX:ErrorFile=C:\Users\Tagir.Valeev\\java_error_in_idea64_%p.log, -XX:HeapDumpPath=C:\Users\Tagir.Valeev\\java_error_in_idea64.hprof, -Xms128m, -Xmx2048m, -XX:ReservedCodeCacheSize=512m, -XX:+UseG1GC, -XX:SoftRefLRUPolicyMSPerMB=50, -XX:CICompilerCount=2, -XX:+HeapDumpOnOutOfMemoryError, -XX:-OmitStackTraceInFastThrow, -XX:+IgnoreUnrecognizedVMOptions, -XX:CompileCommand=exclude,com/intellij/openapi/vfs/impl/FilePartNodeRoot,trieDescend, -XX:MaxJavaStackTraceDepth=10000, -ea, -Dsun.io.useCanonCaches=false, -Dsun.java2d.metal=true, -Djbr.catch.SIGABRT=true, -Djdk.http.auth.tunneling.disabledSchemes="""", -Djdk.attach.allowAttachSelf=true, -Djdk.module.illegalAccess.silent=true, -Dkotlinx.coroutines.debug=off, -Dintellij.plugins.custom.built.in.repository.url=https://buildserver.labs.intellij.net/guestAuth/repository/download/ijplatform_master_IdeaInstallersBuild/386047452:id/IU-plugins/plugins.xml, -Xmx5000m, -Didea.is.internal=true, -Didea.fatal.error.notification=enabled, -Djetbrains.tbe.show.error.popup=true, -Dide.smart.update=true, -Djetbrains.tbe.analytics.fus.enable=true, -Dide.experimental.ui.show.resume=true, -Djetbrains.tbe.branding.icon.show=false, -Dshared.indexes.download.auto.consent=true, -Dshared.indexes.jdk.download=false, -Dshared.indexes.maven.download=false, -Didea.force.freeze.reports=true, -Dide.no.platform.update=true, -Dtoolbox.notification.token=nvPE0JHMap_4vVuA5-OY0br23PSt2DpX-8A1Gn9cC9U=, -Dtoolbox.notification.portFile=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213.vmoptions.port, -Didea.plugins.path=C:\\Users\\Tagir.Valeev\\AppData\\Local\\JetBrains\\Toolbox\\apps\\IDEA-U\\ch-0\\233.11213.plugins, -Didea.diagnostic.opentelemetry.metrics.file=, -Djetbrains.tbe.appType=IDEA-U, -Djetbrains.tbe.trust=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\enterprise-config.json, -Djetbrains.tbe.auth=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\bin\jetbrains-toolbox.exe, -Didea.plugin.hosts=https://tbe.labs.jb.gg/api/plugin-repository?channel=Stable, -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5006, -Djb.vmOptionsFile=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213.vmoptions, -Djava.system.class.loader=com.intellij.util.lang.PathClassLoader, -Didea.vendor.name=JetBrains, -Didea.paths.selector=IntelliJIdea2023.3, -Djna.boot.library.path=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213/lib/jna/amd64, -Dpty4j.preferred.native.folder=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213/lib/pty4j, -Djna.nosys=true, -Djna.noclasspath=true, -Dintellij.platform.runtime.repository.path=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213/modules/module-descriptors.jar, -Dsplash=true, -Daether.connector.resumeDownloads=false, -Dskiko.library.path=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213/lib/skiko-awt-runtime-all, -Dcompose.swing.render.on.graphics=true, --add-opens=java.base/java.io=ALL-UNNAMED, --add-opens=java.base/java.lang=ALL-UNNAMED, --add-opens=java.base/java.lang.ref=ALL-UNNAMED, --add-opens=java.base/java.lang.reflect=ALL-UNNAMED, --add-opens=java.base/java.net=ALL-UNNAMED, --add-opens=java.base/java.nio=ALL-UNNAMED, --add-opens=java.base/java.nio.charset=ALL-UNNAMED, --add-opens=java.base/java.text=ALL-UNNAMED, --add-opens=java.base/java.time=ALL-UNNAMED, --add-opens=java.base/java.util=ALL-UNNAMED, --add-opens=java.base/java.util.concurrent=ALL-UNNAMED, --add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED, --add-opens=java.base/java.util.concurrent.locks=ALL-UNNAMED, --add-opens=java.base/jdk.internal.vm=ALL-UNNAMED, --add-opens=java.base/sun.nio.ch=ALL-UNNAMED, --add-opens=java.base/sun.nio.fs=ALL-UNNAMED, --add-opens=java.base/sun.security.ssl=ALL-UNNAMED, --add-opens=java.base/sun.security.util=ALL-UNNAMED, --add-opens=java.base/sun.net.dns=ALL-UNNAMED, --add-opens=java.desktop/java.awt=ALL-UNNAMED, --add-opens=java.desktop/java.awt.dnd.peer=ALL-UNNAMED, --add-opens=java.desktop/java.awt.event=ALL-UNNAMED, --add-opens=java.desktop/java.awt.image=ALL-UNNAMED, --add-opens=java.desktop/java.awt.peer=ALL-UNNAMED, --add-opens=java.desktop/java.awt.font=ALL-UNNAMED, --add-opens=java.desktop/javax.swing=ALL-UNNAMED, --add-opens=java.desktop/javax.swing.plaf.basic=ALL-UNNAMED, --add-opens=java.desktop/javax.swing.text.html=ALL-UNNAMED, --add-opens=java.desktop/sun.awt.datatransfer=ALL-UNNAMED, --add-opens=java.desktop/sun.awt.image=ALL-UNNAMED, --add-opens=java.desktop/sun.awt.windows=ALL-UNNAMED, --add-opens=java.desktop/sun.awt=ALL-UNNAMED, --add-opens=java.desktop/sun.font=ALL-UNNAMED, --add-opens=java.desktop/sun.java2d=ALL-UNNAMED, --add-opens=java.desktop/sun.swing=ALL-UNNAMED, --add-opens=java.desktop/com.sun.java.swing=ALL-UNNAMED, --add-opens=jdk.attach/sun.tools.attach=ALL-UNNAMED, --add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED, --add-opens=jdk.internal.jvmstat/sun.jvmstat.monitor=ALL-UNNAMED, --add-opens=jdk.jdi/com.sun.tools.jdi=ALL-UNNAMED, -Dide.native.launcher=true, -Djcef.sandbox.ptr=0000025FE461BB20]
2023-10-23 15:28:18,016 [    140]   INFO - #c.i.p.i.b.AppStarter - args: 
2023-10-23 15:28:18,017 [    141]   INFO - #c.i.p.i.b.AppStarter - library path: C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\Git\cmd;C:\Program Files\dotnet\;C:\Program Files (x86)\gnupg\bin;C:\Users\Tagir.Valeev\AppData\Local\Microsoft\WindowsApps;C:\Lan\bin;C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\scripts;C:\Users\Tagir.Valeev\AppData\Local\Programs\Microsoft VS Code\bin;.
2023-10-23 15:28:18,017 [    141]   INFO - #c.i.p.i.b.AppStarter - boot library path: C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213\jbr\bin
2023-10-23 15:28:18,033 [    157]   INFO - #c.i.p.i.b.AppStarter - locale=en_GB JNU=Cp1251 file.encoding=Cp1251
    idea.config.path=C:\Users\Tagir.Valeev\AppData\Roaming\JetBrains\IntelliJIdea2023.3
    idea.system.path=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\IntelliJIdea2023.3
    idea.plugins.path=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-0\233.11213.plugins
    idea.log.path=C:\Users\Tagir.Valeev\AppData\Local\JetBrains\IntelliJIdea2023.3\log
2023-10-23 15:28:18,038 [    162]   INFO - #c.i.p.i.b.AppStarter - CPU cores: 16; ForkJoinPool.commonPool: java.util.concurrent.ForkJoinPool@3bb46be6[Running, parallelism = 15, size = 0, active = 0, running = 0, steals = 0, tasks = 0, submissions = 0]; factory: com.intellij.concurrency.IdeaForkJoinWorkerThreadFactory@547ac27
```

I was able to invoke UI inspector, and here's what I see:

MyDialog ""dialog27""(modalBlocker@Window): 633x195 @ 4482:812, opaque, data-provider

dialogWrapperClass = com.intellij.refactoring.safeDelete.JavaSafeDeleteProcessor$1
toString = com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog[dialog27,4482,812,633x195,layout=java.awt.BorderLayout,APPLICATION_MODAL,title=Select Methods To Propagate Parameter Deletion,defaultCloseOperation=DO_NOTHING_ON_CLOSE,rootPane=,rootPaneCheckingEnabled=true]
  accessibleName = Select Methods To Propagate Parameter Deletion

![](image1.png)

It would be nice to be able to close this window from UI inspector.

EDT from jstack output:

```
""AWT-EventQueue-0"" #105 prio=6 os_prio=0 cpu=381562.50ms elapsed=11979.16s tid=0x0000025fcab99250 nid=0x5720 waiting on condition  [0x000000669eefc000]
   java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@17.0.9/Native Method)
	- parking to wait for  <0x00000006ca442bb8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(java.base@17.0.9/LockSupport.java:341)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(java.base@17.0.9/AbstractQueuedSynchronizer.java:506)
	at java.util.concurrent.ForkJoinPool.unmanagedBlock(java.base@17.0.9/ForkJoinPool.java:3465)
	at java.util.concurrent.ForkJoinPool.managedBlock(java.base@17.0.9/ForkJoinPool.java:3436)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(java.base@17.0.9/AbstractQueuedSynchronizer.java:1623)
	at java.awt.EventQueue.getNextEvent(java.desktop/EventQueue.java:584)
	at com.intellij.ide.IdeEventQueue.getNextEvent(IdeEventQueue.kt:469)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(java.desktop/EventDispatchThread.java:194)
	at java.awt.EventDispatchThread.pumpEventsForFilter(java.desktop/EventDispatchThread.java:128)
	at java.awt.EventDispatchThread.pumpEventsForFilter(java.desktop/EventDispatchThread.java:121)
	at java.awt.WaitDispatchSupport$2.run(java.desktop/WaitDispatchSupport.java:191)
	at java.awt.WaitDispatchSupport$4.run(java.desktop/WaitDispatchSupport.java:236)
	at java.awt.WaitDispatchSupport$4.run(java.desktop/WaitDispatchSupport.java:234)
	at java.security.AccessController.executePrivileged(java.base@17.0.9/AccessController.java:776)
	at java.security.AccessController.doPrivileged(java.base@17.0.9/AccessController.java:318)
	at java.awt.WaitDispatchSupport.enter(java.desktop/WaitDispatchSupport.java:234)
	at java.awt.Dialog.lambda$show$2(java.desktop/Dialog.java:1081)
	at java.awt.Dialog$$Lambda$357/0x000000080044b718.run(java.desktop/Unknown Source)
	at sun.awt.SunToolkit.performOnMainThreadIfNeeded(java.desktop/SunToolkit.java:2170)
	at java.awt.Dialog.show(java.desktop/Dialog.java:1041)
	at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(DialogWrapperPeerImpl.java:875)
	at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(DialogWrapperPeerImpl.java:474)
	at com.intellij.openapi.ui.DialogWrapper.doShow(DialogWrapper.java:1733)
	at com.intellij.openapi.ui.DialogWrapper.show(DialogWrapper.java:1682)
	at com.intellij.openapi.ui.DialogWrapper.showAndGet(DialogWrapper.java:1696)
	at com.intellij.refactoring.safeDelete.JavaSafeDeleteProcessor.preprocessUsages(JavaSafeDeleteProcessor.java:429)
	at com.intellij.refactoring.safeDelete.SafeDeleteProcessor.preprocessUsages(SafeDeleteProcessor.java:188)
	at com.intellij.refactoring.BaseRefactoringProcessor.doRun(BaseRefactoringProcessor.java:231)
	at com.intellij.refactoring.BaseRefactoringProcessor.lambda$run$12(BaseRefactoringProcessor.java:596)
	at com.intellij.refactoring.BaseRefactoringProcessor$$Lambda$10218/0x000000080470e420.run(Unknown Source)
	at com.intellij.refactoring.BaseRefactoringProcessor.run(BaseRefactoringProcessor.java:612)
	at com.intellij.codeInsight.daemon.impl.quickfix.SafeDeleteFix.invoke(SafeDeleteFix.java:51)
	at com.intellij.codeInspection.LocalQuickFixAndIntentionActionOnPsiElement.invoke(LocalQuickFixAndIntentionActionOnPsiElement.java:31)
	at com.intellij.codeInsight.intention.impl.PriorityIntentionActionWrapper.invoke(PriorityIntentionActionWrapper.java:42)
	at com.intellij.codeInsight.intention.impl.IntentionActionWithTextCaching$MyIntentionAction.invoke(IntentionActionWithTextCaching.java:238)
	at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler.invokeIntention(ShowIntentionActionsHandler.java:398)
	at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler.lambda$chooseActionAndInvoke$10(ShowIntentionActionsHandler.java:313)
	at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler$$Lambda$10171/0x00000008046a4000.run(Unknown Source)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:224)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:176)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:166)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:152)
	at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler.chooseActionAndInvoke(ShowIntentionActionsHandler.java:312)
	at com.intellij.codeInsight.intention.impl.IntentionListStep.chooseActionAndInvoke(IntentionListStep.java:143)
	at com.intellij.codeInsight.intention.impl.IntentionListStep.lambda$applyAction$0(IntentionListStep.java:135)
	at com.intellij.codeInsight.intention.impl.IntentionListStep$$Lambda$10170/0x0000000804643c68.run(Unknown Source)
	at com.intellij.ui.popup.AbstractPopup.lambda$dispose$18(AbstractPopup.java:1733)
	at com.intellij.ui.popup.AbstractPopup$$Lambda$9847/0x00000008043a9df0.run(Unknown Source)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.lambda$doWhenFocusSettlesDown$3(FocusManagerImpl.java:169)
	at com.intellij.openapi.wm.impl.FocusManagerImpl$$Lambda$1352/0x0000000800e0d4c0.run(Unknown Source)
	at com.intellij.util.ui.EdtInvocationManager.invokeLaterIfNeeded(EdtInvocationManager.java:33)
	at com.intellij.ide.IdeEventQueue.ifFocusEventsInTheQueue(IdeEventQueue.kt:220)
	at com.intellij.ide.IdeEventQueue.executeWhenAllFocusEventsLeftTheQueue(IdeEventQueue.kt:186)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:165)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:159)
	at com.intellij.ui.popup.AbstractPopup.dispose(AbstractPopup.java:1731)
	at com.intellij.ui.popup.WizardPopup.dispose(WizardPopup.java:161)
	at com.intellij.ui.popup.list.ListPopupImpl.dispose(ListPopupImpl.java:407)
	at com.intellij.openapi.util.ObjectTree.runWithTrace(ObjectTree.java:130)
	at com.intellij.openapi.util.ObjectTree.executeAll(ObjectTree.java:162)
	at com.intellij.openapi.util.Disposer.dispose(Disposer.java:250)
	at com.intellij.openapi.util.Disposer.dispose(Disposer.java:238)
	at com.intellij.ui.popup.WizardPopup.disposeAllParents(WizardPopup.java:269)
	at com.intellij.ui.popup.list.ListPopupImpl.disposePopup(ListPopupImpl.java:518)
	at com.intellij.ui.popup.list.ListPopupImpl.handleNextStep(ListPopupImpl.java:542)
	at com.intellij.ui.popup.list.ListPopupImpl._handleSelect(ListPopupImpl.java:505)
	at com.intellij.ui.popup.list.ListPopupImpl.handleSelect(ListPopupImpl.java:449)
	at com.intellij.ui.popup.list.ListPopupImpl$1.actionPerformed(ListPopupImpl.java:290)
	at com.intellij.ui.popup.WizardPopup.proceedKeyEvent(WizardPopup.java:398)
	at com.intellij.ui.popup.WizardPopup.dispatch(WizardPopup.java:370)
	at com.intellij.ui.popup.PopupDispatcher.dispatchKeyEvent(PopupDispatcher.java:115)
	at com.intellij.ui.popup.PopupDispatcher.dispatch(PopupDispatcher.java:156)
	at com.intellij.ide.IdePopupManager.dispatch(IdePopupManager.java:111)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.kt:562)
	at com.intellij.ide.IdeEventQueue.access$_dispatchEvent(IdeEventQueue.kt:72)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:355)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:354)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:793)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:354)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:349)
	at com.intellij.ide.IdeEventQueueKt.performActivity$lambda$1(IdeEventQueue.kt:1014)
	at com.intellij.ide.IdeEventQueueKt$$Lambda$625/0x0000000800687998.run(Unknown Source)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:114)
	at com.intellij.ide.IdeEventQueueKt.performActivity(IdeEventQueue.kt:1014)
	at com.intellij.ide.IdeEventQueue.dispatchEvent$lambda$7(IdeEventQueue.kt:349)
	at com.intellij.ide.IdeEventQueue$$Lambda$621/0x0000000800684ed0.run(Unknown Source)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:862)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.kt:391)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(java.desktop/EventDispatchThread.java:207)
	at java.awt.EventDispatchThread.pumpEventsForFilter(java.desktop/EventDispatchThread.java:128)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(java.desktop/EventDispatchThread.java:117)
	at java.awt.EventDispatchThread.pumpEvents(java.desktop/EventDispatchThread.java:113)
	at java.awt.EventDispatchThread.pumpEvents(java.desktop/EventDispatchThread.java:105)
	at java.awt.EventDispatchThread.run(java.desktop/EventDispatchThread.java:92)
```

Other threads look irrelevant. Attaching them just for the case.","0"
"IDEA-314029","IntelliJ IDEA","CSE,customer: Stripe","Refactors should not fail when references exist in read-only generated content roots","Keith Lea","23/02/2023 11:42","23/10/2023 12:55",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2022.3",,"Open","2023.3","No tester","No","Yes","Not specified","Not specified","2023.1","<details><summary>Last ticket submitted at 16 Jun 2023, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/5252254"">#5252254</a></td><td>16 Jun 2023</td><td></td><td>keithl</td><td>:wave::skin-tone-2: could w...</td></tr></table></details>","1","No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Open project at <https://github.com/keithl-stripe/intellij-generated-refactor-repro>
2\. Open `src/com/stripe/generatedrefactoringbug/lib/NonGeneratedObject.java` in editor
3\. Attempt to Refactor-\>Rename `NonGeneratedObject` to something else (`NonGeneratedObject2` is fine)
***What is the expected result?***

References in `Main` are changed, and no error message surfaces. (References in read-only generated content root are ignored by the refactoring engine.)

***What happens instead?***

Refactoring cannot be performed: File ... is located in a read-only container.

![](Screenshot 2023-02-23 at 9.34.24 AM.png){width=70%}

***Refactorings affected***

This seems to affect at least:

* Rename class
* Move class
* Move package
* Change signature

***More context***

We use a custom IntelliJ plugin to import Bazel projects into IntelliJ. When Bazel generates code (e.g., for protobuf), it places the generated .java files in JAR files (it calls these ""source jars""). We need to add this generated code to the IntelliJ project, so we add the root of the Jar file as a content root, and mark it as ""generated source."" (Google/JetBrains Bazel plugin adds them as libraries, but we cannot do this because libraries seem to require class files, and we don't produce any during our sync.)","1"
"IDEA-334515","IntelliJ IDEA","rdct/autotests","NullPointerException at SuggestedRefactoringState.createRestoredDeclarationCopy","Dmitrii Denisov","10/10/2023 10:03","23/10/2023 09:19",,"Normal","Exception",,"Roman.Ivanov","Java. Refactorings","2023.3",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","On random typing in java-file (JavaTypingStressTest), quite rare, started from 05 Oct 2023
[Exception history](https://buildserver.labs.intellij.net/test/2735196961944488103?currentProjectId=ijplatform_master_RemoteDevelopment&expandTestHistoryInvestigationsSection=true&expandTestHistoryChartSection=true)

```
During 'JavaTypingStressTest.1 client[IDEA_ULTIMATE]' which has passed: 
Errors happened in IDE started in test, it might not directly relate to CWM or Remote dev functionality
Link to the test where the error has actually reproduced: https://buildserver.labs.intellij.net/buildConfiguration/ijplatform_master_Idea_CodeWithMeWindowsTests_1/378789983?buildTab=tests&status=all&name=JavaTypingStressTest.1+client%5BIDEA_ULTIMATE%5D
[Reps: 1]
  #0: Host: exception occurred while 'Between test task executions':
java.lang.NullPointerException: There was an error of type java.lang.NullPointerException
  at com.intellij.refactoring.suggested.SuggestedRefactoringState.createRestoredDeclarationCopy(SuggestedRefactoringState.kt:144)
  at com.intellij.refactoring.suggested.SuggestedRefactoringState.restoredDeclarationCopy(SuggestedRefactoringState.kt:117)
  at com.intellij.java.refactoring.suggested.JavaSuggestedRefactoringAvailability$amendStateInBackground$1.invokeSuspend(JavaSuggestedRefactoringAvailability.kt:41)
  at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
  at kotlin.sequences.SequenceBuilderIterator.hasNext(SequenceBuilder.kt:129)
  at com.intellij.refactoring.suggested.SuggestedRefactoringChangeCollector.amendStateInBackground$lambda$4(SuggestedRefactoringChangeCollector.kt:141)
  at com.intellij.util.RunnableCallable.call(RunnableCallable.java:20)
  at com.intellij.util.RunnableCallable.call(RunnableCallable.java:11)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$OTelMonitor.callWrapped(NonBlockingReadActionImpl.java:840)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$OTelMonitor$MonitoredComputation.call(NonBlockingReadActionImpl.java:872)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.insideReadAction(NonBlockingReadActionImpl.java:604)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$attemptComputation$4(NonBlockingReadActionImpl.java:567)
  at com.intellij.openapi.application.impl.ApplicationImpl.tryRunReadAction(ApplicationImpl.java:1094)
  at com.intellij.openapi.progress.util.ProgressIndicatorUtils.lambda$runInReadActionWithWriteActionPriority$0(ProgressIndicatorUtils.java:73)
  at com.intellij.openapi.progress.util.ProgressIndicatorUtilService.runActionAndCancelBeforeWrite(ProgressIndicatorUtilService.java:73)
  at com.intellij.openapi.progress.util.ProgressIndicatorUtils.runActionAndCancelBeforeWrite(ProgressIndicatorUtils.java:128)
  at com.intellij.openapi.progress.util.ProgressIndicatorUtils.lambda$runWithWriteActionPriority$1(ProgressIndicatorUtils.java:111)
  at com.intellij.openapi.progress.ProgressManager.lambda$runProcess$0(ProgressManager.java:73)
  at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$1(CoreProgressManager.java:192)
  at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$executeProcessUnderProgress$12(CoreProgressManager.java:610)
  at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:685)
  at com.intellij.openapi.progress.impl.CoreProgressManager.computeUnderProgress(CoreProgressManager.java:641)
  at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:609)
  at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:78)
  at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:179)
  at com.intellij.openapi.progress.ProgressManager.runProcess(ProgressManager.java:73)
  at com.intellij.openapi.progress.util.ProgressIndicatorUtils.runWithWriteActionPriority(ProgressIndicatorUtils.java:108)
  at com.intellij.openapi.progress.util.ProgressIndicatorUtils.runInReadActionWithWriteActionPriority(ProgressIndicatorUtils.java:73)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.attemptComputation(NonBlockingReadActionImpl.java:567)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$transferToBgThread$1(NonBlockingReadActionImpl.java:466)
  at com.intellij.codeWithMe.ClientId$Companion.decorateRunnable$lambda$4(ClientId.kt:305)
  at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$transferToBgThread$2(NonBlockingReadActionImpl.java:481)
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
  at java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:702)
  at java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:699)
  at java.security.AccessController.doPrivileged(AccessController.java:399)
  at java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:699)
  at java.lang.Thread.run(Thread.java:833)

(Details can be found in the idea.log of the the 'Host').
```","0"
"IDEA-147894","IntelliJ IDEA","reproduced","Introduce/Inline variable changes behavior","Andrey Turbanov","13/11/2015 06:31","23/10/2023 08:14",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","2023.3","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Java 8<br/><pre class=""wikicode prettyprint"">public class data.Issue {<br/><br/>    public static void main(String[] args) {<br/>        consume(get());<br/>    }<br/><br/>    public static &lt;T extends data.Issue&gt; T get() {<br/>        return null;<br/>    }<br/><br/>    public static void consume(data.Issue... v) {<br/>        System.out.println(&quot;vararg&quot;);<br/>    }<br/><br/>    public static void consume(Collection v) {<br/>        System.out.println(&quot;collection&quot;);<br/>    }<br/>}</pre>This code prints &quot;collection&quot;<br/><br/>Try to introduce variable from get() call. It transforms to<br/><pre class=""wikicode prettyprint"">        data.Issue v = get();<br/>        consume(v);</pre>And code will print &quot;vararg&quot;<br/><br/>Try to inline v again. Behavior changed again</div>
","1"
"IDEA-333591","IntelliJ IDEA","","Inline variable: make it safe","Delany","28/09/2023 08:22","23/10/2023 08:13",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","Suppose I have

```java
  void setup() {
    var call = new DirectTransactCall();
    call.setRequestId(""3fa85f64-5711-4562-b3fc-2c963f61afa6"");
    expected = call;
  }
```

and I ask Intellij 2023.2.2 to inline the call variable

```
  void setup() {
    new DirectTransactCall().setRequestId(""3fa85f64-5711-4562-b3fc-2c963f61afa6"");
    expected = new DirectTransactCall();
  }
```

Where

```
  @Override
  public void setRequestId(String id) {
    this.requestId = id;
  }
```

According to <https://www.jetbrains.com/help/idea/inline-dialogs.html>

> The Inline Variable refactoring allows you to replace a redundant variable with its value.

But in this case the var should not be considered ""redundant"". And yet the inline operation succeeds, breaking the code, and without so much as a warning.

If its possible, the inline refactoring should consider the finality of the expected variable, and consider changing it to

```java
  void setup() {
    expected = new DirectTransactCall();
    expected.setRequestId(""3fa85f64-5711-4562-b3fc-2c963f61afa6"")
  }
```

And if not, then at least refuse to inline, or produce some warning.","0"
"IDEA-305679","IntelliJ IDEA","","Inline variables with generics produce incorrect code","Tesla Zhang","08/11/2022 20:25","23/10/2023 08:13",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2022.3 Beta (223.7401.7)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
class A {
  record R<T>() {}
}
public static void main(String[] args) {
  A.R<Object> r = new A.R<>();
  System.out.println(Arrays.asList(r));
}
```

Inline the local variable `r`, IDEA produces incorrect code.

Env:

```
IntelliJ IDEA 2022.3 Beta (Ultimate Edition)
Build #IU-223.7401.7, built on November 2, 2022
Licensed to IntelliJ IDEA EAP user: Yinsen Zhang
Expiration date: December 2, 2022
Runtime version: 17.0.5+1-b653.6 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
Windows 11 10.0
GC: G1 Young Generation, G1 Old Generation
Memory: 2048M
Cores: 20
Registry:
    debugger.new.tool.window.layout=true
    ide.experimental.ui=true

Non-Bundled Plugins:
    PsiViewer (223-SNAPSHOT)
    com.github.copilot (1.1.35.2063)
    org.jetbrains.idea.grammar (2021.1.2)
    org.ice1000.kala (0.7)
    com.perl5 (223-SNAPSHOT.1)

Kotlin: 223-1.7.20-release-201-IJ7401.7
```


","0"
"IDEA-180435","IntelliJ IDEA","reproduced","Inlining variable which uses declared in try-with-resource variable may create red code","Timur Yuldashev","11/10/2017 15:01","23/10/2023 08:13",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2017.3.7 (173.4710.11)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","2023.3","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 181.52</strong><br/><br/>Based on sample from <a href=""/issue/IDEA-121153"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-668202"" title=""Cannot inline variable returned outside try block"">IDEA-121153</a>, inlining <span class=""monospace"">s</span> creates uncompilable code<br/><br/><pre class=""wikicode prettyprint"">public class Test {<br/>    String foo()<br/>    {<br/>        String s;<br/>        try (Resource r = getResource()) {<br/>            &lt;caret&gt;s&lt;/caret&gt; = r.get();<br/>        }<br/>        return s;<br/>    }<br/><br/>    public Resource getResource() {<br/>        return new Resource();<br/>    }<br/><br/>    class Resource implements AutoCloseable{<br/><br/>        @Override<br/>        public void close() {<br/><br/>        }<br/><br/>        public String get() {<br/>            return &quot;&quot;;<br/>        }<br/>    }<br/>}</pre><br/><strong>After inlining</strong><br/><pre class=""wikicode prettyprint"">...<br/>    String foo()<br/>    {<br/>        try (Resource r = getResource()) {<br/>        }<br/>        return r.get(); // r - undefined<br/>    }<br/>...</pre></div>
","0"
"IDEA-174294","IntelliJ IDEA","reproduced","inline variable misses out name clash","Nikolay Metchev","11/06/2017 09:41","23/10/2023 08:13",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","2023.3","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><br/>IC-172.2827.15, JRE 1.8.0_152-release-884-b5x64 JetBrains s.r.o, OS Windows 10(amd64) v10.0 , screens 1920x1080<br/><br/>Before:<br/><br/><code class=""inline-code"">class A {<br/>    static int f = 42;<br/><br/>    int foo() {<br/>        int r = f;//inline r<br/>        int f = 23;<br/>        return r;<br/>    }<br/>}</code><br/><br/>After:<br/><br/><code class=""inline-code"">class A {<br/>    static int f = 42;<br/><br/>    int foo() {<br/>        int f = 23;<br/>        return f;<br/>    }<br/>}</code><br/><br/><br/>Expected:<br/><br/><code class=""inline-code"">class A {<br/>    static int f = 42;<br/><br/>    int foo() {<br/>        int f = 23;<br/>        return A.f;<br/>    }<br/>}</code></div>
","0"
"IDEA-165255","IntelliJ IDEA","reproduced","Inline variable of functional type involving ternary operator produces incorrect code","Tagir Valeev","09/12/2016 00:57","23/10/2023 08:13",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","2023.3","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider the following method:<br/><br/><pre class=""wikicode prettyprint"">  int get(boolean b) {<br/>    IntSupplier s = b ? () -&gt; 1 : () -&gt; 2;<br/>    return s.getAsInt();<br/>  }</pre><br/>This code is correct, but when I inline the <code class=""inline-code"">s</code> variable, I have an incorrect code:<br/><br/><pre class=""wikicode prettyprint"">  int get(boolean b) {<br/>    return ((IntSupplier)(b ? () -&gt; 1 : () -&gt; 2)).getAsInt();<br/>  }</pre><br/>When inlining ternary operator which has lambdas/method references in true/false branches, the cast should be pushed down to operands:<br/><br/><pre class=""wikicode prettyprint"">  int get(boolean b) {<br/>    return (b ? (IntSupplier)() -&gt; 1 : (IntSupplier)() -&gt; 2).getAsInt();<br/>  }</pre><br/>Of course things become more complicated when there&#39;s nested ternary like <code class=""inline-code"">IntSupplier s = b ? () -&gt; 1 : b1 ? () -&gt; 2 : () -&gt; 3</code> (the cast should be pushed down further).</div>
","1"
"IDEA-335494","IntelliJ IDEA","patch_attached","""Move Instance Method"" and ""Move Static Members"" dialogs have clashing mnemonics","Margarita Tyumenkova","18/10/2023 17:46","20/10/2023 08:23",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2023.2.3 (232.10072.27)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 18 Oct 2023, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/5644876"">#5644876</a></td><td>18 Oct 2023</td><td>Margarita Tyumenkova</td><td>kanailaurent@gmail.com</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","1","sergei.riabinin","Unknown","This ticket is based on support feedback.



**Scenario:**

1) Make **Refactor \| [Move Instance Method](https://www.jetbrains.com/help/idea/2021.3/move-refactorings.html?keymap=primary_windows#move_instance) **or **Refactor \| Move Members**

**Expected result:** you can use ""Alt + O"" to choose ""Protected""

**Actual result:** ""Open in editor"" and ""Protected"" have clashing mnemonics

![](image.png){width=380px} ![](image1.png){width=439px}","0"
"IDEA-325061","IntelliJ IDEA","","F: PlainDescriptor.calcCanBeNull (Extract method)","Exception Analyzer","12/07/2023 05:28","09/10/2023 15:53",,"Normal","Exception",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","2023.3","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Exception Analyzer issue

[EA-584536](https://jb-web.exa.aws.intellij.net/issue/584536)

### Properties

* **Reports count**\: 15
* **Since**\: 222.3345.16
* **Until**\: 222.3345.16

### Stacktrace

```stacktrace
com.intellij.diagnostic.Freeze
	at com.intellij.codeInspection.dataFlow.jvm.descriptors.PlainDescriptor.calcCanBeNull(PlainDescriptor.java:149)
	at com.intellij.codeInspection.dataFlow.jvm.descriptors.PsiVarDescriptor.getInitialDfType(PsiVarDescriptor.java:73)
	at com.intellij.codeInspection.dataFlow.jvm.descriptors.PlainDescriptor.getInitialDfType(PlainDescriptor.java:31)
	at com.intellij.codeInspection.dataFlow.value.DfaVariableValue.getInherentType(DfaVariableValue.java:160)
	at com.intellij.codeInspection.dataFlow.memory.DfaMemoryStateImpl.getDfType(DfaMemoryStateImpl.java:1216)
	at com.intellij.codeInspection.dataFlow.java.JavaDfaHelpers.dropLocality(JavaDfaHelpers.java:43)
	at com.intellij.codeInspection.dataFlow.java.inst.JvmPushInstruction.eval(JvmPushInstruction.java:47)
	at com.intellij.codeInspection.dataFlow.lang.ir.EvalInstruction.accept(EvalInstruction.java:42)
	at com.intellij.codeInspection.dataFlow.interpreter.StandardDataFlowInterpreter.acceptInstruction(StandardDataFlowInterpreter.java:316)
	at com.intellij.codeInspection.dataFlow.interpreter.StandardDataFlowInterpreter.interpret(StandardDataFlowInterpreter.java:138)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.interpret(StandardDataFlowRunner.java:183)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.analyzeFlow(StandardDataFlowRunner.java:163)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.analyzeMethod(StandardDataFlowRunner.java:149)
	at com.intellij.codeInspection.dataFlow.StandardDataFlowRunner.analyzeMethod(StandardDataFlowRunner.java:114)
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer$Companion.inferNullability(CodeFragmentAnalyzer.kt:239)
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer$Companion.inferNullability(CodeFragmentAnalyzer.kt:251)
	at com.intellij.refactoring.extractMethod.newImpl.ExtractMethodAnalyzerKt.findVariableData(ExtractMethodAnalyzer.kt:209)
	at com.intellij.refactoring.extractMethod.newImpl.ExtractMethodAnalyzerKt.findExtractOptions(ExtractMethodAnalyzer.kt:38)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.DuplicatesMethodExtractor.replaceDuplicates(DuplicatesMethodExtractor.kt:328)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor$extractAndRunTemplate$templateState$2.invoke(InplaceMethodExtractor.kt:110)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor$extractAndRunTemplate$templateState$2.invoke(InplaceMethodExtractor.kt:38)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.ExtractMethodTemplateBuilder$createTemplate$1$4.templateFinished(ExtractMethodTemplateBuilder.kt:129)
	at com.intellij.codeInsight.template.impl.TemplateState.fireTemplateFinished(TemplateState.java:1338)
	at com.intellij.codeInsight.template.impl.TemplateState.finishTemplate(TemplateState.java:976)
	at com.intellij.codeInsight.template.impl.TemplateState.nextTab(TemplateState.java:840)
	at com.intellij.codeInsight.template.impl.actions.NextVariableAction$Handler.doExecute(NextVariableAction.java:44)
	at com.intellij.openapi.editor.actionSystem.DynamicEditorActionHandler.doExecute(DynamicEditorActionHandler.java:63)
	at com.intellij.openapi.editor.actionSystem.EditorActionHandler.lambda$execute$4(EditorActionHandler.java:199)
	at com.intellij.openapi.editor.actionSystem.EditorActionHandler$$Lambda$10160/0x00000008048eb4a0.perform(Unknown Source)
	at com.intellij.openapi.editor.actionSystem.EditorActionHandler.doIfEnabled(EditorActionHandler.java:89)
	at com.intellij.openapi.editor.actionSystem.EditorActionHandler.execute(EditorActionHandler.java:198)
	at com.intellij.openapi.editor.actionSystem.EditorAction.lambda$actionPerformed$0(EditorAction.java:93)
	at com.intellij.openapi.editor.actionSystem.EditorAction$$Lambda$10159/0x00000008048eb250.run(Unknown Source)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:219)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:174)
	at com.intellij.openapi.editor.actionSystem.EditorAction.actionPerformed(EditorAction.java:102)
	at com.intellij.openapi.editor.actionSystem.EditorAction.actionPerformed(EditorAction.java:77)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.doPerformActionOrShowPopup(ActionUtil.java:315)
	at com.intellij.openapi.keymap.impl.ActionProcessor.performAction(ActionProcessor.java:47)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(IdeKeyEventDispatcher.java:581)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.lambda$doPerformActionInner$9(IdeKeyEventDispatcher.java:703)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$$Lambda$8890/0x0000000804259120.run(Unknown Source)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:105)
	at com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(TransactionGuardImpl.java:94)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.lambda$doPerformActionInner$10(IdeKeyEventDispatcher.java:703)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$$Lambda$8889/0x0000000804258ed0.run(Unknown Source)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performDumbAwareWithCallbacks(ActionUtil.java:337)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.doPerformActionInner(IdeKeyEventDispatcher.java:700)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:644)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:592)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processActionOrWaitSecondStroke(IdeKeyEventDispatcher.java:475)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.inInitState(IdeKeyEventDispatcher.java:464)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(IdeKeyEventDispatcher.java:229)
	at com.intellij.ide.IdeEventQueue.dispatchKeyEvent(IdeEventQueue.java:804)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:740)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$6(IdeEventQueue.java:439)
	at com.intellij.ide.IdeEventQueue$$Lambda$696/0x000000080079f930.compute(Unknown Source)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:791)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$7(IdeEventQueue.java:438)
	at com.intellij.ide.IdeEventQueue$$Lambda$694/0x000000080079e928.run(Unknown Source)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:113)
	at com.intellij.ide.IdeEventQueue.performActivity(IdeEventQueue.java:604)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$8(IdeEventQueue.java:436)
	at com.intellij.ide.IdeEventQueue$$Lambda$689/0x000000080078fa48.run(Unknown Source)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:881)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:484)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:207)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:128)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:117)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:105)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:92)
```","0"
"IDEA-334254","IntelliJ IDEA","","Rename of the annotation qualifier doesn't work","Roman Ivanov","06/10/2023 09:05","06/10/2023 09:05",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Steps to reproduce:
Create in the source root file RuntimeAnnotationWithEnums

```
@RuntimeAnnotationWithEnums.RuntimeAnn
public class RuntimeAnnotationWithEnums {
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.TYPE)
    @interface RuntimeAnn {

    }
}
```

Rename file to RuntimeAnnotationWithArgs

Qualifier is not changed, but should be.
![](image.png){width=70%}","0"
"IDEA-334214","IntelliJ IDEA","","Field accessors renamed on field rename even when unselected with Lombok ToString in us","theotherp","06/10/2023 04:08","06/10/2023 08:01",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2023.2.2 (232.9921.47), 2023.3 EAP 2 (233.8264.8)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","***What steps will reproduce the issue?***
1\. Open the attached file .
2\. Rename the field and disable any of the accessors to be renamed.
***What is the expected result?***

Only the field is renamed.

***What happens instead?***

The accessors are renamed. Removing the @ToString annotation prevents this.



IntelliJ IDEA 2023.3 EAP (Ultimate Edition)

Build #IU-233.9102.97, built on October 4, 2023

Licensed to IntelliJ IDEA EAP user: Theodor Peterson

Expiration date: November 3, 2023

Runtime version: 17.0.8.1+7-b1070.2 amd64

VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.

Windows 10.0

GC: G1 Young Generation, G1 Old Generation

Memory: 4096M

Cores: 32

Registry:

  debugger.watches.in.variables=false

  debugger.new.tool.window.layout=true

  ide.experimental.ui=true

  editor.minimap.enabled=true

Kotlin: 233-1.9.0-release-358-IJ9102.97


","0"
"IDEA-333934","IntelliJ IDEA","","Assertion in SuggestedRefactoringState when running stress test RandomTypingTest","Artem Bukhonov","02/10/2023 16:47","04/10/2023 09:20",,"Normal","Exception",,"Tagir.Valeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","The test:
```
com.jetbrains.rdct.cwm.distributed.typing.RandomTypingTest#random typing with a host and single client
```
Exception:

```
2023-10-02 21:41:05,211 [  43976] SEVERE - #o.j.c.AsyncPromise - Failed requirement.
java.lang.IllegalArgumentException: Failed requirement.
	at com.intellij.refactoring.suggested.SuggestedRefactoringState.createRestoredDeclarationCopy(SuggestedRefactoringState.kt:127)
	at com.intellij.refactoring.suggested.SuggestedRefactoringState.restoredDeclarationCopy(SuggestedRefactoringState.kt:117)
	at com.intellij.java.refactoring.suggested.JavaSuggestedRefactoringAvailability$amendStateInBackground$1.invokeSuspend(JavaSuggestedRefactoringAvailability.kt:41)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlin.sequences.SequenceBuilderIterator.hasNext(SequenceBuilder.kt:129)
	at com.intellij.refactoring.suggested.SuggestedRefactoringChangeCollector.amendStateInBackground$lambda$4(SuggestedRefactoringChangeCollector.kt:141)
	at com.intellij.util.RunnableCallable.call(RunnableCallable.java:20)
	at com.intellij.util.RunnableCallable.call(RunnableCallable.java:11)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$OTelMonitor.callWrapped(NonBlockingReadActionImpl.java:840)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$OTelMonitor$MonitoredComputation.call(NonBlockingReadActionImpl.java:872)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.insideReadAction(NonBlockingReadActionImpl.java:604)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$attemptComputation$4(NonBlockingReadActionImpl.java:567)
	at com.intellij.openapi.application.impl.ApplicationImpl.tryRunReadAction(ApplicationImpl.java:1079)
	at com.intellij.openapi.progress.util.ProgressIndicatorUtils.lambda$runInReadActionWithWriteActionPriority$0(ProgressIndicatorUtils.java:73)
	at com.intellij.openapi.progress.util.ProgressIndicatorUtilService.runActionAndCancelBeforeWrite(ProgressIndicatorUtilService.java:73)
	at com.intellij.openapi.progress.util.ProgressIndicatorUtils.runActionAndCancelBeforeWrite(ProgressIndicatorUtils.java:128)
	at com.intellij.openapi.progress.util.ProgressIndicatorUtils.lambda$runWithWriteActionPriority$1(ProgressIndicatorUtils.java:111)
	at com.intellij.openapi.progress.ProgressManager.lambda$runProcess$0(ProgressManager.java:73)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$1(CoreProgressManager.java:192)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$executeProcessUnderProgress$12(CoreProgressManager.java:610)
	at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:685)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computeUnderProgress(CoreProgressManager.java:641)
	at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:609)
	at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:78)
	at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:179)
	at com.intellij.openapi.progress.ProgressManager.runProcess(ProgressManager.java:73)
	at com.intellij.openapi.progress.util.ProgressIndicatorUtils.runWithWriteActionPriority(ProgressIndicatorUtils.java:108)
	at com.intellij.openapi.progress.util.ProgressIndicatorUtils.runInReadActionWithWriteActionPriority(ProgressIndicatorUtils.java:73)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.attemptComputation(NonBlockingReadActionImpl.java:567)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$transferToBgThread$1(NonBlockingReadActionImpl.java:466)
	at com.intellij.codeWithMe.ClientId$Companion.decorateRunnable$lambda$4(ClientId.kt:302)
	at com.intellij.openapi.application.impl.NonBlockingReadActionImpl$Submission.lambda$transferToBgThread$2(NonBlockingReadActionImpl.java:481)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:702)
	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:699)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:699)
	at java.base/java.lang.Thread.run(Thread.java:833)
```","0"
"IDEA-333755","IntelliJ IDEA","","When converting a java record to class annotations are placed","peter-janssen","29/09/2023 19:51","02/10/2023 08:07",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2021.3.3 (213.7172.25)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","***What steps will reproduce the issue?***
1\. Create java record with annotated fields (e.g. DeprecatedConfigurationProperty)
2\. Convert record to class 
***What is the expected result?***
Annotations are placed according to their Target annotation
***What happens instead?***
Annotations restricted to, for example, methods are placed on constructor parameters.

*If you can’t provide IDE logs, please provide information about the IDE version and the OS you are using. You can copy these details from the About dialog in the Help or App menu.*
```text
IntelliJ IDEA 2023.2.2 (Ultimate Edition)
Build #IU-232.9921.47, built on September 12, 2023
***
Runtime version: 17.0.8+7-b1000.22 x86_64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
macOS 13.6
GC: G1 Young Generation, G1 Old Generation
Memory: 4096M
Cores: 16
Metal Rendering is ON
Registry:
    debugger.new.tool.window.layout=true
    ide.experimental.ui=true
    scala.erase.compiler.process.jdk.once=false

Non-Bundled Plugins:
    com.github.b3er.idea.plugins.arc.browser (0.32)
    org.nik.presentation-assistant (1.0.10)
    YAML/Ansible support (0.11.2)
    String Manipulation (9.11.3)
    org.jetbrains.plugins.hocon (2023.1.0)
    MavenRunHelper (4.26.0-IJ2022.2)
    org.intellij.scala (2023.2.23)

Kotlin: 232-1.9.0-IJ9921.47
```","0"
"IDEA-332489","IntelliJ IDEA","","Inlining refactoring operation leads to naming conflicts","CH_D","14/09/2023 22:34","27/09/2023 10:19",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","***What steps will reproduce the issue?***
1\.  Perform an inline refactoring operation on the 'foo()' method in the test case.

```
public class TestCase{
	public void main() {
		class T {
			public T() {}
		}
		/*]*/foo();/*[*/
	}
	
	public void foo() {
		class T {
			T t;
			public T() {}
		}
	}
}
```

2\. Result of the inline refactoring execution

![](1694741464573.png)

3\. The result indicates a naming conflict between the inner class 'T' in the 'foo()' method and the inner class 'T' in the 'main' method. Therefore, when performing an inline refactoring, it is important to check for naming conflicts between identifiers within the method body and the target method body.

***What happens instead?***

*Please attach the [IDE logs](https://intellij-support.jetbrains.com/hc/en-us/articles/207241085) to the issue. You can get them by selecting Collect Logs and Diagnostic Data from the Help menu.*

*If possible, please attach a code sample, screenshot, or screencast that illustrates the problem.*

*To make the issue visible only to the JetBrains team, you can set its visibility to the `jetbrains-team` group. With the exception of images, all attachments are visible only to the JetBrains team by default.*

*If you can’t provide IDE logs, please provide information about the IDE version and the OS you are using. You can copy these details from the About dialog in the Help or App menu.*

*If you are experiencing performance issues, please also [attach the relevant snapshots](https://intellij-support.jetbrains.com/hc/en-us/articles/207241235).*","0"
"IDEA-333120","IntelliJ IDEA","","Inline Class may break code if constructor is called inside ternary operation","Nikolay Chashnikov","22/09/2023 12:06","27/09/2023 08:28",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2022.2",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","Invoke ""Inline to Anonymous Class"" action on `StringWrapper1` declaration in the following code:
```java
public class Foo {
    StringWrapper2 foo(Object param) {
        return param instanceof String ? new StringWrapper1((String) param) : null;
    }

    private static class StringWrapper1 extends StringWrapper2 {
        public StringWrapper1(String param) {
            super(param);
        }
    }

    private static class StringWrapper2 {
        public StringWrapper2(String param) {
        }
    }
}
```
It'll replace `foo` body with the following code which apparently has different behavior:
```
        String param1 = (String) param;
        return param instanceof String ? new StringWrapper2(param1) : null;
```","0"
"IDEA-311157","IntelliJ IDEA","","Change signature refactoring doesn't consider usages in guards while deleting record component","Roman Ivanov","22/01/2023 09:51","26/09/2023 04:44",,"Normal","Bug",,"Aleksey.Dobrynin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","2023.3","No zendesk mentions",,"No assigned support","Unknown","Example:
```
public record Point(int x, int y) {
    void foo(Object obj) {
        switch (obj) {
            case Point(int x, int y) when x > 10 -> {}
            default -> {}
        }
    }
}
```
Invoke change signature refactoring on the Point. 
Delete record component x.
Result looks like this:
```
public record Point(int y) {
    void foo(Object obj) {
        switch (obj) {
            case Point(int y) when x > 10 -> {}
            default -> {}
        }
    }
}
```
X is highlighted as unresolved.
It is worth showing a conflict in this case.","1"
"IDEA-308578","IntelliJ IDEA","","Converting class to record only renames direct super classes","Roman Golyshev","14/12/2022 12:13","05/09/2023 04:17",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2022.2.5 (222.4554.10)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","How to reproduce:

```java
interface Base {
  String getFoo();
}

interface Child extends Base {
  @Override
  String getFoo();
}

static final class Foo implements Child {
  private final String foo;

  Foo(String foo) { this.foo = foo; }

  @Override
  public String getFoo() { return foo; }
}
```

Invoke ""Convert to record"" intention on `Foo` class

Expected result:

```java
interface Base {
  String foo();
}

interface Child extends Base {
  @Override
  String foo();
}

record Foo(String foo) implements Child {
}
```

Actual result: 
```java
interface Base {
  String getFoo();
}

interface Child extends Base {
  String foo();
}

record Foo(String foo) implements Child {
}
```

The code no longer compiles since `Foo` class does not implement `getFoo` anymore","0"
"IDEA-330992","IntelliJ IDEA","","Convert to Instance Method on Best Practice Java Singletons (single element Enums) creates nonsense","nico","29/08/2023 03:42","04/09/2023 11:08",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2021.3.3 (213.7172.25), 2023.2.1 (232.9559.62)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.3","No zendesk mentions",,"sergei.riabinin","Unknown","IU-232.9559.62, JRE 17.0.8+7-b1000.8x64 JetBrains s.r.o., OS Linux(amd64) v5.15.0-79-generic, screens 1920.0x969.0

Having worked on this type of team before, I know a minimum viable repro is the best bug report. The library and its dependency are enclosed, though I didn't bother to check the build after gzipping (it's standard Gradle + Java, it should work...)



But the problem should be pretty evident from just looking at [this commit](https://bitbucket.org/visionary-software/measurement/commits/535a17dabb65188c691c6b2e1ab70805b9c6e0cd), specifically `ConversionStrategy`, `UnitConverter`, and any one of the oodles of files touched by using `Convert To Instance Method` on `UnitConverter#as`.



The fix for this is actually pretty straightforward, one just has to make the [reflective checks](https://bitbucket.org/visionary-software/reflexive/src/20e0433678ad23b72cb162b715f110615a1e5a9c/src/main/java/software/visionary/reflexive/Reflexive.java#lines-91) I've made in similar situations. 



(I'm releasing these reflexive under GPLv3, though I'm happy to discuss terms of alternative licensing if such functionality would help improve IntelliJ for everybody.)","0"
"IDEA-153529","IntelliJ IDEA","","Undo rename on ESC when edit local variable or parameter","Timur Yuldashev","23/03/2016 12:09","01/09/2023 12:46",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Shouldn&#39;t we undo (leave name as it was before) when user hits ESC during in-place editing of method parameter or local variable. The same as it already happens with field, method or class rename.</div>
","5"
"IDEA-207349","IntelliJ IDEA","","Actual value of parameter is always same - Doesn't infer if constant is statically imported","Janko Sokolovic","14/02/2019 23:03","31/08/2023 11:43",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2019.1 (191.6183.87)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.2.1","No zendesk mentions",,"No assigned support","Unknown","Not an actual bug, but could be optimized

Steps to reproduce:

1. Create a class A
2. Add a constant  String B inside A
3. Make a method void f1() { f2( B ); } inside A
4. Make a method void f2(String param){ System.out.println(param);} Inside A

Intellij will recommend on parameter 'param' a hint ""Inline Value..."" 

Do refactor

Notice how it is injected ""A.B"" instead of shorter version -> ""B"".","0"
"IDEA-313957","IntelliJ IDEA","","Rename is suggested when no method usages exist","Egor Sergeev","22/02/2023 15:32","30/08/2023 09:02",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","artem.miagkov","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### How to reproduce

1. Add a new method to any class so that it won't have any usage
2. Editst's name

Expected: Rename is not suggested; nothing happens

Actual: method Rename is suggested

![](Screen Recording 2023-02-22 at 20.24.48.mov){width=405px}","0"
"IDEA-144364","IntelliJ IDEA","","""Extract delegate"":  Better handling of constructors, final fields","Jonas Kvarnström","26/08/2015 05:18","29/08/2023 11:23",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If I have a class with a number of fields that I want to extract to a separate class, I can do this with &quot;extract delegate&quot;.  Often these fields are final, and the current implementation of this refactoring appears to always create an empty constructor leading to broken code.  <br/><br/>It would be nice if IDEA would instead (at least in the presence of final fields) generate a constructor that initializes all of those final fields.  Every constructor of the original class must have given explicit values to those fields, and in many cases the assignments are &quot;simple&quot; and unconditional so that IDEA should be able to convert those assignments (field by field) to a single constructor call.  There are probably edge cases to consider, such as conditional assignments or the case where side effects would occur in a different order, but the automation should still be of great help in most cases.<br/><br/>Example:<br/><pre class=""wikicode prettyprint"">public class Foo {<br/>    public final int x;<br/>    public final double y;<br/>    public final int z;<br/>    public Foo(int x, int y, int z) {<br/>        this.x = x;<br/>        this.y = y;<br/>        this.z = z;<br/>    }<br/>}</pre><br/>This would become:<br/><br/><pre class=""wikicode prettyprint"">public class Point {<br/>    public final int x;<br/>    public final double y;<br/>    public Foo(int x, int y) {<br/>        this.x = x;<br/>        this.y = y;<br/>    }<br/>}<br/>public class Foo {<br/>    public final Point p;<br/>    public final int z;<br/>    public Foo(int x, int y, int z) {<br/>        this.p = new Point(x,y);<br/>        this.z = z;<br/>    }<br/>}</pre><br/>What I get now:<br/><br/><pre class=""wikicode prettyprint"">public class Point {<br/>    public final int x; // Error<br/>    public final double y; // Error<br/><br/>    public Point() {<br/>    }<br/>}<br/><br/>public class Foo {<br/>    public final int z;<br/>    public final Point point = new Point();<br/><br/>    public Foo(int x, int y, int z) {<br/>        this.point.x = x; // Error<br/>        this.point.y = y; // Error<br/>        this.z = z;<br/>    }<br/>}</pre><br/>Or am I missing something I could do in the current version?</div>
","1"
"IDEA-327320","IntelliJ IDEA","","Introduce automatic ""Rename"" refactoring","Gregory Ledenev","02/08/2023 12:25","29/08/2023 05:57",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","In 99% of the cases renaming of identifiers leads to their refactoring. Therefore it requires pressing the shortcut or choosing the ""Rename"" refactoring from the menu in 99% of the cases. Though it is pretty easy to track where the editing occurs and if it occurs in an identifier's name - then turn ON the ""Rename"" mode automatically. Less keys to press; everything is pretty natural. There should be an ability to commit renaming without performing the refactoring e.g. by using a shortcut like Shift+Enter. And certainly there should be an option to turn OFF the automatic ""Rename"" refactoring...","1"
"IDEA-314992","IntelliJ IDEA","","""Rename Package Directories"" dialog is unclear","efeliksik","09/03/2023 06:04","24/08/2023 06:44",,"Normal","Usability Problem",,"IJ_Java_Developer","Java. Refactorings","2022.3 (223.7571.182)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.1 EAP 1 (231.4840.387)","No zendesk mentions",,"sergei.riabinin","Unknown","***What steps will reproduce the issue?***
1\. In a multi-module Java project or a project (and sometimes a project with both src/ and test/ in a module not sure) try to rename a package directory
***What is the expected result?***

Dialog would warn for multiple directories, but make clear

* what directories are in what modules
* (that would also make clear which are in the 'current module' (as the given 'Current' is, I think, only the directory initially used to indicate the refactor usecase)

\*\*\*What happens instead?

---

Dialog is quite unclear:

(I blocked the full package name in the screenshot)

![](image.png)





Found in Build #IU-223.7571.182, built on November 29, 2022, on MacOS


","0"
"IDEA-329866","IntelliJ IDEA","","Inspection for pattern matching instanceof when using Inline Cast","Manuel","15/08/2023 12:58","16/08/2023 09:36",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","When creating a new Variable like this in an instanceOf Statement, the IDE correctly suggests to use pattern matching:

`String s = (String) o;`

But when the cast is performed within another statement like this:

```java
Object o;
if (o instanceof String) {
  System.out.println((String) o);
}
```

Then the IDE does not suggest to use a pattern variable.

I would like to be able to replace it with a pattern variable like this:

```java
Object o;
if (o instanceof String s) {
  System.out.println(s);
}
```

And the name of the variable should be selected so I can give it a new name if I want to.","0"
"IDEA-326817","IntelliJ IDEA","","Extract variable could extract instanceof expression into pattern variable","Roman Ivanov","28/07/2023 12:03","16/08/2023 09:35",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Example:

```
    if (element.getContainingFile() instanceof PsiJavaFile) {
      
    }
```

If you select \`element.getContainingFile()\` and extract variable - you should be able to do it into pattern variable
Expected:

```
    if (element.getContainingFile() instanceof PsiJavaFile f) {

    }
```","0"
"IDEA-327818","IntelliJ IDEA","plugin-welcome","Add shortcut for a quick  ""Change access modifier"" action","Jacky Liu","08/08/2023 07:49","15/08/2023 08:10",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","2023.2",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 05 Aug 2023, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/5396534"">#5396534</a></td><td>05 Aug 2023</td><td>Jacky Liu</td><td>Nad Chel</td><td>Does IntelliJ have some sho...</td></tr></table></details>","1","sergei.riabinin","Unknown","***What steps will the feature be?***
1. Put the cursor at some class member method: `void foo() {}`
2. Press `Alt + Up` to widen access or `Alt + Down` to make it more restrictive.

This is from the user feedback at: https://intellij-support.jetbrains.com/hc/en-us/community/posts/12906410564242-Does-IntelliJ-have-some-shortcut-for-changing-access-modifers-","0"
"IDEA-326388","IntelliJ IDEA","","Field Name Recommendation Based on Contexts","CH_D","26/07/2023 05:09","27/07/2023 10:42",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","* According to our evaluation, the average precision of IDEA in recommending names for extract local variable refactorings is as low as 6.3%.
* The following code snippet comes from the elastic/elasticsearch (libs/nio/src/test/java/org/elasticsearch/nio/TestSelectionKey.java, commit:1d3b096374a10dadc8d2bd9b2b7088ea8e1136cb).

  ![](image.png)

  ![](image1.png)
* In this example, the original developers renamed the field ""**ops**"" (Line 18) to a new name ""**interestOps**"". For the given example,IntelliJ IDEA 

   recommends “**anInt**” instead, that is substantially different from the one chosen by the original developers.
* We suggest that we should exploit methods that return the to-be-renamed field (Line 37).  The simple names of such methods should be 

  exploited as initialization of the to-be-renamed fields. That is, we can remove special tokens (all verbs in base form) from the simple method 

  name, and take the resulting string as the new field name.
* We have validated the heuristic on 11085 field renamings conducted by the original developers in open-source applications. In total, the 

  heuristic recommended 456 names where 206 were the same as what the original developers finally used. That is, the precision is 45.18%, 

  substantially higher than that of IntelliJ IDEA.

```java
    private int ops = 0;

    public int interestOps() {
        return ops;
    }
```
actual refactoring suggestions don't have expected `interfaceOps` (IDEA-121809):
![](Screenshot 2023-07-27 at 15.37.05.png){width=70%}

```java
List<String> interface_vec = new ArrayList<>();
```
![](Screenshot 2023-07-27 at 15.38.38.png){width=70%}
`inerfaceVec` should probably be prioritized, and `interfaceList` added to possible options.","0"
"IDEA-121809","IntelliJ IDEA","","Extract variable/constant: suggest name considering method's name","Anton Makeev","07/03/2014 06:40","27/07/2023 10:42",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I would expect &#39;PROTOCOL&#39; here as an option:<br/><div class=""wiki picture""><img src=""[](Screenshot 2014-03-07 10.39.33.png)""/></div></div>
","2"
"IDEA-66783","IntelliJ IDEA","","rename variable: suggest proposals from local DFA","Taras Tielkes","18/03/2011 12:55","27/07/2023 10:33",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If the local variable is passed as an argument into method calls in the scope of the current method, the parameter names from those methods can be collected and used for name suggestions.</div>
","1"
"IDEA-326488","IntelliJ IDEA","","""Copy class"" refactoring on inner class is copying whole outer class, top-level one","Artem Miagkov","26/07/2023 19:34","27/07/2023 07:59",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Steps:

1. ```
   public class IDEA324474 {
   
       public class ABC{
          public class EFG{
             
          }
       }
   ```
2. Attempt to call ""Copy class"" refactoring on body of class ABC or class EFG
3. Set name for new class (e.g. ""Test"")

### Expected:

```
public class Test{
       public class EFG{
          
       }
    }
```

or

```
public class Test{
          
       }
```

created, respectively.



### Actual result:

```
public class Test {

    public class ABC{
       public class EFG{
          
       }
    }
```","0"
"IDEA-324664","IntelliJ IDEA","plugin-welcome","Replace 'if' with 'switch' enhancement: handle equalsIgnoreCase","J Goldberg","07/07/2023 16:29","19/07/2023 14:03",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","If I have code like this, then I don't get the ""Replace 'if' with 'switch'"" intention:

        if (""ACS"".equalsIgnoreCase(name)) {
            pad = 12.0;
        } else if (""COS"".equalsIgnoreCase(name)) {
            pad = 23.0;
        } else if (""NICMOS"".equalsIgnoreCase(name)) {
            pad = 12.0;
        } else if (""STIS"".equalsIgnoreCase(name)) {
            pad = 27.0;
        } else if (""WFC3"".equalsIgnoreCase(name)) {
            pad = 20.0;
        }

But this does allow me to use the intention:

        if (""ACS"".equals(name.toUpperCase())) {
            pad = 12.0;
        } else if (""COS"".equals(name.toUpperCase())) {
            pad = 23.0;
        } else if (""NICMOS"".equals(name.toUpperCase())) {
            pad = 12.0;
        } else if (""STIS"".equals(name.toUpperCase())) {
            pad = 27.0;
        } else if (""WFC3"".equals(name.toUpperCase())) {
            pad = 20.0;
        }

Resulting in:

        pad = switch (name.toUpperCase()) {
            case ""ACS"" -> 12.0;
            case ""COS"" -> 23.0;
            case ""NICMOS"" -> 12.0;
            case ""STIS"" -> 27.0;
            case ""WFC3"" -> 20.0;
            default -> pad;
        };

It would be helpful if the intention (or a new one) could recognize that pattern, uppercase all of the strings in the 'case ""xyz""' labels if needed, and use toUpperCase for the input expression to the switch.

I wondered if not using a locale might cause different results in some cases, but String.equalsIgnoreCase ""does not take locale into account, and will result in unsatisfactory results for certain locales"" so I think this is a safe translation. (The code in String.regionMatches is a little complicated, so I'm not completely sure.)","1"
"IDEA-161642","IntelliJ IDEA","","Pull method 'Class1' to 'Interface1'  - pull Annotations too","Łukasz Woźniak","23/09/2016 06:39","18/07/2023 05:43",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","<div class=""wiki text prewrapped"">When i pull Method from some class to some interface, it pull annotations too. It&#39;s very annoying. I need to go to interface and remove it. Very offen I forget about this and i lose many hours of work</div>
","2"
"IDEA-323074","IntelliJ IDEA","","Clean up refactorings in Refactor This for Java and Kotlin","Egor Sergeev","20/06/2023 11:16","17/07/2023 11:53",,"Normal","Cosmetics",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Problem

A large number of refactorings in the Refactor menu / Refactor This increases the cognitive load when a user tries to find the proper option. Besides that, it reduces the chances that users may read the description of refactorings, which causes reduced refactorings usage.

### Evidence

* Refactorings usage for Java
  ![](Frame 140.png){width=585px}
* Kotlin refactorings statistic is to be collected

### Suggested solution

* Remove the following refactorings from Refactor This completely.
  * [ ] Replace Method With Method Object
  * [ ] Find and Replace Code Duplicates
  * [ ] Make Static
  * [ ] Convert To Instance Method
  * [ ] User Interface Where Possible
  * [ ] Invert Boolean
  * [x] Migrate to AndroidX - [IDEA-324477](https://youtrack.jetbrains.com/issue/IDEA-324477)
  * [ ] Migrate to Non-Transitive R Classes
    * We can consider moving them to the Migrate Packages and Classes group
* They will remain in the Refactor option in the main menu","0"
"IDEA-325540","IntelliJ IDEA","","Extract method creates static method when this is not possible","Bas Leijdekkers","17/07/2023 10:58","17/07/2023 10:58",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","To reproduce: extract the println statement to a separate method and choose the anonymous class as the destination class in the following code.
```
class X {
  Object x(String string) {
    return new Object() {
      void y() {
        System.out.println(string);
      }
    };
  }
}
```
Result: the string variable is referenced from a static context (where it is not available and it is also not passed in as a parameter)
```
class X {
  Object x(String string) {
    return new Object() {
      void y() {
        extracted();
      }

      private static void extracted() {
        System.out.println(string);
      }
    };
  }
}
```","0"
"IDEA-304456","IntelliJ IDEA","","'Create Constant Field' shouldn't add initializer if called from 'static' block","Andrey Turbanov","24/10/2022 09:09","17/07/2023 06:48",,"Normal","Bug",,"mikhail.pyltsin","Java. Refactorings","2022.3 EAP 4 (223.7126.7)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
package org.qw;

import java.util.HashMap;
import java.util.Map;

public enum MyEnum {
    A, B, C;

    static {
        HashMap<String, MyEnum> names = new HashMap<>();
        for (MyEnum value : MyEnum.values()) {
            names.put(value.name(), value);
        }
        PER_NAMES<caret> = Map.copyOf(names);
    }
}
```
Apply quick-fix `Create constant field 'PER_NAMES' in 'MyEnum'`

**Expected**
```
private static final Map<String, MyEnum> PER_NAMES;
```

**Actual**
```
private static final Map<String, MyEnum> PER_NAMES = ;
```

BTW, why IDEA shows `int` in preview?
![](изображение.png){width=70%}","0"
"IDEA-318037","IntelliJ IDEA","","""pull members up"" preview doesn't reflect changes for pulling up method to an interface","Sergei Riabinin","14/04/2023 08:20","17/07/2023 06:48",,"Normal","Bug",,"mikhail.pyltsin","Java. Refactorings","2022.2.5 (222.4554.10)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.2","<details><summary>Last ticket submitted at 13 Apr 2023, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/5050085"">#5050085</a></td><td>13 Apr 2023</td><td>Sergei Riabinin</td><td>jens.berger@quinscape.de</td><td>Refactoring Preview does no...</td></tr></table></details>","1","sergei.riabinin","Unknown","```java
package com.some.packages;

public interface Some {
    
}
```
```java
package com.some.packages;

public class SomeClass implements Some {

    int foo() {
        return 1;
    }
}
```
**actual**
invoke ""Refactor | Pull members up"" for `foo`, press Preview:
![](Screenshot 2023-04-14 at 13.19.20.png){width=70%}

**expected**:
preview should reflect refactoring change
```java
    @Override
    public int foo() {
        return 1;
    }
```","0"
"IDEA-322375","IntelliJ IDEA","","Make Refactor This a main entry point in Editor's and Project's context menu","Egor Sergeev","13/06/2023 04:39","30/06/2023 04:24",,"Normal","Usability Problem",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### **Problem**

Refactorings depend on the context, and many are often unavailable. That increases the cognitive load when the user tries to find the desired refactoring.

### Evidence

* Despite the fact that most actions are more commonly invoked with mouse clicks, the refactorings are mostly used with shortcuts [[shortcut usage](https://analytics.jetbrains.com/statistics/query/bdb68eb5d5a0439ea93080b15d19d0b8?f=%5Eextract%7Cintroduce%7C%5Einline%7C%5Emembers%7Csignature%7C%5Emove$&r=1&st=group-with-segments&s=metric_users&o=desc)] [[mouse usage](https://analytics.jetbrains.com/statistics/query/e316e188d58f4712ab302d4dd3e30b83?f=%5Erename%7C%5Eextract%7Cintroduce%7C%5Einline%7C%5Emembers%7Csignature%7C%5Emove$&r=1&st=group-with-segments&s=percentByUser&o=desc)]. E.g. Introduce Variable — 7.9% (shortcut) vs 0.8% (mouse), Extract Method — 3.8% vs 2.1%

### Suggested solution

* Replace the Refactor context menu group with Refactor This

### Success validation

* Increased non-shortcut refactorings usage","0"
"IDEA-322946","IntelliJ IDEA","","Extract Interface doesn't modify usages of inner class","Bas Leijdekkers","19/06/2023 13:10","19/06/2023 13:10",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Extract an interface from the `Node` class below and select `getName()`. Also select `Rename original class and use interface where possible` and rename the implementation class to e.g. `DefaultNode`.
```java
class A {

    public static class Node {

        private final String name;

        public Node(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }
    }
}
class B {

    private A.Node node;
    private final List<A.Node> nodes = new ArrayList<>();
}
```

Result: no changes made in class `B`, but `A.Node` no longer exists:
```java
class B {

    private A.Node node;
    private final List<A.Node> nodes = new ArrayList<>();
}
```

Expected:
```java
class B {

    private Node node;
    private final List<Node> nodes = new ArrayList<>();
}
```","0"
"IDEA-224355","IntelliJ IDEA","","Usage of moved inner class after 'Extract Interface' should use interface instead of implementation","Andrey Turbanov","07/10/2019 17:12","19/06/2023 13:10",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public abstract class ExtractInterfaceWithInnerClass {<br/>    public abstract SomeInner run();<br/>    public static class SomeInner {<br/>    }<br/>}<br/><br/>class ActionWithClass {<br/>    public static void run(ExtractInterfaceWithInnerClass instance) {<br/>        ExtractInterfaceWithInnerClass.SomeInner someInner = instance.run();<br/>    }<br/>}</pre><br/>Try to <code class=""inline-code"">Extract Interface</code> from <code class=""inline-code"">ExtractInterfaceWithInnerClass</code> and choose to move <code class=""inline-code"">run</code> method and <code class=""inline-code"">SomeInner</code> class.<br/>Also select <code class=""inline-code"">Rename original class and use interface where possible</code><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/><strong>Expected</strong><br/>IDEA doesn&#39;t touch code of <code class=""inline-code"">ActionWIthClass</code> class<br/><pre class=""wikicode prettyprint"">    public static void run(ExtractInterfaceWithInnerClass instance) {<br/>        ExtractInterfaceWithInnerClass.SomeInner someInner = instance.run();<br/>    }</pre><br/><strong>Actual</strong><br/>IDEA changes <code class=""inline-code"">ActionWIthClass</code> class code to use implementation class to reference <code class=""inline-code"">SomeInner</code> class<br/><br/><pre class=""wikicode prettyprint"">    public static void run(ExtractInterfaceWithInnerClass instance) {<br/>        ExtractInterfaceWithInnerClassImpl.SomeInner someInner = instance.run();<br/>    }</pre></div>
","0"
"IDEA-322489","IntelliJ IDEA","","New refactoring: Replace usages with ...","Mikko Nylén","13/06/2023 13:48","19/06/2023 05:59",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","First of all, the existing ""Replace structurally..."" does this already (big thanks to whomever implemented it!), so not a high priority.

But at least for replacing some method calls with another ones, the usability could be improved by a dedicated refactoring tool, which could be called with ""Replace usages with ..."".

Really stupid example, but let's say you have a `Name` class and someone added a function `sayHello()` there that prints `Hello, <name>`. There's thousands of such calls in the code base and you wanted to refactor the code to use a new static `Greeter.sayHello(Name)` function.

With Edit -\> Find -\> Replace Structurally... you can do this by:

1. Select ""Method calls"" template as starting point.
2. Then modify the `$Instance$` modifiers to add `type=Name`.
3. For the `$MethodCall$` you add modifier `text=sayHello`
4. Then for the replace template you type: `com.mycompany.Greeter.sayHello($Instance$)`
5. You tick ""Shorten fully qualified names""
6. You click Find
7. You click Replace all from the Find tool window
8. Voila, all of those thousands of `<something>.sayHello()` are now neatly replaced with `Greeter.sayHello(<something>)`
9. Even better, all imports are added automatically. It even works if `<something>` is split to multiple lines.



This is awesome, BUT: as a feature, the structural find/replace is quite well hidden (I didn't actually know of it until yesterday, and I've been using IntelliJ IDEA for 13 years).

So my question/request is, would use cases like this be better served by a dedicated ""Replace usages with ..."" refactoring available for methods? I'm envisioning that one could right click on top of a method definition in class, select Refactor -\> Replace usages with ... and then in a dialog search for the method to use instead, and optionally select to use static imports.","0"
"IDEA-322753","IntelliJ IDEA","","Refactoring is incorrectly disabled in context menu","Vladimir Parfinenko","16/06/2023 08:07","16/06/2023 08:32",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Refactoring ""Replace Method with Method Object"" in the simplest cases is enabled in top menu bar but disabled in context menu.
![](top menu bar.png){width=40%} ![](context menu.png){width=40%}","0"
"IDEA-322737","IntelliJ IDEA","","Missing return after Replace method with method object","Vladimir Parfinenko","16/06/2023 07:00","16/06/2023 08:32",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","Input:
```
public class Main {
    public static Thread bug() throws InterruptedException {
        Thread t = new Thread(); // <- these
        t.join();                // <- lines
        return t;
    }
}
```
Select lines 3 & 4, invoke refactoring ""Replace Method with Method Object..."".
Output:
```
public class Main {
    public static Thread bug() throws InterruptedException {
        Thread t = Foo.invoke();
        return t;
    }

    private static class Foo {
        private static Thread invoke() throws InterruptedException {
            Thread t = new Thread();
            t.join();
            // <- no return statement here ;(
        }
    }
}
```

Introduced method `invoke` lacks return statement.

Motivation: this refactoring is used during code fragment evaluation and leads to errors like
```
Thread t = new Thread(() -> {});
t.join();

~~~>

Compilation failed:
missing return statement
```","0"
"IDEA-322382","IntelliJ IDEA","","Suggest creating new method/variable when user cuts extractable code fragment","Egor Sergeev","13/06/2023 04:54","13/06/2023 04:55",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Problem

When users cut extractable code fragments, they often lack awareness of available refactorings. As a result, they manually introduce new methods or variables, which reduces productivity and increases editing effort for type, modifiers, and usage updates.

### Suggested solution

1. Implement a statistics collector to track the frequency of users cutting extractable code fragments in order to evaluate the prevalence of this behavior.
2. Display a clear suggestion to users, prompting them to create a new method or variable after they cut an extractable code fragment.
3. Alternative to [2]: provide a suggestion to assist users in correctly declaring the method or variable when they paste code fragments that were previously cut from another location in their project.

These suggestions should not be disturbing and should have a possibility to hide them or disable them completely.

### Success validation

* \>5% users cut the extractable code fragment
* Increased Extract Method and Introduce Variable usage
* \<5% of users disable extract suggestions
* \>20% suggestions application rate","0"
"IDEA-322381","IntelliJ IDEA","","Suggest Rename refactoring when search and replace is invoked on the element name or its usage","Egor Sergeev","13/06/2023 04:53","13/06/2023 04:53",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### Problem

When users perform a search and replace operation on an element name or its usage, they may not be aware of the availability of the Rename functionality. Additionally, users may inadvertently overlook some of the occurrences that need to be renamed, leading to incomplete or inconsistent changes.

### Evidence

* 20% replace users do not use Rename [[report](https://analytics.jetbrains.com/statistics/query/67f54432cef14cc0afe7c689f699c496?f=rename&r=0&st=group-with-segments&s=metric_users&o=desc)]. That’s 9% of IDEA active users

### Suggested solution

* Provide a clear and visible suggestion to use the Rename functionality when users invoke the search and replace operation on an element name or its usage. E.g. suggest “Rename 24 more occurrences in 5 files” when search and replace is invoked on element name or its usage

### Success validation

* Increased Rename usage
* > 3% usage of the suggestion among IDEA active users","0"
"IDEA-322378","IntelliJ IDEA","","Preview for Refactor This","Egor Sergeev","13/06/2023 04:40","13/06/2023 04:41",,"Normal","Feature",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","### **Problem**

Users often hesitate to apply refactorings because they are unsure about the changes that will be made to their code. This lack of visibility into the potential changes creates uncertainty and increases the risk of introducing unintended bugs or breaking existing functionality.

### Evidence

* 48% of respondents mentioned they didn't use IDE refactoring because “I was not sure the automated refactoring would work the way I wanted” [[survey](https://data.surveygizmo.com/r/321629_603b74f08bed95.45317439)]![](image.png){width=333px}

### Suggested solution

* Add a preview to the Refactor This menu, allowing users to see a preview of the changes that a selected refactoring will apply

### Success validation

* Increased conversion: open Refactor This → invoke any refactoring
* Increased Refactorings usage","0"
"IDEA-307912","IntelliJ IDEA","","""Inline parameter"" replaces parameter with local variable of another method","Artem Miagkov","07/12/2022 11:46","17/05/2023 12:57",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","**Sample code:**

```
public class InlineParameterLab {

    public String method1(String innerLine1){
        return innerLine1 + ""some text"";
    }

    public String method2(){
        String interchangeString = """";
        String tempString = interchangeString;
        String anotherTempString = method1(tempString);
        return  tempString;
    }
}
```

**Steps:**

1. Invoke `inline parameter` on innerLine1

**AR:**

```
public String method1(){
    return interchangeString + ""some text"";
}
```","0"
"IDEA-151856","IntelliJ IDEA","","Guava -> Java 8 migration: AE at PsiUtil.ensureValidType() on applying to `Predicates.and()`, `Predicates.or()`","Alexander Chernikov","18/02/2016 11:58","17/05/2023 12:32",,"Normal","Exception",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","<div class=""wiki text prewrapped"">Dummy Java code with Guava:<br/><pre class=""wikicode prettyprint"">import com.google.common.base.Predicate;<br/>import com.google.common.base.Predicates;<br/><br/>public class Pair {<br/>    public Predicate&lt;String&gt; andFix(Predicate&lt;String&gt; p) {<br/>        Predicate&lt;String&gt; r = Predicates.and(p);<br/>        return r;<br/>    }<br/>} </pre>Apply Guava -&gt; Java 8 quick fix to <code class=""inline-code"">and()</code> method call: get exception.<br/><br/>No such problem on applying the fix to method return type or variable type.<br/>Same problem for <code class=""inline-code"">Predicates.or()</code>.<br/>IDEA 144.4279.</div>
","0"
"IDEA-152498","IntelliJ IDEA","","Guava -> Java 8 migration: Find tool window opened to view conflicts sometimes shows no conflicts","Alexander Chernikov","02/03/2016 17:27","17/05/2023 12:32",,"Normal","Usability Problem",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","<div class=""wiki text prewrapped"">Dummy Java with Guava:<br/><pre class=""wikicode prettyprint"">import com.google.common.base.Predicate;<br/>import com.google.common.base.Predicates;<br/><br/>public class NoConflicts {<br/>    public Predicate&lt;String&gt; dummy1(Predicate&lt;String&gt;... px) { return Predicates.and(px); }<br/>    public Predicate&lt;String&gt; dummy2(Predicate&lt;String&gt;... px) { return Predicates.and(px); }<br/>} </pre>Enable &quot;Guava&#39;s functional primitives can be replaced by Java&quot; inspection.<br/>Apply &quot;Fix all problems in file&quot; to any of <code class=""inline-code"">px</code> parameters, get a conflict, agree to View Usages, get Find tool window.<br/><br/>Select every node in upper left panel of the window (&quot;migration roots&quot;). Effects:<br/>a. Some roots, even ones without sub-elements shows only &quot;Select root&quot; label in &quot;Reasons to migrate&quot; (upper right) panel.<br/>b. Neither root shows anything in &quot;Conflicts&quot; (bottom) panel.<br/><br/>&quot;A&quot; probably means that some roots are chosen by user, when he applies &quot;Fix all&quot; command. Would be nice to say it more explicitly.<br/>&quot;B&quot; is harder to understand. The Find window has been opened exactly because of some conflicts. And then no one is found?<br/><br/>NB: in some other cases &quot;Conflicts&quot; panel does show information.<br/>IDEA 146.304.</div>
","0"
"IDEA-152128","IntelliJ IDEA","","Guava -> Java 8 migration: conflicts in case of generic type usage","Alexander Chernikov","24/02/2016 16:37","17/05/2023 12:32",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","<div class=""wiki text prewrapped"">Dummy Java with Guava usage:<br/><pre class=""wikicode prettyprint"">import com.google.common.base.Optional;<br/><br/>public class TwoCases {<br/>    public Optional&lt;String&gt; provideFix() { return Optional.absent(); }<br/>    public void consumeFix() { Optional&lt;String&gt; vf1 = provideFix(); }<br/>    public void consumeFixOther() { Optional&lt;String&gt; vf2 = new TwoCases().provideFix(); }<br/><br/>    public &lt;T&gt; Optional&lt;T&gt; provideGene() { return Optional.absent(); }<br/>    public &lt;T&gt; void consumeGene() { Optional&lt;T&gt; vg1 = provideGene(); }<br/>} </pre>&quot;Guava&#39;s functional primitives can be replaced by Java&quot; inspection.<br/>Apply quick fix to <code class=""inline-code"">provideFix()</code> return type or any related variable <code class=""inline-code"">vf1</code>, <code class=""inline-code"">vf2</code>: the code is silently converted, all is Ok. Undo all.<br/>Apply quick fix to <code class=""inline-code"">provideGene()</code> return type as <strong>fix all problems in file</strong>: the code is silently converted, all is Ok. Undo all.<br/>Apply quick fix to <code class=""inline-code"">provideGene()</code> return type _not_ as &quot;fix all problems in file&quot;: get conflict Usages Detected dialog.<br/>If &quot;Fix all&quot; goes without problem, why fix one entry does not?<br/>145.75, 146.127.</div>
","0"
"IDEA-167813","IntelliJ IDEA","","Guava -> Java 8 migration action generates excess code","Сергей Цыпанов","07/02/2017 09:16","17/05/2023 12:32",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"sergei.riabinin","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">Set&lt;RegionType&gt; regionTypes = regionTypeOpt.isPresent() //guava Optional<br/>? regionTypeOpt.asSet()<br/>: anotherSet;</pre><br/>turns into <br/><br/><pre class=""wikicode prettyprint"">Set&lt;RegionType&gt; regionTypes = regionTypeOpt.isPresent()<br/>? regionTypeOpt.isPresent() ? Collections.singleton(regionTypeOpt.get()) : Collections.emptySet();<br/>: anotherSet;</pre><br/>while better way is<br/><br/><pre class=""wikicode prettyprint"">Set&lt;RegionType&gt; regionTypes = regionTypeOpt.map(Collections::singleton).orElse(anotherSet);</pre><br/> 2016.3.2</div>
","0"
"IDEA-149967","IntelliJ IDEA","","Refactoring to move inner class to upper level reformats Javadoc whitespace","Kevin Connor Arpe","02/01/2016 06:13","05/05/2023 14:12",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I use IntelliJ Ultimate 16+ EAP on Windows with Java 8.<br/><br/>See screenshot #1 as inner class.<br/>See screenshot #2 as top-level class.<br/><br/>The Javadoc whitespace has been reformatted.<br/><br/>Meta-note: The ticket type is <strong>Bug</strong>, but that is a bit strong.  =)  Let&#39;s start with Question... if we decide behaviour is incorrect or can be improved, can be marked as a Feature or Bug.</div>
","0"
"IDEA-319289","IntelliJ IDEA","","Move Instance Method adds a random parameter to each reference that is not in the declaration","vccarl98","29/04/2023 18:01","04/05/2023 04:51",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.2","No zendesk mentions",,"sergei.riabinin","Unknown","Hoping I can provide enough pretext to this. I think it might potentially be related to this 3 year old bug <https://youtrack.jetbrains.com/issue/IDEA-227152/Move-Instance-Method-produces-uncompilable-code-by-adding-redundant-parameter>.

I have a superclass, we'll call for this situation Superclazz with a method let's call method1(). The parameters for method1() are two of the same class, we'll call ComponentClazz (so `method1(ComponentClazz component1, ComponentClazz component2)`)

I have 6 children of Superclazz inheriting that same method1 - no overriding, no change. Pretend method1() is final (it might as well be).

I decided instead of having method1() be in Superclazz and its children that I would ""Move Instance Method"" to ComponentClazz, as I have successfully done with other methods, including from Superclazz. Strangely, when I did this, every reference to method1() from within the children of Superclazz got updated.

The expectation:

`component1.method1(component2)`

The actual result in every Superclazz child (assume for this example this is in a child of Superclazz named Childclazz):

`component1.method1(component2, Childclazz.this)`

Even though the method declaration when moved into ComponentClazz was, as expected:

`method1(ComponentClazz component2)`

This resulted in a lot of manual edits to the references, and even undoing and redoing did not alter the outcome.

IC-223.8617.56, JRE 17.0.5+1-b653.25x64 JetBrains s.r.o., OS Windows 11(amd64) v10.0 , screens 3600.0x2400.0","0"
"IDEA-227152","IntelliJ IDEA","","'Move Instance Method' produces uncompilable code by adding redundant parameter","Andrey Turbanov","19/11/2019 06:46","02/05/2023 14:43",,"Normal","Bug",,"IJ_Java_Developer","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.2","No zendesk mentions",,"sergei.riabinin","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class AbstractMoveInstanceMethod {<br/>    public String code;<br/><br/>    protected void setupApplication(Application customApplication, String code, Integer properties) {<br/>        customApplication.setCode(code);<br/>        customApplication.setProperties(properties);<br/>        customApplication.start();<br/>    }<br/>}<br/><br/>class MoveInstanceMethod extends AbstractMoveInstanceMethod {<br/>    void setup(Application application, Integer properties) {<br/>        setupApplication(application, code, properties);<br/>    }<br/>}<br/><br/>abstract class Application {<br/>    abstract void setCode(String code);<br/>    abstract void setProperties(Integer properties);<br/>    abstract void start();<br/>}</pre><br/>Try to move <code class=""inline-code"">setupApplication</code> method to <code class=""inline-code"">Application</code> class<br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">    void setup(Application application, Integer properties) {<br/>        application.setupApplication(code, properties);<br/>    }</pre><br/><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">    void setup(Application application, Integer properties) {<br/>        application.setupApplication(code, properties, MoveInstanceMethod.this);<br/>    }</pre></div>
","1"
"IDEA-161779","IntelliJ IDEA","","Extract parameter with varags results in broken and unprofessional code","Róbert Papp","27/09/2016 08:15","24/04/2023 06:27",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Here&#39;s a simple skeleton where it&#39;s easy to reproduce the problem.<br/><pre class=""wikicode prettyprint"">class Obj {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public static Obj createObject(String name) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return null;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public static Obj merge(Obj... objs) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return null;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}<br/><br/>class UseObj {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>void methodThatCalls() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>methodThatMerges(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>Obj.createObject(&quot;some param that&quot;),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>Obj.createObject(&quot;may be quite long&quot;)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>void methodThatMerges(Obj... objs) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// call Extract parameter refactoring when cursor is on the merge method call<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>methodThatReceives(merge(objs));<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>void methodThatReceives(Obj obj) { }<br/>}</pre><br/>When Extract parameter is executed the resulting code looks like this (reasons why this is bad are in comments):<br/><pre class=""wikicode prettyprint"">// actual<br/>void methodThatCalls() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// (1) unnecessary explicit array creation<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// (1b) this array creation would actually fail to compile if Obj was generic<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// (2) original formatting is totally lost, in this case it fits on a single line, but that&#39;s not necessarily the case always<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>final Obj[] objs = new Obj[] {Obj.createObject(&quot;some param that&quot;), Obj.createObject(&quot;may be quite long&quot;)};<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>methodThatMerges(merge(merge(objs)) // (3) duplicate merge call<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>); // (2b) notice that part of the formatting is preserved<br/>}<br/>void methodThatMerges(Obj merge) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>methodThatReceives(merge);<br/>}<br/><br/>// expected (this, or at least something closer to the original)<br/>void methodThatCalls() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>methodThatMerges(merge(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>Obj.createObject(&quot;some param that&quot;),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>Obj.createObject(&quot;may be quite long&quot;)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>));<br/>}</pre><br/><br/>In case you&#39;re wondering here&#39;s the original example where this problem came up (Android Espresso with some custom matchers):<br/><pre class=""wikicode prettyprint"">// methodThatMerges<br/>@SafeVarargs<br/>public final void checkMoveToast(Matcher&lt;String&gt;... matchers) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>onView(isDialogMessage()).inRoot(isToast()).check(matches(allOf(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>isDisplayed(),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>withText(allOf(matchers)) // wanted to extract allOf to get rid of varargs<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>)));<br/>}<br/><br/>// methodThatCalls<br/>itemView.checkMoveToast(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsString(TEST_ITEM),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsStringRes(R.string.generic_error_unique_name),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsString(TEST_ITEM_OTHER)<br/>);</pre><br/>after refactoring <code class=""inline-code"">allOf</code>:<br/><pre class=""wikicode prettyprint"">// actual:<br/>// (4) fully qualified class names<br/>final org.hamcrest.Matcher&lt;String&gt;[] matchers = new org.hamcrest.Matcher&lt;String&gt;[] {containsString(TEST_ITEM),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsStringRes(R.string.generic_error_unique_name), containsString(TEST_ITEM_OTHER)};<br/>// (5) in this case even the static import of allOf is lost<br/>itemView.checkMoveToast(Matchers.allOf(Matchers.allOf(matchers))<br/>);<br/>@SafeVarargs // (6) SafeVarags left after refactoring ... that&#39;s a compile error<br/>public final void checkMoveToast(Matcher&lt;String&gt; matcher)<br/><br/>// expected (or at least something closer to the original)<br/>itemView.checkMoveToast(allOf(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsString(TEST_ITEM),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsStringRes(R.string.generic_error_unique_name),<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>containsString(TEST_ITEM_OTHER)<br/>));</pre><br/>Of the 6 issues shown I would say the priorities are: 3, 1, 6, 4, 5, 2. I wouldn&#39;t consider this bug fixed without 3, 1, 6; but 4, 5 is just really annoying to have, it makes the refactoring make us do more work than if we didn&#39;t use the refactoring. 2 is just cosmetics.<br/><hr/><br/>Note: inlining <code class=""inline-code"">methodThatMerges</code> actually does a better job, but I don&#39;t want to inline that method, because it actually does more IRL. &quot;better job&quot; actually also destroys formatting:<br/><pre class=""wikicode prettyprint"">methodThatReceives(merge(Obj.createObject(&quot;some param that&quot;), Obj.createObject(&quot;may be quite long&quot;)));</pre></div>
","0"
"IDEA-317240","IntelliJ IDEA","","'Introduce local variable' canceling removes semicolon","hasan yıldız","05/04/2023 06:27","19/04/2023 06:47",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2022.2.5 (222.4554.10)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.2","No zendesk mentions",,"sergei.riabinin","Unknown","When writing java code, i used 'introduce local variable' shortcut and then cancelled pressing Esc twice.

After that line ending semicolon is removed.



IC-231.8109.175, JRE 17.0.6+10-b829.5x64 JetBrains s.r.o., OS Windows 10(amd64) v10.0 , screens 2400.0x1350.0, 1920.0x1080.0","0"
"IDEA-317009","IntelliJ IDEA","","Introducing a functional variable functionality works incorrectly","Alexander Tsukanov","02/04/2023 05:28","18/04/2023 18:57",,"Normal","Bug",,"basleijdekkers","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.1","<details><summary>Last ticket submitted at 03 Apr 2023, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/5003835"">#5003835</a></td><td>03 Apr 2023</td><td>Sergei Riabinin</td><td>Alexander Tsukanov</td><td>[YouTrack] IDEA-317009: Int...</td></tr></table></details>","1","sergei.riabinin","Unknown","I have the next block of the code:

```java
 private static void doSomeStaff(){
        System.out.println(""Hello!"");
    }
```

The IntelliJ suggests only Runnable interface when I want to extract Functional variable, I believe it is wrong. The behaviour should be as follows: <https://blog.jetbrains.com/idea/2015/02/intellij-idea-14-1-introduces-extract-functional-parameter-refactoring/>
The set of interfaces should be proposed. E.g. I would like to extract block to Consumer interface. 

Please, verify.

![](image.png)","0"
"IDEA-311720","IntelliJ IDEA","","Renaming class does not rename related test class, losing the link","olsavmic","27/01/2023 11:53","17/04/2023 06:48",,"Major","Bug",,"bart.vanhelvert","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.1","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Create class HelloController, Create test class HelloControllerTest in the same package

```
package com.example.springtestingdemo;

public class HelloController
{
}
```

```
package com.example.springtestingdemo;

import org.junit.jupiter.api.Test;

class HelloControllerTest
{

    @Test
    public void test()
    {
    }

}
```

Navigation from HelloController to Test class and back via \`Go to Test\` works just fine.

***What is the expected result?***

IntelliJ IDEA should suggest renaming the linked Test classes as well.

***What happens instead?***

Renaming `HelloController` to `HelloControllers` does not show `HelloControllerTest` among Refactoring preview and does not offer rename of related test classes.

I believe this functionality was working in the past and I was assured about it in <https://youtrack.jetbrains.com/issue/IDEA-20779/Move-class-refactoring-should-move-test-class#focus=Comments-27-6802124.0-0>





IntelliJ IDEA 2022.3.1 (Ultimate Edition)
Build #IU-223.8214.52, built on December 20, 2022


","1"
"IDEA-53945","IntelliJ IDEA","","Refactoring conflicts view: resolve conflicts action should be available","Anna Kozlova","14/04/2010 05:39","23/03/2023 05:09",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It would be convenient to resolve e.g. visibility conflicts automatically</div>
","3"
"IDEA-233032","IntelliJ IDEA","","Rename refactoring should respect settings","Timur Yuldashev","14/02/2020 12:11","14/03/2023 06:11",,"Normal","Bug",,"valentin","Java. Refactorings","2020.1 (201.6668.121)",,"To be discussed","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">201.5430<br/><br/>For instance user disables search in comments, string and text occurrences then renaming method through dialog or inplace does not perform that search and do renaming right away. But new post edit refactoring still warns about such occurrences.<br/><br/>I think all three approaches should use the same settings to be consistent. Also it would allow to configure behavior of post-edit refactoring, which currently seems not possible.</div>
","0"
"IDEA-144764","IntelliJ IDEA","","Move refactoring: action to include ""safe"" dependencies","Dmitry Cherniachenko","04/09/2015 05:22","10/03/2023 11:09",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Say I have a static method in a class and it uses some private static final field.<br/>When I try to move the method to another class IDEA highlights the constant with a blue color to signal the dependency.<br/>But to check if it is safe to also move the field I have to cancel the refactoring and search for the field usages to check if it is used somewhere else.<br/><br/>It would be great to have an action like &quot;Include all dependencies that are only used in the moved members&quot;.<br/><br/>In my case the list of members was pretty long and I didn&#39;t notice the field was blue. So I pressed Ok and IDEA showed &quot;Problems Detected&quot; window. Please consider adding &quot;Include all safe and continue&quot; action there too.<br/>(you might even run a usage search in the background and only suggest &quot;Include all and continue&quot; when all the dependencies are &quot;safe&quot;)</div>
","0"
"IDEA-313665","IntelliJ IDEA","","Suggest 'create' prefix for extracted method","Tagir Valeev","20/02/2023 06:27","20/02/2023 07:01",,"Normal","Feature",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","If the extracted method returns a new variable, and that variable is exactly once assigned inside the extracted block, and it's assigned to a 'new' expression, it looks a good idea to suggest `createXyz` prefix instead of `getXyz`. E.g.:

```java
class X {
  void test() {
    List<String> list = new ArrayList<>();
    list.add(""x"");
    list.add(""y"");
    System.out.println(list);
  }
}
```

![](image.png){width=70%}

Having `createList` or `createStringList` suggestions would be nice.","0"
"IDEA-313666","IntelliJ IDEA","","Extract method name suggestions: rank return variable based suggestions higher","Tagir Valeev","20/02/2023 06:32","20/02/2023 07:01",,"Normal","Feature",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When we have extract method that creates one output, the method name suggestions are based on output variable type and name. However, it looks like the type is preferred. In many cases, variable name is more specific than variable type. I suggest to try ranking name-based suggestions higher. Example:

```java
class X {
  void test() {
    String greeting = ""Hello World!""; // extract this line
    System.out.println(greeting);
  }
}
```

![](image.png)

Default suggestion `getString` sounds uncool. This is not something that anybody would want. The `getGreeting` one is much better and should come first.

We may rank lower name-based suggestions if the name is generic, like `result`, or `output`. However, in general case my experience shows that name is usually more specific than type.","0"
"IDEA-202608","IntelliJ IDEA","","Refactoring to convert between structurally similar classes (especially will be helpful when converting from tuple-like types)","Anton Lobov","21/11/2018 10:00","10/02/2023 14:28",,"Normal","Feature",,"sergei.riabinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">We have interfaces like <code class=""inline-code"">com.intellij.openapi.util.Pair</code> , <code class=""inline-code"">Couple</code>, etc. Many other codebases use their own tuple-like types, or some tuple-like types from third-party libraries.<br/><br/>Let&#39;s suppose that some method returns a Pair:<br/><pre class=""wikicode prettyprint"">Pair&lt;String, String&gt; compute() {<br/>  // ...<br/>}<br/><br/>void method() {<br/>    Pair&lt;String, String&gt; result = compute();<br/>    System.out.println(&quot;Result: &quot; + result.getFirst() + &quot;, err: &quot; + result.getSecond());<br/>}</pre><br/>At some moment, Pair is not enough, being replaced by Triple. Then, Triple is not enough, or is confusing, and there exists a need to refactor it to some decent class instead, for example:<br/><pre class=""wikicode prettyprint"">class Result {<br/>    String text;<br/>    String errorText;<br/><br/>    // get/set/etc.<br/>}</pre><br/>It would be nice to have some refactoring that will automatically transform a tuple-like type to this Result type, mapping fields correspondingly.<br/>I.e., some UI to set <code class=""inline-code"">Result#text</code> map to <code class=""inline-code"">Pair#first</code> and <code class=""inline-code"">Result#errorText</code> map to <code class=""inline-code"">Pair#second</code>, and afterwards. the occurrences will be updated:<br/><br/><pre class=""wikicode prettyprint"">Result compute() {<br/>  // ...<br/>}<br/><br/>void method() {<br/>    Result result = compute();<br/>    System.out.println(&quot;Result: &quot; + result.getText() + &quot;, err: &quot; + result.getErrorText());<br/>}</pre><br/>By some reason I expected &#39;Migrate type&#39; to behave this way, but it doesn&#39;t.</div>
","0"
"IDEA-185711","IntelliJ IDEA","","Allow move left/right to move switch cases","Róbert Papp","28/01/2018 10:09","10/02/2023 14:28",,"Normal","Feature",,"sergei.riabinin","Java. Refactorings","2018.1.5 (181.5284.24)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Similar to being able to move method arguments/params, e.g. `f(a,b,c)` -> `f(a,c,b)` when ""Code > Move Element Right"" is executed on `b`.

It would be a useful feature to allow a similar code transformation:
```
class X {
	void f(String s) {
		switch (s) {
			case ""a"":
				System.out.println(""A"");
				break;
			case ""b"":
				System.out.println(""B"");
				break;
			case ""c"":
				System.out.println(""C"");
				break;
		}
	}
}
```
when `b` moved to left or `a` moved to right:
```
		switch (s) {
			case ""b"":
				System.out.println(""B"");
				break;
			case ""a"":
				System.out.println(""A"");
				break;
			case ""c"":
				System.out.println(""C"");
				break;
		}
```
Currently this is achievable by moving lines, but it could be error prone, e.g. missing a line and resulting in fall-through.
The transformation would work being focused on `case ""x"":`.","0"
"IDEA-53608","IntelliJ IDEA","","Refactor TestNG Autowired Resource","opticyclic","05/04/2010 15:57","10/02/2023 13:08",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The @Resource TestNG annotation autowires with the property name as well as the type.<br/><br/>However, although IDEA recognises that it is autowired and jumps to the correct bean, when I refactor the name it doesn&#39;t change the name in the spring.<br/><br/><a href=""http://www.jetbrains.net/devnet/thread/287700"" target=""_blank"" rel=""noopener noreferrer"">http://www.jetbrains.net/devnet/thread/287700</a></div>
","0"
"IDEA-182719","IntelliJ IDEA","","On adding a new parameter in Change Signature dialog using keyboard focus is not immediately transferred to Type field","Dmitry Batrak","27/11/2017 07:52","10/02/2023 13:05",,"Normal","Usability Problem",,"kb","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Extra Tab press is required to transfer focus.<br/><br/>IntelliJ IDEA 2018.1 EAP (Ultimate Edition)<br/>Build #IU-181.SNAPSHOT, built on 13:17, November 26, 2017<br/>IntelliJ IDEA EAP User<br/>Expiration date: December 26, 2017<br/>JRE: 1.8.0_152-release-1056-b12 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 10 10.0</div>
","0"
"IDEA-56621","IntelliJ IDEA","","Java: Renaming a property also changes it in unrelated modules","Joachim Ansorg","20/07/2010 11:42","10/02/2023 13:00",,"Normal","Bug",,"cdr","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have two modules A and B, they are NOT related or connected by dependencies, i.e. completely unrelated.<br/><br/>&quot;A&quot; has a property file with the property &quot;property.one&quot; and &quot;B&quot; has a property of the same name. Now I want to rename the property in module &quot;A&quot;, I press shift-F6 on the property and do the rename.<br/><br/>IDEA renames the property in &quot;A&quot; and in &quot;B&quot;. I think that this should not happen, the rename should only affect module &quot;A&quot; (and probably the modules which depend on &quot;A&quot;).<br/><br/>This messed up my module &quot;B&quot; and I had to revert all the changes IDEA made there.<br/><br/>(Also, the resolve of a property looks into unrelated modules, this is also a bug, I think)</div>
","0"
"IDEA-35121","IntelliJ IDEA","","Refactor | Internationalize: with transparent native-to-ascii conversion = off, write characters correctly into the properties file anyway","Alexander Chernikov","27/10/2006 10:18","10/02/2023 12:59",,"Normal","Bug",,"cdr","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Make sure settings | general | transparent native-to-ascii conversion = off. Provide some native value in code like: <pre class=""wikicode prettyprint""> private String russianValue = &quot;??????? ????????&quot;; </pre> (&quot;Russian value&quot;). Refactor | i18n. Ok to default prompt. Result: characters are written into properties file as ??????? ... Obviously, this result is useless.<br/><br/>This seems to be not correct. Option &quot;transparent native-to-ascii conversion&quot; should affect, how properties file is shown in IDEA editor. But if users set it off, this does not mean they want to get useless properties files. Refactoring should perform necessary conversion anyway.</div>
","0"
"IDEA-58760","IntelliJ IDEA","","Find Usages dialog on class method has conflicting mnemonics","Anders Wallgren","15/09/2010 18:35","10/02/2023 12:59",,"Normal","Bug",,"cdr","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Find Usages uses &#39;o&#39; for both &quot;Overriding methods&quot; and &quot;Search for text occurrences&quot;</div>
","0"
"IDEA-83325","IntelliJ IDEA","","Idea goes into endless loop when trying to introduce a constant.","Siddharth Priya","22/03/2012 10:57","10/02/2023 12:59",,"Normal","Bug",,"cdr","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The user was trying to introduce a constant by typing ctrl + alt + c  (probably when editing the enum constructor of a java file)<br/><br/>Is this enough or will you need more data to analyse the bug?<br/><br/>thanks<br/>Siddharth</div>
","0"
"IDEA-80986","IntelliJ IDEA","","""Extract superclass"" breaks formatting and doesn't optimize imports","Evgeny Gerashchenko","08/02/2012 06:37","10/02/2023 12:59",,"Normal","Bug",,"cdr","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Subclass</strong><br/><div class=""wiki picture""><img src=""[](subclass.png)""/></div><br/><br/><strong>Superclass</strong><br/><div class=""wiki picture""><img src=""[](superclass.png)""/></div></div>
","0"
"IDEA-15159","IntelliJ IDEA","","Crete interface option when Alt-Enter on a non-existant class instantiation","Vaclav Pech","20/09/2007 11:40","10/02/2023 12:57",,"Normal","Feature",,"cdr","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;d like to be able to create an interface in the code as shown in the screen-shot and immediately construct an anonymous inner class out of it, but I&#39;m only given options to create a class or an inner class.<br/>The image 1 shows the situation, image 2 shows the desired result, which, however, must currently be achieved manually.</div>
","0"
"IDEA-82662","IntelliJ IDEA","","refactoring: anonymous to inner class: option to create static classes","Cristian Vasile Mocanu","13/03/2012 08:24","10/02/2023 12:56",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Add an option to the &quot;Convert anonymous to inner&quot; class refactoring: &quot;create static inner class&quot;.<br/><br/>The option will pass to the constructor of the newly created inner class all the fields used from the outer class.<br/><br/><strong>Please, don&#39;t pass the instance of the outer class as a constructor parameter, but rather each individual field used by the inner class!</strong><br/><br/>Static inner classes have the advantage that they can become top level classes easily with only one additional refactoring (&quot;Move inner to upper level&quot;).</div>
","1"
"IDEA-307931","IntelliJ IDEA","","Make ""Inline parameter"" work for multiple identical constants","Artem Miagkov","07/12/2022 12:53","09/02/2023 07:20",,"Normal","Feature",,"artem.miagkov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Code sample:**

```
public class InlineParameterLab {
    public Integer number1;
    private String line1;

    public String method1(String innerLine1){
        return innerLine1 + ""some text"";
    }

    public String method2(){
        String tempString = ""ABC"";
        String anotherTempString = method1(tempString);
        return  tempString;
    }

    public  String method3(){
        String tempString = ""ABC"";
        String anotherTempString = method1(tempString);
        return  tempString;
    }
}
```

Here parameter of method1 is identical by the time method call happens.
Idea could thus inline parameter as ""ABC"" and edit both of method usages (with confirmation from user)


","0"
"IDEA-307936","IntelliJ IDEA","","Make ""Inline parameter"" recognize incremental operations with constant","Artem Miagkov","07/12/2022 13:09","09/02/2023 07:19",,"Normal","Feature",,"artem.miagkov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Sample code:**

```
public String method1(String innerLine1){
    return innerLine1 + ""some text"";
}

public String method2(){
    String tempString = ""This is some"";
    tempString =tempString + ""D"";
    String anotherTempString = method1(tempString);
    return  tempString;
}
```

**Current behavior:**

```
public String method1(){
    return (tempString + ""D"") + ""some text"";
}
```

**Desired behavior:**

```
public String method1(){
    return (""ABC"" + ""D"") + ""some text"";
}
```","0"
"IDEA-307915","IntelliJ IDEA","","Change message for ""Inline Parameter"" if multiple different constants are found","Artem Miagkov","07/12/2022 11:55","09/02/2023 07:19",,"Normal","Usability Problem",,"artem.miagkov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Example:**

![](image.png){width=70%}

**Code sample:**

```
public String method1(String innerLine1){
    return innerLine1 + ""some text"";
}

public String method2(){
    String tempString = ""ABC"";
    String anotherTempString = method1(tempString);
    return  tempString;
}

public  String method3(){
    String tempString = ""ABC"";
    String anotherTempString = method1(tempString);
    return  tempString;
}
```

**Use case explanation:**

Upon refactoring of longer code it could happen that method2 is visible on screen, while method3 could be much lower in code and user is unaware of it. That creates false contradiction.

**Suggested error text:** ""Multiple constant initializers found""","0"
"IDEA-106607","IntelliJ IDEA","","expose serialVersionUID generation","Arash Bizhanzadeh","02/05/2013 15:24","09/02/2023 04:32",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 26 Aug 2019, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2232344"">#2232344</a></td><td>26 Aug 2019</td><td>Yaroslav Bedrov</td><td>wangwii@foxmail.com</td><td>IntelliJ IDEA feedback</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently there is no manual way to generate serialVersionUID. It seems the only way it to enable serializable inspection and rely on IDEA to prompt help.<br/>It will be beneficial if you can expose it as an action.</div>
","2"
"IDEA-230777","IntelliJ IDEA","","Pull Members Up should replace generic type arguments","Herman Bovens","16/01/2020 08:27","26/01/2023 07:44",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121), 2019.3.1 (193.5662.53)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**
1.  Create a class that has a type parameter `T`, e.g. `SuperType<T>`
2. Create a class that will be used as type argument, e.g. `MyType`
3. Create a subclass of the first class that uses `MyType` as argument for `T`, e.g. `SubType extends SuperType<MyType>`
4. Create a method inside `SubType` which has a parameter or return value of type `MyType`
5. Invoke the Pull Members Up refactoring on this method to pull it up to `SuperType`

**What is the expected result?**

I'd expect the type of the method parameter or return value (`MyType`) to be replaced with `T` in the super class.

**What happens instead?**

The method created in the super class has a method with parameter or return value `MyType`.
In some cases this will even fail to compile, e.g. if the super class has a `List<T>` and the method tries to add something of `MyType` to this list.

This may apply to Kotlin as well, haven't tested this yet.","0"
"IDEA-165640","IntelliJ IDEA","reproduced","'Pull Members Up' shows false positive problem in case of generics","Andrey Turbanov","19/12/2016 07:58","26/01/2023 07:44",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In module1 interface<br/><pre class=""wikicode prettyprint"">public interface GenericInterface&lt;T&gt; {<br/>}</pre><br/>In module2 class<br/><pre class=""wikicode prettyprint"">public class GenericImpl&lt;T&gt; implements GenericInterface&lt;T&gt; {<br/>    void register(T t) {<br/>    }<br/>}</pre>module2 depends on module1.<br/><br/>Invoke Pull Members Up for <span class=""monospace"">register</span> method.<br/><br/><strong>Expected</strong><br/>No problems<br/><br/><strong>Actual</strong><br/>IDEA shows windows &#39;Problems Detected&#39;<br/><span class=""monospace"">Class T, referenced in method GenericImpl.register(T), will not be accessible in module m1</span></div>
","0"
"IDEA-181625","IntelliJ IDEA","static import","Java: add option to forbid static wildcard import","Johan Ström","03/11/2017 08:12","25/01/2023 15:14",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When writing unittests with PowerMockito and Mockito (normal combination), IntelliJ tends to do this<br/><br/><pre class=""wikicode prettyprint"">import static org.mockito.Mockito.*;<br/>import static org.powermock.api.mockito.PowerMockito.*;</pre><br/>This is bad, since some methods are defined in both classes (such as &quot;when&quot;), causing code to fail or be ambiguous.<br/><br/>Similarly to the &quot;Packages to Use Import with &#39;*&#39;&quot; setting, it would be nice to have either a &quot;Packages to NEVER use static import &#39;*&#39; with&quot;.<br/><br/>My current settings:<br/>[x] Use single class import<br/>[ ] Use fully qualified class names<br/>[ ] Insert imports for inner classes<br/><br/>Class count to use imports with &#39;*&#39;: 10<br/>Class count to use static import with: 3<br/><br/>Packages to Use Import &#39;*&#39;:<br/>import java.awt.*<br/>import javax.swing.*</div>
","4"
"IDEA-311184","IntelliJ IDEA","","""Extract Superclass"" and ""Pull Members Up"" in inner class introduce infinite recursion","Daniel Chýlek","22/01/2023 22:46","24/01/2023 08:21",,"Normal","Bug",,"basleijdekkers","Java. Refactorings","2021.3.3 (213.7172.25)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2023.1","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Example code:
```java
public abstract class Test<T> {

	public String valueToString(T value) {
		return value.toString();
	}

	public static final Test<String> CHILD = new Test<String>() {

		@Override
		public String valueToString(String value) {
			return value.isEmpty() ? ""abc"" : super.valueToString(value);
		}
	};
}
```
2\. Use ""Extract Superclass"" inside CHILD and include `getThing()`

The extracted superclass now causes a `StackOverflowError` when `valueToString` is called:

![](image.png){width=70%}

You can also use ""Extract Superclass"" without including `getThing()` in the superclass, and then use ""Pull Members Up"" to pull `valueToString` into the newly created superclass. This causes the same broken code.","0"
"IDEA-119202","IntelliJ IDEA","","Support sharing of migration maps","Russ Tennant","09/01/2014 15:13","22/01/2023 18:44",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 20 Jan 2023, total tickets 3</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/4681589"">#4681589</a></td><td>20 Jan 2023</td><td>Arina Efremova</td><td>pkv.sjc@gmail.com</td><td>[IDEA webhelp] issue with p...</td></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3146606"">#3146606</a></td><td>19 Feb 2021</td><td>Olga Klisho</td><td>dimioblog@gmail.com</td><td>Export migration map from M...</td></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2752360"">#2752360</a></td><td>11 Jul 2020</td><td>Olga Klisho</td><td>lemadec.fr@gmail.com</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","3","No assigned support","Unknown","<div class=""wiki text prewrapped"">It would be nice to be able to share or import-export migration maps [Refactor -&gt; Migrate...] so other people on my team can make use of them.<br/><br/>The current workaround is to copy the XML files to/from the ~/.IntelliJIdeaXX/config/migration/ folder.</div>
","3"
"IDEA-223530","IntelliJ IDEA","","Replace constructor with builder with Lombok annotation","Olga Klisho","25/09/2019 09:14","16/01/2023 15:20",,"Normal","Usability Problem",,"michail.plushnikov","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 25 Feb 2022, total tickets 3</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3853218"">#3853218</a></td><td>25 Feb 2022</td><td>Arina Efremova</td><td>kirill.semenov@seqvoia.com</td><td>Refactor constructor to (lo...</td></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2811692"">#2811692</a></td><td>18 Aug 2020</td><td>Olga Klisho</td><td>Dablick</td><td>Refactor Constructor invoca...</td></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2277036"">#2277036</a></td><td>24 Sep 2019</td><td>Olga Klisho</td><td>admitrov@playtika.com</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","3","No assigned support","Unknown","Code sample:
```
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor

public class BundleItemDto {
    private long bundleId;
    private int skuId;
    private SkuData skuData;
    private double amount;

    private static final BundleItemDto BUNDLE_ITEM_1 = new BundleItemDto(1,
            100,
            new SkuData().append(""packageId"", 1),
            0
    );
}
```
Replace Constructor with Builder and rename setters:

![](image.png){width=500} ![](image1.png){width=500}

**Actual result:**
`private static final BundleItemDto BUNDLE_ITEM_1 = new BundleItemDtoBuilder().bundleId(1).skuId(100).skuData(new SkuData().append(""packageId"", 1)).amount(0).createBundleItemDto();`

**Expected result:**
`private static final BundleItemDto BUNDLE_ITEM_1 = new BundleItemDtoBuilder().bundleId(1).skuId(100).skuData(new SkuData().append(""packageId"", 1)).amount(0).build();`","7"
"IDEA-175228","IntelliJ IDEA","","As a ReSharper user moving to IntelliJ the Rename command is frustrating","Dru Sellers","30/06/2017 11:31","16/01/2023 14:11",,"Normal","Usability Problem",,"zollycute","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 04 Feb 2019, total tickets 2</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1967986"">#1967986</a></td><td>04 Feb 2019</td><td>Andrey Dernov</td><td>wayneleroux@gmail.com</td><td>IntelliJ IDEA feedback</td></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1211806"">#1211806</a></td><td>16 Jan 2018</td><td>Andrey Dernov</td><td>william.hubertus@igt.com</td><td>refactor a variable bug</td></tr></table></details>","2","No assigned support","Unknown","<div class=""wiki text prewrapped"">Shift + F6 to rename<br/>Get inplace renamer, cool. rename my private field.<br/>Um, a pop up - hmm- well I like the name I already picked. R# never failed me. <br/>Press enter.<br/>! no rename !!!<br/>WTF<br/>Shift+F6, again<br/>type the new name<br/>another pop up, ok lets look at it this time.<br/>Oh it wants to change this other thing. ok. <br/>its highlighted, I press space to select it.<br/>Press enter<br/>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<br/>It still didn&#39;t take it.<br/>Shift+F6 for the THIRD time<br/>select desired name<br/>press space to pick up that other variable<br/>try hitting tab and see where that goes?<br/>parameter name -&gt; rename to -&gt; ???<br/>IT NEVER GOES TO OK<br/>Do I really have to use my mouse?!<br/>hover over OK looking for the short cut<br/>check the ? mark &quot;No Help Available&quot; :/<br/>shift + enter ? - no action<br/>rants to coworker about how his beloved company JetBrains could possible have missed this. Is furious and pretty sure that he is missing something obvious. <br/><br/>RAGE<br/><br/>mouse clicks ok.</div>
","1"
"IDEA-60148","IntelliJ IDEA","","Copy class: update date/time in file header","Pavel Fatin","21/10/2010 07:29","16/01/2023 13:00",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 01 Jul 2021, total tickets 2</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3373125"">#3373125</a></td><td>01 Jul 2021</td><td>Egor Klepikov</td><td>1360218698@qq.com</td><td>idea use alt+enter keys and...</td></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1287812"">#1287812</a></td><td>12 Mar 2018</td><td>Yaroslav Bedrov</td><td>david@unitas.nl</td><td>IntelliJ IDEA Feedback</td></tr></table></details>","2","No assigned support","Unknown",,"11"
"IDEA-266515","IntelliJ IDEA","","Scratch class rename bug","Maxim Degtyarev","10/04/2021 16:59","16/01/2023 11:56",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 13 Jul 2021, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3390720"">#3390720</a></td><td>13 Jul 2021</td><td>Ethan Yin</td><td>zx77@cornell.edu</td><td>Refactor not working in scr...</td></tr></table></details>","1","No assigned support","Unknown","**What steps will reproduce the issue?**

1. Create new Java scratch file
2. Replace scratch file content with the following:
```java
import java.util.stream.Collectors;
import java.util.stream.Stream;

class Scratch {

    public static void main(String[] args) {
        System.out.println(test());
    }

    private static String test() {
        return
            Stream.of(
                ""Participate in a flame war about Stream API performance"",
                ""Contribute a patch to Stream API to improve performance""
            )
            .parallel()
            .map(Scratch::acceptChallenge)
            .collect(Collectors.joining(""\n""));
    }

    private static String acceptChallenge(String s) {
        return ""CHALLENGE ACCEPTED: "" + s;
    }

}
```
3. Rename `Scratch` class to, let's say, `ScratchRenameBug`

**What is the expected result?**

Class and all references to the class `Scratch` should be renamed.

**What happens instead?**

Class itself renamed, but method reference to `Scratch::acceptChallenge` remains not renamed.

Same actions done with regular class (not scratch) in the Java project does not expose such bug.

---

IntelliJ IDEA 2021.1 (Community Edition)
Build #IC-211.6693.111, built on April 6, 2021
Runtime version: 11.0.10+9-b1341.35 amd64
VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o.
Windows 7 6.1
GC: G1 Young Generation, G1 Old Generation
Memory: 750M
Cores: 4
Registry: run.processes.with.pty=false, vcs.force.non.modal.commit=true, error.navigation.show.tooltip=false, actionSystem.fix.alt.gr=false
Non-Bundled Plugins: com.intellij.marketplace (211.6693.121), org.jetbrains.kotlin (211-1.4.32-release-IJ6693.72), com.jetbrains.edu (2021.3-2021.1-322)
Kotlin: 211-1.4.32-release-IJ6693.72","0"
"IDEA-200785","IntelliJ IDEA","","Refactor->Move project incompletely updates build configuration, project structure","Seth Battis","18/10/2018 10:45","16/01/2023 11:55",,"Normal","Bug",,"anet","Java. Refactorings","2018.2.4 (182.4505.22), 2019.1 (191.6183.87)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 02 Dec 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3001911"">#3001911</a></td><td>02 Dec 2020</td><td>Olga Klisho</td><td>lefevrol@yahoo.com</td><td>Cannot build Kotlin project...</td></tr></table></details>","1","No assigned support","Unknown","I noticed this first with some Maven projects my students are working on, but confirmed it just now by doing the following:

  1. Create a basic Java project using the Hello World template.
  2. Run the project once
  3. Refactor->move the entire project to a new directory
  4. Try to run the project again

  - I observe that the run configuration's working directory path is still to the original location of the project
  - In _Maven_ projects, I observe that in the project structure, the project compiler output is still to the original location.
  - If I edit these paths to reflect the new project location and run the project again, I get ""Error:build: Cannot determine build data storage root for project [path to original location]""
  - If I close the project and reopen it, the Hello World project runs fine. The Maven project tends to need to have either the run configuration's module set or an SDK selected.
  - In searching through the IML file and the .idea/*.xml files, I see no lingering references to the original project path.

----
IntelliJ IDEA 2018.2.4 (Ultimate Edition)
Build #IU-182.4505.22, built on September 18, 2018
Licensed to Seth Battis
Subscription is active until August 15, 2019
For educational use only.
JRE: 1.8.0_152-release-1248-b8 amd64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0

Oracle JDK 1.8 and 10 both installed.","0"
"IDEA-25349","IntelliJ IDEA","","Artifacts: Jar manifest entries aren't updated when refactoring classes","Andrew Perepelytsya","23/10/2009 17:25","16/01/2023 11:45",,"Normal","Bug",,"nik","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 11 Aug 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2800260"">#2800260</a></td><td>11 Aug 2020</td><td>Serge Baranov</td><td>stephan.steiner@gmail.com</td><td>Moving maven dependencies t...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">Create a blank project with a single empty main() class. Configure a jar artifact and specify this class as Main-Class for manifest. Now refactor/move the class to a different package.<br/><br/>Expected: manifest entries updated<br/>Actual: manifest entries are not updated</div>
","1"
"IDEA-254858","IntelliJ IDEA","","""Replace constructor with builder"" makes uncompilable code when choosing ""Use existing"" and select the class with the constructor itself.","Ethan Yin","08/11/2020 23:22","16/01/2023 11:33",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 07 Nov 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2957578"">#2957578</a></td><td>07 Nov 2020</td><td>Ethan Yin</td><td>jpseng@mailbox.org</td><td>Bug found in refactoring &#34;R...</td></tr></table></details>","1","No assigned support","Unknown","Version: IntelliJ 2020.2

 ![](image.png)![](image1.png)

apply refactoring ""Replace constructor with builder"":
Choose ""Use existing"" and select the class with the constructor itself

![](image2.png)


This leads to uncompilable code
![](image3.png)
![](image4.png)","0"
"IDEA-185710","IntelliJ IDEA","","Allow move left/right to move if-elseif branches","Róbert Papp","28/01/2018 10:04","16/01/2023 11:32",,"Normal","Feature",,"basleijdekkers","Java. Refactorings","2018.1.5 (181.5284.24)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 27 May 2019, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2118378"">#2118378</a></td><td>27 May 2019</td><td>Konstantin Annikov</td><td>kristjan.laane@gmail.com</td><td>IntelliJ IDEA feedback</td></tr></table></details>","1","No assigned support","Unknown","Similar to being able to move method arguments/params, e.g. `f(a,b,c)` -> `f(a,c,b)` when ""Code > Move Element Right"" is executed on `b`.

It would be a useful feature to allow a similar code transformation:
```
class X {
	void f(String s) {
		if (""a"".equals(s)) {
			System.out.println(""A"");
		} else if (""b"".equals(s)) {
			System.out.println(""B"");
		} else if (""c"".equals(s)) {
			System.out.println(""C"");
		}
	}
}
```
to if `b` moved to left or `a` moved to right
```
		if (""b"".equals(s)) {
			System.out.println(""B"");
		} else if (""a"".equals(s)) {
			System.out.println(""A"");
		} else if (""C"".equals(s)) {
			System.out.println(""C"");
		}
```

This transformation sould work if the user is focused on the following areas (enclosed within `<>`): `} <else if (>""a"".equals(s)<) {>`, maybe even including the condition, but that's tricky because you can already reorder boolean conditionals.","0"
"IDEA-253854","IntelliJ IDEA","","No option to add/remove annotation from parameters of extracted method","Timur Yuldashev","26/10/2020 13:17","16/01/2023 11:24",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 24 Nov 2021, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3647183"">#3647183</a></td><td>24 Nov 2021</td><td>Yaroslav Bedrov</td><td>info-jetbrains@p2r.se</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","1","No assigned support","Unknown","IU-211.277

If only parameters of extracted method are annotated there is no option to control that. For instance extracting this one printing line:
```
    void foo(@NotNull Object obj) {
        System.out.println(""obj = "" + obj);
    }
```

![](image.png)
![](image1.png)

The option is actually saved and applied, but shown and could be changed only when return type is annotated as well.
The same behaviour is in 2020.2 but i think this a bug, because every time IDEA adds inferred annotations, user should be able to control that.","0"
"IDEA-248028","IntelliJ IDEA","","""Safe Delete"" change field visibility from public to private and breaks code","Lejia Chen","12/08/2020 01:40","16/01/2023 11:19",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.3 (203.5981.155)","<details><summary>Last ticket submitted at 12 Aug 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2800637"">#2800637</a></td><td>12 Aug 2020</td><td>Lejia Chen</td><td>a01195770@itesm.mx</td><td>Find usage option show wron...</td></tr></table></details>","1","No assigned support","Unknown","Steps to reproduce:

1. Clone repo https://github.com/HectorRicardo/bug2-intellij and open it in IntelliJ
2. switch to the ""bug2"" branch (git switch bug2).
3. Run the Unused declaration inspection using the defaults (Whole project, everything checked and in public).
4. Try to delete the buggyMethod of MyInterface. (Use ""Safe delete"" in the Inspection Results)
5. There is a compile error in ChildA.java. buggyMethod changed from public to private.

The simper steps:
Use ""Safe delete"" from Reactor menu for `MyInterface.buggyMethod` method.","1"
"IDEA-52165","IntelliJ IDEA","","Refactor / Inline parameter: object method call between object variable initialization and passing variable to method is lost","Alexander Chernikov","10/02/2010 13:20","16/01/2023 11:18",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 21 Dec 2022, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/4599292"">#4599292</a></td><td>21 Dec 2022</td><td>Sergei Riabinin</td><td>Artem Miagkov</td><td>[YouTrack] IDEA-309184: &#34;In...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">Provide code with a chain of statements like: (object variable declaration; call to the object method; method call with this variable as a parameter):<br/><pre class=""wikicode prettyprint"">public class ExpData {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void use(Object p) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(p);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void context() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>ObjectType v3 = new ObjectType();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>v3.mutate();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>inline3(v3);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void inline3(ObjectType subj) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>use(subj);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}<br/><br/>class ObjectType {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>private int value = 1;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void mutate() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>value++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre>Refactor / Inline subj parameter. Resulted code is compilable, but v3.mutate() call is left out of the inline3() body. So, semantic may be broken.<br/><br/>94.273.</div>
","0"
"IDEA-154127","IntelliJ IDEA","","Extract refactorings: navigation and mnemonics problems","Timur Yuldashev","04/04/2016 10:41","16/01/2023 11:12",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 30 Jan 2019, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1961881"">#1961881</a></td><td>30 Jan 2019</td><td>Julia Vaseva</td><td>th33ts@gmail.com</td><td>keyboard shortcut for &#34;make...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">In the case i&#39;ve summarized found issues related to ability to use keyboard for navigation and editing and validation of mnemonics through extract refactoring dialogs.<br/><br/><strong>If only part of the problems is fixed, please strike them out in the text, so it would be clear what&#39;s left. Thanks.</strong> <br/><br/><h4>Common problems:</h4><br/><ul class=""wiki-list0""><li> Navigation through radio-buttons<br/></li><li> Navigation through checkboxes<br/></li><li> Cannot navigate into tables and select there specific options</li></ul><br/><h4>Extract refactoring dialogs</h4><br/><strong>Variable</strong><br/><ul class=""wiki-list0""><li> <span class=""monospace"">Tab</span> skips checkboxes <em>Replace all occurrences</em> and <em>Declare final</em><br/><br/><strong>Constant</strong><br/></li><li> Cannot select all <strong>Visibility</strong> options with keyboard. Focus moved to first option, but <span class=""monospace"">Up/Down</span> don&#39;t work properly after that.<br/></li><li> Mnemonic clash: &quot;Extract as &amp;enum constant&quot; and &quot;&amp;Escalate&quot;, suggest to change first one to &quot;e&amp;num&quot;.<br/><br/><strong>Field</strong><br/></li><li> <span class=""monospace"">Tab</span> skips all radio buttons and checkboxes<br/><br/><strong>Parameter (Functional parameter)</strong><br/></li><li> <span class=""monospace"">Tab</span> skips all checkboxes<br/><br/><strong>Introduce Parameter Object</strong><br/></li><li> If user selects &quot;Create inner class&quot; and focus stays there, it&#39;s not possible to move back hitting <span class=""monospace"">Shift-Tab</span><br/></li><li> If user NOT selects &quot;Use existing class&quot; it&#39;s not possible to get into &quot;Parameters to Extract&quot; with <span class=""monospace"">Tab</span><br/></li><li> When cursor gets into Parameter table it seems not possible to move out of the table with usage of keyboard<br/></li><li> Seems cannot change type of parameter with usage of keyboard, probably it&#39;s possible to use <span class=""monospace"">Space</span> to expand &quot;Type&quot; submenu<br/></li><li> No mnemonics to get into &quot;Parameters to Extract&quot; table. Maybe &quot;Para&amp;meters to Extract&quot; is good enough<br/></li><li> Mnemonic clash: &quot;&amp;Package name&quot; and &quot;&amp;Preview&quot; button. May change to &quot;Pac&amp;kage&quot;<br/></li><li> Mnemonic clash: &quot;Keep method as &amp;delegate&quot; and &quot;Target &amp;destination directory&quot;. May change to &quot;&amp;Target destination directory&quot;<br/><br/><strong>Method</strong><br/></li><li> <span class=""monospace"">Tab</span> skips &quot;Declare static&quot; checkbox<br/></li><li> When cursor gets into Parameter table it seems not possible to move out of the table with usage of keyboard<br/></li><li> Seems cannot change type of parameter with usage of keyboard, probably it&#39;s possible to use <span class=""monospace"">Space</span> to expand &quot;Type&quot; submenu<br/><br/><strong>Method object</strong><br/></li><li> When cursor gets into &quot;Parameters&quot; table it seems not possible to move out of the table with usage of keyboard<br/></li><li> Seems cannot change type of parameter with usage of keyboard, probably it&#39;s possible to use <span class=""monospace"">Space</span> to expand &quot;Type&quot; submenu<br/></li><li> If user NOT selects &quot;Create anonymous class&quot; it&#39;s not possible to get into &quot;Parameters&quot; table with <span class=""monospace"">Tab</span><br/></li><li> If user selects <strong>Create anonymous class</strong> and focus stays there, it&#39;s not possible to move back hitting <span class=""monospace"">Shift-Tab</span><br/></li><li> When cursor on &quot;Make static&quot; clicking <span class=""monospace"">Space</span> enables checkbox but also moves focus to &quot;Class name&quot; field instead of leaving it where it is.<br/></li><li> No mnemonics to get into &quot;Parameters&quot;. &quot;&amp;Parameters&quot; should be okay as it&#39;s the same as in &quot;Extract Method&quot; dialog.<br/><br/><strong>Delegate</strong><br/></li><li> When cursor gets into &quot;Members to Extract&quot; table it seems not possible to move out of the table with usage of keyboard<br/></li><li> In &quot;Members to Extract&quot; table cannot select option &quot;As enum&quot; with keyboard.<br/></li><li> Cannot select all &quot;Visibility&quot; options with keyboard <span class=""monospace"">Up/Down</span> skips some of the values.<br/></li><li> No mnemonic for &quot;Create nested class&quot;, we may use &#39;s&#39;, &#39;t&#39; or &#39;l&#39;.<br/></li><li> Mnemonic clash: &quot;Pu&amp;blic&quot; and &quot;Mem&amp;bers to Extract&quot;. May change to &quot;&amp;Members to Extract&quot;<br/></li><li> Mnemonic clash: &quot;&amp;Package name&quot; and &quot;&amp;Preview&quot; button. Seems the only variant to use is &#39;Pa&amp;ckage name&#39;.<br/><br/><strong>Interface</strong><br/></li><li> <span class=""monospace"">Tab</span> skips &quot;JavaDoc&quot; section radiobuttons.<br/></li><li> When cursor gets into &quot;Members to form Interface&quot; table it seems not possible to move out of the table with usage of keyboard<br/></li><li> In &quot;Members to form Interface&quot; table cannot select option &quot;Make abstract&quot; with keyboard.<br/></li><li> Mnemonics doesn&#39;t work for &quot;Interface name&quot; and &quot;Package for new interface&quot; or the same fields when select option &quot;Rename original class...&quot;<br/></li><li> Mnemonic clash: &quot;&amp;Package for new interface&quot; and &quot;&amp;Preview&quot; button. Seems may change to &quot;Pac&amp;kage for new interface&quot;<br/><br/><strong>Superclass</strong><br/></li><li> The same issues as with <strong>Interface</strong><br/></li><li> When select option &quot;Rename original class..&quot;, mnemonic &quot;&amp;Rename original class to&quot; conflicts with &quot;&amp;Refactor&quot; button. Better to change it &quot;Rename original cla&amp;ss to&quot;, so it would be the same for both options Extract/Rename.<br/></li></ul></div>
","9"
"IDEA-122030","IntelliJ IDEA","reproduced","Moving a class containing a main method did not update the run configurations","Yaroslav Bedrov","12/03/2014 06:33","16/01/2023 10:59",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 30 Dec 2017, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1193861"">#1193861</a></td><td>30 Dec 2017</td><td>Yaroslav Bedrov</td><td>xenoterracide@gmail.com</td><td>problems with gradle, using...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">Moving a class containing a main method did not update the run configurations accordingly (the associated build folders were still the old location).<br/>Moving main method to another class did not update the run configurations. </div>
","1"
"IDEA-59978","IntelliJ IDEA","","Change Signature should allow annotations to be added","Jonas Kvarnström","18/10/2010 11:20","16/01/2023 10:57",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 06 Dec 2018, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1895286"">#1895286</a></td><td>06 Dec 2018</td><td>Olga Klisho</td><td>notifications@youtrack-mail.jetbrains.com</td><td>[YouTrack, Created] data.Issue I...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">When I add a new parameter to a method using Change Signature (alt-F6), it should be possible to add annotations immediately.  For example, I may want to annotate new parameters with @NotNull or <a href=""https://youtrack.jetbrains.com/users/nullable"" title=""nullable"" data-user-id=""11-848785"">KS-KIM KS-KIM</a>.</div>
","10"
"IDEA-128019","IntelliJ IDEA","","Rename refactoring reformats code","Andrey Dernov","30/07/2014 04:16","16/01/2023 10:03",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 29 Mar 2018, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1313696"">#1313696</a></td><td>29 Mar 2018</td><td>Serge Baranov</td><td>smo@doclinx.com</td><td>Stop automatically reformat...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">How do disable reformat/reindent when renaming (shift-f6) variable?<br/><br/>Say I have a local variable that I use on a really long line:<br/><br/>1 SomeClass whatever = new SomeClass(); <br/>2 whatever.aReallyLongLineWithLotsOfStuff(parameter1, parameter2, parameter3, parameter4, parameter5);<br/><br/>The really long line extends past the right margin.<br/><br/>When I do shift-f6 on &quot;whatever&quot; to rename the variable, IDEA immediately reformats the really long line following my indentation rules, even before I&#39;ve typed the new name:<br/><br/><pre class=""wikicode prettyprint"">SomeClass whatever = new SomeClass(); <br/>whatever.aReallyLongLineWithLotsOfStuff( <br/>parameter1, <br/>parameter2, <br/>parameter3, <br/>parameter4, <br/>parameter5);</pre><br/>But I&#39;m just renaming the variable. I don&#39;t want it to reformat all the lines where that variable is used. Is there a setting to disable this feature without disabling ALL auto-formatting?</div>
","8"
"IDEA-232940","IntelliJ IDEA","","Change behavior of ""Use any variable"" in Change Signature refactoring to support multiple variables in scope","Sebastian Aigner","13/02/2020 14:12","16/01/2023 10:02",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"To be discussed","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 03 Nov 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2950126"">#2950126</a></td><td>03 Nov 2020</td><td>Olga Klisho</td><td>janphilipp.seng@amadeus.com</td><td>Bug in refactoring &#34;change ...</td></tr></table></details>","1","No assigned support","Unknown","**Expected**: any variable is chosen (probably the one with the innermost scope)

Note that if there is only one class- or local-variable, it gets picked correctly.

![](chooseany.gif)","0"
"IDEA-160061","IntelliJ IDEA","","Refactoring does not re-arrange the imports","George Karpenkov","19/08/2016 11:19","16/01/2023 10:02",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 07 Aug 2019, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2209341"">#2209341</a></td><td>07 Aug 2019</td><td>Serge Baranov</td><td>david_greenbaum@comcast.com</td><td>Rename Does Not Resort Imports</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">I have configured IntelliJ to automatically sort imports on saving files.<br/>Unfortunately, that task does not fire after the refactorings: thus any re-arrangements of classes may lead to inconsistent import order in any files.<br/>The issue can become quite painful if the project has a mandatory linter which enforces the import order.</div>
","1"
"IDEA-139252","IntelliJ IDEA","","Packages view: impossible to move package that exists in both project root(s) and library jar(s)","Irina Petrovskaya","15/04/2015 11:07","16/01/2023 09:58",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 20 Jun 2018, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/1453829"">#1453829</a></td><td>20 Jun 2018</td><td>Yaroslav Bedrov</td><td>vladislav.zablotsky@cloudlinux.com</td><td>Easy package renaming like ...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">142.1183<br/><br/>if the project contains package with name similar to some library package (for example, &#39;com&#39; or &#39;org&#39;), then i can preform Move refactoring for it via the Project view, but not from the Packages view.<br/>When F6 or Refactor/Move action are used, the dialog &quot;multiple directories correspond to package... continue?&quot; is displayed, and then the <br/>&quot;cannot perform refactoring&quot; error message is shown.<br/><br/>Shift-F6 works (except the case from the related issue)</div>
","1"
"IDEA-278497","IntelliJ IDEA","","Refactor | Encapsulate to Lombok annotation","Konstantin Annikov","19/09/2021 05:32","16/01/2023 09:48",,"Normal","Bug",,"michail.plushnikov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 18 Sep 2021, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3506770"">#3506770</a></td><td>18 Sep 2021</td><td>Konstantin Annikov</td><td>martinen@uk.ibm.com</td><td>Refactor | Encapsulate to L...</td></tr></table></details>","1","No assigned support","Unknown","Rather than refactor code with public fields to use getters and setters, is it possible to refactor a field to use Lombok annotations instead? So the result of the refactor changes a public field to private and adds the @Getter and @Setter annotations.

```
public final class Something {
public String state;
}
```

would become

```
public final class Something {

@Getter
@Setter
private String state;
}
```","3"
"IDEA-73408","IntelliJ IDEA","","Refactoring preview should also show the result of refactoring","Muescha","22/08/2011 08:02","16/01/2023 09:47",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 21 Mar 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2560566"">#2560566</a></td><td>21 Mar 2020</td><td>Antonina Belianskaya</td><td>tbttfox@gmail.com</td><td>Refactoring Rename UX</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">if i start a refactoring i can use the preview. but there i see only the current code. but i do not see the refactored code.<br/><br/>i would like to see also the refactored code result code.<br/><br/>(seen this feature at eclipse refatoring preview)</div>
","1"
"IDEA-180388","IntelliJ IDEA","","Copy... action is not available while updating indices","Tagir Valeev","11/10/2017 06:06","16/01/2023 09:43",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 30 Jun 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2734605"">#2734605</a></td><td>30 Jun 2020</td><td>Eugene Morozov</td><td>eranda@listudiosl.com</td><td>PhpStorm feedback</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">It&#39;s strange, because I can copy the file using Ctrl+C, Ctrl+V, but cannot copy the same file at the same momment using F5.</div>
","0"
"IDEA-133898","IntelliJ IDEA","","How to copy packages in IntelliJ without creating numerous fully-specified links to the old package","Josiah Yoder","04/12/2014 11:57","16/01/2023 09:36",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 14 Sep 2022, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/4298479"">#4298479</a></td><td>14 Sep 2022</td><td>Sergei Riabinin</td><td>jgonzalezsalv@uoc.edu</td><td>Java. Why when I copy a pac...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">When I use IntelliJ to copy a package which contains subpackages, every internal references to other classes in the same package is converted to an ugly fully-qualified name.  Worse yet, this fully-qualified name links back to the old package instead of to the copied class in the new package!  Does anyone know a workaround for this problem?<br/><br/>To reproduce this problem, I create a program structure like this:<br/><br/>![&quot;example&quot; folder containing an empty folder &quot;subpackage&quot; and two Java files &quot;A.java&quot; and &quot;B.java&quot;][1]<br/><br/>Where A.java is:<br/><br/>    package example;<br/>    <br/>    public class A { }<br/><br/>And B. java is:<br/>    package example;<br/>    <br/>    public class B {<br/>        private A a;<br/>        public B(A a) {<br/>            this.a = a;<br/>        }<br/>    }<br/><br/>I then Ctrl-C and Ctrl-V the example folder, and edit the dialog as below:<br/>![Dialog with example renamed to example2][2]<br/><br/>The copied version of classB now has every instance of A replaced with example.A<br/>    package example2;<br/><br/>    import example.*;<br/><br/>    public class B {<br/>        private example.A a;<br/>        public B(example.A a) {<br/>            this.a = a;<br/>        }<br/>    }<br/><br/>Can you change the copy-package feature so that it distinguishes between references to internal and external classes when copying the project?<br/><br/>I originally posted this question as a workaround request on Stack Overflow [3], and tried to post it earlier from a different email address.  I&#39;m re-posting it from my account so I can track it more easily.  I&#39;m a new user, and a bit confused what the difference between the different bug-tracking options are, or how to find my previously-posted bug.<br/><br/>My version is 13.1.4 &ndash; which I cannot enter on the right.<br/><br/>  [1]: <a href=""http://i.stack.imgur.com/eJjPe.png"" target=""_blank"" rel=""noopener noreferrer"">http://i.stack.imgur.com/eJjPe.png</a><br/>  [2]: <a href=""http://i.stack.imgur.com/JeJfx.png"" target=""_blank"" rel=""noopener noreferrer"">http://i.stack.imgur.com/JeJfx.png</a><br/>  [3]: <a href=""http://stackoverflow.com/questions/27296398/how-to-copy-packages-in-intellij-without-creating-numerous-fully-specified-links"" target=""_blank"" rel=""noopener noreferrer"">http://stackoverflow.com/questions/27296398/how-to-copy-packages-in-intellij-without-creating-numerous-fully-specified-links</a></div>
","0"
"IDEA-108172","IntelliJ IDEA","","new actions: safe and unsafe delete without dialog","Cristian Vasile Mocanu","31/05/2013 04:13","16/01/2023 09:33",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 21 Apr 2022, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3988896"">#3988896</a></td><td>21 Apr 2022</td><td>Lejia Chen</td><td>kurellajunior@gmail.com</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","1","No assigned support","Unknown","<div class=""wiki text prewrapped"">Please implement a new action &quot;Unsafe delete&quot; which is similar to the &quot;Safe delete&quot; action, but it doesn&#39;t display the dialog box and it doesn&#39;t do any kind of searches (no usages search, not string search, etc.). I suggest mapping this action as Shift+Delete, which deletes a file unsafely on Windows (it deletes the file directly, without moving it to trash).<br/><br/>Also implement the counterpart: a &quot;Safe delete without dialog&quot; action, which does the same things as the &quot;Safe delete&quot;, but doesn&#39;t display the dialog and does all searches (i.e. like I would check all checkboxes on that dialog box). Suggested key shortcut: Ctrl+Delete.<br/><br/><strong>Use case</strong><br/>Most of the time I invoke &quot;Safe delete&quot;, but sometimes I know some usages are not to the file I want to delete - so I need an &quot;Unsafe delete&quot;. In this case I need to either:<br/><ul class=""wiki-list0""><li> uncheck all checkboxes. In this case I have the inconvenience that I need to check them again next time I want to do safe delete - and I might forget<br/></li><li> leave the checkboxes checked. In this case the delete can take a lot of time, and I need to manually exclude all found references and then press &quot;Do refactor&quot;.</li></ul>In both cases the workflow is not as streamlined as it can.<br/><br/>Basically this feature request is to have delete actions in accordance with IntelliJ&#39;s philosophy: less dialogs, more focused actions, leading to increased productivity (even though it may be a little harder to learn in the beginning).</div>
","6"
"IDEA-297565","IntelliJ IDEA","Jigsaw","Combine 'Rename module and directory' with 'Rename package' for Jigsaw modules","Sergei Riabinin","07/07/2022 10:25","16/01/2023 09:21",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 01 Jul 2022, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/4136246"">#4136246</a></td><td>01 Jul 2022</td><td>Sergei Riabinin</td><td>esben.krag.hansen@gmail.com</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","1","No assigned support","Unknown","Reverse-DNS naming convention can be used for Jigsaw modules ([one](https://openjdk.org/projects/jigsaw/spec/sotms/#module-declarations), [two](https://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html)), so it could be nice if IDEA can detect that and combine 'Rename module and directory' with 'Rename package' for such modules

This module naming convention is followed e.g. in IDEA videos <https://youtu.be/Txsl-K83ygI>","0"
"IDEA-231518","IntelliJ IDEA","","Move inner class to upper level causes freeze","Olga Klisho","27/01/2020 10:25","16/01/2023 08:46",,"Normal","Bug",,"anet","Java. Refactorings","2019.3.2 (193.6015.39)",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 27 Jan 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2464996"">#2464996</a></td><td>27 Jan 2020</td><td>Olga Klisho</td><td>lynxpluto@gmail.com</td><td>IDE freezes when attempting...</td></tr></table></details>","1","No assigned support","Unknown","IU-193.6015.39 IDE freezes when attempting to move inner Java class to upper level. This works well in IDEA 2019.2.4 (IU-192.7142.36)","0"
"IDEA-268239","IntelliJ IDEA","","Replace Constructor with Builder does not allow use of Lombok builders","Mat Jaggard","28/04/2021 17:22","16/01/2023 08:43",,"Normal","Feature",,"michail.plushnikov","Java. Refactorings","2021.2 (212.4746.92)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 25 Feb 2022, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3853218"">#3853218</a></td><td>25 Feb 2022</td><td>Arina Efremova</td><td>kirill.semenov@seqvoia.com</td><td>Refactor constructor to (lo...</td></tr></table></details>","1","No assigned support","Unknown","***What steps will reproduce the issue?***
1. Create a class with a large number of properties
2. Create a constructor with all the properties
3. Use the constructor in another class
4. Create a Lombok builder by using `@Builder` (or `@SuperBuilder`)
5. Right click on the large constructor, select Refactor and then ""Replace constructor with builder..."" 
6. Attempt to select the Lombok generated Builder class using ""Use existing""
***What is the expected result?***
The builder class should appear in the list and selecting it should perform the refactor using the generated builder.

***What happens instead?***
The lombok generated builder does not appear in the list and cannot be searched for either.

*Please attach the [IDE logs](https://intellij-support.jetbrains.com/hc/en-us/articles/207241085) to the issue. You can get them by selecting Collect Logs and Diagnostic Data from the Help menu.*

*If possible, please attach a code sample, screenshot, or screencast that illustrates the problem.*

*To make the issue visible only to the JetBrains team, you can set its visibility to the `jetbrains-team` group. With the exception of images, all attachments are visible only to the JetBrains team by default.*

*If you can’t provide IDE logs, please provide information about the IDE version and the OS you are using. You can copy these details from the About dialog in the Help or App menu.*

*If you are experiencing performance issues, please also [attach the relevant snapshots](https://intellij-support.jetbrains.com/hc/en-us/articles/207241235).*

Tested on IntelliJ IDEA 2021.1 (Ultimate Edition)
Build #IU-211.6693.111, built on April 6, 2021 
Runtime version 11.0.10+9-b1341.35 x86_64
MacOS 11.3","3"
"IDEA-237618","IntelliJ IDEA","","'Refactor: Rename' of an HTML file creates wrong path in references to renamed file","Arina Efremova","14/04/2020 11:49","16/01/2023 08:41",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 11 Apr 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2597006"">#2597006</a></td><td>11 Apr 2020</td><td>Arina Efremova</td><td>9720560@gmail.com</td><td>Re: [JetBrains] Re: Intelli...</td></tr></table></details>","1","No assigned support","Unknown","Reported in https://jbs.zendesk.com/agent/tickets/2597006

Spring + JPA + Web project.

>Before refactoring in FileUploadControler.java I have: `return ""carsads/uploadPhoto"";`
RightClick on uploadPhoto  =>>  Refactor  =>> Rename   (or just Shift + F6)
We can use any name. F.e.: uploadPhoto2
`return ""carsads/uploadPhoto"";` =>>  `return ""uploadPhoto2"";`
Shouldn't it stay `""carsads/uploadPhoto2""`?

Link to GitHub project can be found in Zendesk.","0"
"IDEA-282109","IntelliJ IDEA","","Move to another module with dependencies","Olga Klisho","08/11/2021 09:19","16/01/2023 08:40",,"Normal","Feature",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 27 Oct 2021, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/3589394"">#3589394</a></td><td>27 Oct 2021</td><td>Olga Klisho</td><td>kevin@algoint.com</td><td>[IDEA webhelp] issue with p...</td></tr></table></details>","1","No assigned support","Unknown","Suggest to add library dependencies or dependencies on other modules during within modules refactoring.
Sample project attached.
[TwoModsProj.zip](TwoModsProj.zip)

Actual:
![](image.png)
Expected:
Suggest to add correspoding dependencies so that the classes become resolved.","0"
"IDEA-230852","IntelliJ IDEA","","Sort switch branches intention","Olga Klisho","17/01/2020 06:49","16/01/2023 08:31",,"Normal","Feature",,"Roman.Ivanov","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","<details><summary>Last ticket submitted at 05 Jan 2020, total tickets 1</summary><table><tr><th>ID</th><th>Created at</th><th>Assignee</th><th>Requester email</th><th>Subject</th></tr><tr><td><a href=""https://jbs.zendesk.com/agent/tickets/2429288"">#2429288</a></td><td>05 Jan 2020</td><td>Olga Klisho</td><td>st106012@stud.uni-stuttgart.de</td><td>Refactoring option to sort ...</td></tr></table></details>","1","No assigned support","Unknown","It would be nice to have a refactoring option on the jetbrains products to sort switch cases, e.g:
sorting from 0 ... x, sorting by enums capital letter etc.
This would be a handy feature I guess.

I do have use cases, where I use it to structure the code without using if statements or specific methods for every case. A very broken down example:

```
string myFruitName= ""tasty "";
switch(fruits) {
case Fruits.Apple:
myFruitName += ""apple"";
break;
case Fruits.Banana:
myFruitName += ""banana"";
break;
// ...
}
```

Imagine having a whole lot of fruits and adding them later on to the Fruits Enum. Intellij will ask you to automatically add them to the switch case, however it always adds them to the end.
Now if there is a lot of fruits and more code within the cases which is not redundant, it becomes hard to quickly find the correct case when searching through the statement.","1"
"IDEA-272592","IntelliJ IDEA","","""Introduce local variable"" could infer more details from 'Map.getOrDefault()' call","Dmitry Cherniachenko","28/06/2021 10:48","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","2021.2 (212.4746.92)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Introducing a local variable for a 'getOrDefault' call currently results in this:
![](image1.png)

IDEA could:
- suggest variable names based on the 'key' parameter rather than the method name (this also applies to 'Map.get()')
- use the actual type of the 'defaultValue' parameter for the variable","0"
"IDEA-226200","IntelliJ IDEA","","Extract variable should suggest better names (Mockito.mock)","Carsten  Otto","05/11/2019 07:21","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Use Mockito: `when(endpoint.getCapabilities(any())).thenReturn(mock(Capabilities.class));`
2. Extract a local variable for `mock(Capabilities.class)`

What is the expected result?
The new variable should have helpful name suggestions. In this case: `mock`, `capabilities` (maybe even`mockedCapabilities`, `capabilitiesMock`, ...)

What happens instead?
Just `mock` is offered as a name.

It is quite frustrating to always end up with variables (and fields) named `mock`. Either these names stay, which leads to unreadable code. Or, as a developer I have to change the names, which is a bit annoying. IntelliJ IDEA is very good at coming up with names, and I'd love to see this here, too.

IntelliJ IDEA 2019.2.4 (Ultimate Edition)
Build #IU-192.7142.36, built on October 29, 2019
Licensed to Carsten Otto
Subscription is active until March 16, 2020
Runtime version: 11.0.4+10-b304.77 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Linux 5.2.0-0.bpo.2-amd64
GC: ParNew, ConcurrentMarkSweep
Memory: 3891M
Cores: 16
Registry: 
Non-Bundled Plugins: CheckStyle-IDEA, Error-prone plugin, Lombook Plugin","0"
"IDEA-215041","IntelliJ IDEA","","Remember the factory method name selected and make it default","Olga Klisho","27/05/2019 14:50","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Would be convenient if the chosen factory method name in &quot;Replace constructor with factory method&quot; dialog was remembered and suggested as the default one afterwards.<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","1"
"IDEA-199272","IntelliJ IDEA","","Name suggestions should include names derived from wildcard bounds","Stephen Friedrich","21/09/2018 08:49","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">See this (dummy) example:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/>I just invoked &quot;introduce variable&quot;.<br/>IDEA only proposes &quot;t&quot; as the name for the variable.<br/>It should also propose &quot;number&quot; because that is a type bound of T.<br/><br/><pre class=""wikicode prettyprint"">class NumberFactory&lt;T extends Number&gt; {<br/>    T create() {<br/>        return null;<br/>    }<br/>}<br/><br/>class Calculator&lt;T extends Number&gt; {<br/>    NumberFactory&lt;T&gt; numberFactory;<br/><br/>    public Calculator(NumberFactory&lt;T&gt; numberFactory) {<br/>        this.numberFactory = numberFactory;<br/>    }<br/><br/>    T foo() {<br/>        numberFactory.create()<br/>    }<br/>}</pre></div>
","0"
"IDEA-180798","IntelliJ IDEA","","""Invert Boolean"" should suggest sensible name","Carsten  Otto","18/10/2017 07:56","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I invert a <code class=""inline-code"">notFoo</code> boolean (or method returning a boolean), this works as expected. However, the suggested name is <code class=""inline-code"">notFoo</code>. I expect IntelliJ IDEA to be clever enough to suggest <code class=""inline-code"">foo</code> instead.<br/><br/><code class=""inline-code"">notFoo</code> and <code class=""inline-code"">foo</code> should be valid pairs, <code class=""inline-code"">isFoo</code> and <code class=""inline-code"">isNotFoo</code> might also be good.<br/><br/>IntelliJ IDEA 2017.2.5<br/>Build #IU-172.4343.14, built on September 26, 2017<br/>Licensed to Carsten Otto<br/>Subscription is active until March 15, 2018<br/>JRE: 1.8.0_152-release-915-b12 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 7 6.1</div>
","0"
"IDEA-175367","IntelliJ IDEA","","Use the last 'getter' when suggesting options for ""Extract variable"" name","Dmitry Cherniachenko","04/07/2017 10:42","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Extracting variable for an expression like this <code class=""inline-code"">outputFile.getName().toLowerCase()</code> suggests the names based on the last method in the chain:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>It could be useful to add the names generated from the last &#39;getter&#39; in the chain too: <code class=""inline-code"">name</code>.<br/><br/>And in case the last &#39;getter&#39; is the first method called on some object a concatenation of the two would be useful as well: <code class=""inline-code"">outputFileName</code>.<br/>Just like you do when suggesting names for <code class=""inline-code"">outputFile.getName()</code>.<br/><br/>Or even in a more generic way: concatenation of the last &#39;getter&#39; and preceding object / &#39;getter&#39;:<br/><code class=""inline-code"">storage.getOutputFile().getName()</code> =&gt; <code class=""inline-code"">outputFileName</code> + <code class=""inline-code"">fileName</code> + <code class=""inline-code"">name</code><br/><code class=""inline-code"">source.getInputFiles().get(i).getName()</code> =&gt; <code class=""inline-code"">inputFileName</code> + <code class=""inline-code"">fileName</code> + <code class=""inline-code"">name</code></div>
","0"
"IDEA-143563","IntelliJ IDEA","","Rename variable with the same variable name in narrow scope is dangerous and ask confirmation","Anton Pashkin","06/08/2015 06:32","13/01/2023 06:26",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Assume we have the code with internal classes:<br/><pre class=""wikicode prettyprint"">class {<br/>  public void render() {<br/>    User sessionUser = getSession().getUser();<br/>    ....<br/>    add(new List(userService.getUsers()) {<br/>       public void render(User user) {<br/>            add(new List(timeService.getShifts(user)) {<br/>                  public void render(Shift shift) {<br/>                     boolean canEdit =  Can.edit(sessionUser, shift, user); <br/>                 }<br/>            })<br/>       }<br/>   })  <br/>  } <br/>}</pre><br/>When rename variable (using shift-F6) sessionUser to new name &#39;user&#39; then the program will change behaviour totally. that&#39;s is wrong and not suppose to do. it creates bugs. <br/><br/>Suggestion to show confirmation dialog in Intellij Idea or prevent to do it and part of the code (or at least line) that is already used that name.<br/>like this:<br/> boolean canEdit =  Can.edit(sessionUser, shift, user); </div>
","0"
"IDEA-86282","IntelliJ IDEA","","Variable in-place rename: variants improvement","Yann Cebron","18/05/2012 09:23","13/01/2023 06:26",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">actually #2 and #3 should be higher rated<br/><br/>118.476</div>
","0"
"IDEA-76929","IntelliJ IDEA","","Don't suggest numerically suffixed names when extracting variables and 'this' can be prefixed instead.","peter royal","14/11/2011 12:26","13/01/2023 06:26",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Given:<br/><br/><pre class=""wikicode prettyprint"">class Test {<br/>  Foo foo;<br/><br/>  public Test() {<br/>    this.foo = new Foo();<br/>  }<br/>}</pre><br/>if I select &#39;new Foo()&#39; and try to extract a constructor parameter, it wants to name it &#39;foo1&#39;, when &#39;foo&#39; is a perfectly valid (and more desirable) name, since &#39;this&#39; disambiguates the two variables.</div>
","1"
"IDEA-72147","IntelliJ IDEA","reply needed","Introduce Variable should include unresolved identifiers in current method in the list of name suggestions","Dmitry Jemerov","15/07/2011 09:19","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;m introducing the variable to make one of these identifiers resolved, so it would be helpful if IDEA suggested this for me.</div>
","1"
"IDEA-67113","IntelliJ IDEA","reproduced","Support new name sugesstions variants for introduce variable refactoring","Nikolai Matveev","26/03/2011 09:25","13/01/2023 06:26",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">For expression &#39;instruction.getAnchor().getTextRange()&#39; I expect to get several additional name suggestions:<br/><div class=""wiki quote"">instructionAnchorTextRange<br/>anchorTextRange</div><br/><br/>Currently it work only for one levels of getters i.e. for expressions like &#39;instruction.getAnchor()&#39;</div>
","0"
"IDEA-308408","IntelliJ IDEA","","Inline parameter should not be performed if parameter type is generic","Artem Miagkov","13/12/2022 05:33","10/01/2023 14:33",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","artem.miagkov","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Sample code:**

```
public class InlineParameterLab {

    class InnerClass1<T>{
        public void method1(T innerLine1){
            T SomeObject = innerLine1;
        }   
    }
    
    class InnerClass2{
        InnerClass1<Integer> Class1 = new InnerClass1<>();
        
        public void method2(){
            Class1.method1(1);
        }
    }
}
```

Upon inline parameter refactoring on `innerLine1` result is:

```
public void method1(){T SomeObject = (T) 1;}
```

which leads to type cast error.



**Justification:**

while we could try to replace type for parameter and assigned variable, it will lead to various other unresolvable edge cases (e.g. generic class parameter with multiple setter-like methods)","0"
"IDEA-309094","IntelliJ IDEA","","Incorrect ""Introduce Variable"" refactoring, resulting in NullPointerException","chixiaye","21/12/2022 05:06","06/01/2023 12:28",,"Normal","Feature",,"Tagir.Valeev","Java. Refactorings","2022.2.4 (222.4459.24)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","2023.1","No zendesk mentions",,"No assigned support","Unknown","# Incorrect ""Introduce Variable"" refactoring, resulting in NullPointerException

## Description

""Introduce Variable"" refactoring is a useful feature of IDEA. However, in some cases, it may not work correctly. Here we report a bug in this feature and attach a feasible patch for the bug.

We take the following sample code to illustrate the bug:

```java
1   /* CS1: Original Code Snippet */  
2   public String metaPhone(final String txt){  
3       boolean hard = false;  
4       if(txt == null || txt.length() == 0){  
5           return """";  
6       }  
7       if(txt.length() == 1){  
8           return txt.toUpperCase(java.util.Local.ENGLISH);  
9       }  
10      //Do other things  
11      // ...  
12   }  
```

If we select the expression `txt.length()` (line `4` in `CS1`), conduct refactoring "" introduce variable"", and name the new variable as `length` , we will get the following code snippet:

```java
1   /* CS2: Code Snippet after refactoring */  
2   public String metaPhone(final String txt){  
3       boolean hard = false;  
4       int length = txt.length();  
5       if(txt == null || length == 0){  
6           return """";  
7       }  
8       if(length == 1){  
9           return txt.toUpperCase(java.util.Local.ENGLISH);  
10       }  
11      //Do other things  
12      // ...  
13   }  
```

The refactoring is incorrect and dangerous. If the method is called via `metaphone(null)`, the refactored version would result in NullPointerException whereas the original version would not.","0"
"IDEA-202251","IntelliJ IDEA","","Moving parameters in method signature does not move parameter comments at call sites","Dmitry Cherniachenko","14/11/2018 13:49","03/01/2023 16:01",,"Normal","Feature",,"anet","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","A method:
`fromOptions(boolean ignoreUnavailable, boolean allowNoIndices)`

Called like this:
`fromOptions(/* ignoreUnavailable= */ true, /* allowNoIndices= */ false)`

Running ""Change Signature"" (Ctrl+F6) and swapping the parameters order results in:
`fromOptions(/* ignoreUnavailable= */ false, true /* allowNoIndices= */)`

See also https://errorprone.info/bugpattern/ParameterComment","2"
"IDEA-201126","IntelliJ IDEA","","Introduce variable which replaces many occurrences should use most specific type","Andrey Turbanov","24/10/2018 11:24","03/01/2023 15:56",,"Normal","Usability Problem",,"anet","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    private static void load(StringBuilder a, CharSequence b, boolean which) {<br/>        loadFromDb(which ? a : b);<br/>        loadFromHttp(which ?&lt;caret&gt; a : b);<br/>    }<br/><br/>    private static void loadFromDb(CharSequence number) {<br/>    }<br/><br/>    private static void loadFromHttp(Object number) {<br/>    }</pre><br/>Invoke &#39;Introduce Variable&#39; refactoring and choose to replace all occurrences.<br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">        CharSequence number = which ? a : b;<br/>        loadFromDb(number);<br/>        loadFromHttp(number);</pre><br/><strong>Actual</strong><br/>Uncompilable source<br/><pre class=""wikicode prettyprint"">        Object number = which ? a : b;<br/>        loadFromDb(number);<br/>        loadFromHttp(number);</pre></div>
","0"
"IDEA-201607","IntelliJ IDEA","","Introducing variable as a fix for duplicate expressions inspection may change the semantics","Pavel Dolgov","01/11/2018 08:40","03/01/2023 15:56",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Found in <code class=""inline-code"">com.intellij.openapi.util.IconLoader</code> at commit d3425785<br/><br/>The expression <code class=""inline-code"">path.substring(0, path.length() - 4)</code> is highlighted as a duplicate, which is correct.<br/><pre class=""wikicode prettyprint"">  @Nullable<br/>  private static String tryAnotherPath(@NotNull String path) {<br/>    if (path.endsWith(&quot;.png&quot;)) return path.substring(0, path.length() - 4) + &quot;.svg&quot;;<br/>    if (path.endsWith(&quot;.svg&quot;)) return path.substring(0, path.length() - 4) + &quot;.png&quot;;<br/>    return null;<br/>  }</pre><br/>The problem is that after introducing the variable <code class=""inline-code"">substring</code> the length of the <code class=""inline-code"">path</code> isn&#39;t checked which may cause an exception.<br/><pre class=""wikicode prettyprint"">  @Nullable<br/>  private static String tryAnotherPath(@NotNull String path) {<br/>    String substring = path.substring(0, path.length() - 4);<br/>    if (path.endsWith(&quot;.png&quot;)) return substring + &quot;.svg&quot;;<br/>    if (path.endsWith(&quot;.svg&quot;)) return substring + &quot;.png&quot;;<br/>    return null;<br/>  }</pre><br/>IntelliJ IDEA 2018.3 EAP (Ultimate Edition)<br/>Build #IU-183.3975.18, built on October 24, 2018</div>
","0"
"IDEA-201068","IntelliJ IDEA","","Move on anonymous class in interface does not work if class uses SuperType.this reference","Bartłomiej Mazur","24/10/2018 03:42","03/01/2023 15:53",,"Normal","Bug",,"anet","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.1 (191.6183.87)","No zendesk mentions",,"No assigned support","Unknown","Example code:
```java
    interface Test {
        void run();
        default Test warpForNoReason() {
            return new Test() {
                @Override
                public void run() {
                    Test.this.run(); // there is reference to outer instance
                }
            };
        }
    }
```
After moving that anonymous class or using ""Convert anonymous to inner"" it will be extracted as inner class inside interface, and because interfaces don't really support non-static nested classes it will produce invalid code like this: 
```java
        default Test warpForNoReason() {
            return new MyTest();
        }
        class MyTest implements Test {
            @Override
            public void run() {
                Test.this.run();
            }
        }
```
Where it should convert it to typical static nested class like this: 
```java
        default Test loop(int times) {
            return new MyTest(this, times);
        }
        class MyTest implements Test {
            private final Test instance;
            public MyTest(Test instance) {
                this.instance = instance;
            }
            @Override
            public void run() {
                this.instance.run();
            }
        }
```","0"
"IDEA-284713","IntelliJ IDEA","","""Extract interface"" thinks code was changed and is unable to replace usages of class with interface","Simon Stratmann","12/12/2021 15:39","03/01/2023 14:57",,"Normal","Bug",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","To reproduce:
Extract an interface and pull an existing method up.
Choose to replace usages of the class with the interface.

I get an error that the code was changed inbetween even though I just navigated through the dialogs.

Please see these screenshots. You can reproduce using the attached project [demo.zip](demo.zip).
![](intellij extract interface 1.png)
![](intellij extract interface 2.png)
![](intellij extract interface 3.png)
![](intellij extract interface 4.png)
![](intellij extract interface 5.png)

Diagnostic data: 
[idea-logs-20211212-19390012444074806400495350.zip](idea-logs-20211212-19390012444074806400495350.zip)","2"
"IDEA-281972","IntelliJ IDEA","","Rename variables refactor dialog too small (hidpi issue?)","Bob Brown","04/11/2021 19:10","03/01/2023 14:48",,"Normal","Bug",,"Vassiliy.Kudryashov","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Invoked via SHIFT-F6.

As shown.

![](image.png)

Note the 5760.0x3240.0 screen resolution.

FYI, this is a Dell XPS 900 laptop.

IU-213.5605.12, JRE 11.0.13+7-b1751.16x64 JetBrains s.r.o., OS Windows 11(amd64) v10.0 , screens 6720.0x4200.0, 5760.0x3240.0","0"
"IDEA-280267","IntelliJ IDEA","","'Introduce Variable' refactoring uses nonsensical type for variable","Andrey Turbanov","13/10/2021 09:16","03/01/2023 14:40",,"Normal","Bug",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
import java.util.List;

public class IntroduceVarFromVar {
    void doWork(Provider<?> provider) {
        var o = provider.get();
        for (var number : o) {
            System.out.println(number<caret>);
        }
    }
}

interface Provider<T extends Enum<?> & Appendable> {
    List<T> get();
}
```
Try to extract variable from `number`

**Expected**
```
        var o = provider.get();
        for (var number : o) {
            var number1 = number;
            System.out.println(number1);
        }
```

**Actual**
IDEA uses some strange types, like `boolean`. In my project it even suggest classes from another module - inaccessible from current context.
```
        var o = provider.get();
        for (var number : o) {
            boolean number1 = (boolean)number;
            System.out.println(number1);
        }
```","0"
"IDEA-281626","IntelliJ IDEA","","Retain the typed out package name on refactoring /  renaming, extracting to method, pull out to class...","momomo","31/10/2021 16:25","03/01/2023 14:11",,"Normal","Bug",,"anet","Java. Refactorings","2021.2.3 (212.5457.46)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2021.3 (213.5744.223)","No zendesk mentions",,"No assigned support","Unknown","See video. 

![](Screen Recording 2021-10-31 at 20.22.41.mov)


","0"
"IDEA-282316","IntelliJ IDEA","3q2020","Renaming a common method takes several minutes","Alice Kober-Sotzek","10/11/2021 11:30","03/01/2023 14:10",,"Normal","Performance Problem",,"cdr","Java. Refactorings","2021.2.3 (212.5457.46)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***Context***
Our internal users have been complaining about bigger performance issues in large IntelliJ projects for the last major IntelliJ versions (2021.2, 2021.1, 2020.3, 2020.2, 2020.1) and those issues seem to have gotten worse in the 2021.x versions. A quick test of 2021.3 EAP didn't seem better.

I'm creating several different reports for each different action in the IDE. It's very likely, though, that all of them have a common root cause.

This report is for the slow renaming of a common method (e.g. a method like `build()`).

***IntelliJ project details***
* Single module
* \>7000 libraries
* 30 source roots with many files below them

***Executed steps***
1. Go to a Java class with a common method (e.g. a method like `build()`).
2. Wait for the IDE to be idle.
3. Rename the method.

***Observed performance***
The IDE showed a “Looking for Usages” popup with the message “Searching for build in 2,200 files” for several minutes after the renaming was requested. The new name was applied only when the search was finished and the popup had disappeared.

Interestingly, there is no delay at all when invoking the “Find usages” action while the method is still named ""build"" (result: 3 usages).

***CPU snapshots***
All of these snapshots were for exactly the same action.
* IU-212.5080.55_aliceks_05.11.2021_14.12.16.snapshot
* IU-212.5457.46_aliceks_10.11.2021_13.01.26.snapshot (with disabled internal plugins to avoid interference)","0"
"IDEA-276951","IntelliJ IDEA","","""Update implementation"" hint truncating signature","Joachim Ansorg","27/08/2021 07:13","03/01/2023 13:50",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.2.1 (212.5080.55)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2021.3 (213.5744.223)","No zendesk mentions",,"No assigned support","Unknown","I updated the signature in an interface in the editor and then wanted to apply the implementations. The hint is truncating old and new signatures and not that helpful here.

![](Screenshot_20210827_121119.png)","0"
"IDEA-277382","IntelliJ IDEA","","Moving packages shows conflicts between memory and filesystem for dozens or even hundreds of files","Dirk Dittert","02/09/2021 10:17","03/01/2023 13:24",,"Normal","Bug",,"anet","Java. Refactorings","2021.2.1 (212.5080.55)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1. Move a Java package with several subpackages to another package of the same module

***What is the expected result?***
The classes are moved

***What happens instead?***
Classes are moved to the destination but IntelliJ shows a dialog that there now is a conflict between the memory contents and the filesytem contents. The diff dialog shows that the filesytem contents still has the old imports and the memory contents has the new imports that result from the move operation.

I have seen instances of this problem with hundreds of files that have this conflict. Luckily, it was only a few of them for this case that is shown in `idea.log`.

It would be great to have a **Accept all memory changes** or **Accept all filesystem changes** button as there can be a lot of affected files. You can't just keep clicking one of the buttons as the width of that dialog depends on the path of the file that has the conflict. Because of that, the position of the buttons shifts and you start hitting the wrong buttons accidently. That problem would go away if the dialog had a fixed width.

The project versioned under Git and the changelist contains 207 entries after the move (i.e. it is only a small move). 

```
IntelliJ IDEA 2021.2.1 (Ultimate Edition)
Build #IU-212.5080.55, built on August 24, 2021
Runtime version: 11.0.11+9-b1504.16 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
Windows 10 10.0
GC: ParNew, ConcurrentMarkSweep
Memory: 5966M
Cores: 4
Registry: debugger.watches.in.variables=false, documentation.show.toolbar=true
Non-Bundled Plugins: JFormDesigner (7.0.4), YourKit Java Profiler 2021.3-b230 Integration (2021.3.230.0), com.intellij.guice (212.5080.8)
Kotlin: 212-1.5.10-release-IJ5080.55
```","0"
"IDEA-271467","IntelliJ IDEA","","""Replace with 'try' with resources"" quick-fix produces uncompilable code","Andrey Turbanov","13/06/2021 10:25","03/01/2023 12:38",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2021.2 (212.4746.92)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
public abstract class TryWithResources {
    public void show(InputStream is) {
        BufferedInputStream bis = new BufferedInputStream(is);
        try {
            showFull(bis);
        } finally {
            try {
                bis.close();
            } catch (IOException ignore) {
            }
        }
    }

    protected abstract void showFull(InputStream is);
}
```

Invoke quick-fix `Replace with 'try' with resources` from inspection `Java | Java language level migration aids | Java 7 | 'try finally' replaceable with 'try' with resources`

**Expected**
Something like this:
```
    public void show(InputStream is) {
        try (BufferedInputStream bis = new BufferedInputStream(is)) {
            showFull(bis);
        } catch (IOException ignore) {
        }
    }
```
Or do not propose to replace code.

**Actual**
Uncompilable code
```
    public void show(InputStream is) {
        try (BufferedInputStream bis = new BufferedInputStream(is)) {
            showFull(bis);
        }
    }
```","0"
"IDEA-272047","IntelliJ IDEA","","'Introduce local variable' is unable to infer type when custom Stream Collector is used","Andrey Turbanov","21/06/2021 08:04","03/01/2023 12:38",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.2 (212.4746.92)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
import java.util.stream.Collector;
import java.util.stream.Stream;

public class CustomCollector {

    void calc(Stream<StringBuilder> legs) {
        legs
                .map(StringBuilder::toString)
                .collect(collectorLong(instrumentByIdIndexer));
    }

    public static final Indexer<String> instrumentByIdIndexer = String::length;

    public static <V> Collector<V, ?, ? extends IndexedSet<Long, V>> collectorLong(Indexer<? super V> indexer) {
        throw new UnsupportedOperationException(indexer.toString());
    }
}

abstract class IndexedSet<K, V> {
}

interface Indexer<V> {
    long getNumberKey(V value);
}
```

Try to invoke `Introduce local variable` for result of `.collect` call

**Expected**
```
        IndexedSet<Long, String> collect = legs
                .map(StringBuilder::toString)
                .collect(collectorLong(instrumentByIdIndexer));
```

**Actual**
```
        Object collect = legs
                .map(StringBuilder::toString)
                .collect(collectorLong(instrumentByIdIndexer));
```","0"
"IDEA-309185","IntelliJ IDEA","","""Inline parameter"" - inline parameter changes preformed prior to method call.","Artem Miagkov","21/12/2022 15:55","21/12/2022 15:58",,"Normal","Feature",,"artem.miagkov","Java. Refactorings","Not specified",,"Submitted","Not specified","artem.miagkov","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","## **Use case 1**

### Code sample:

```
    public void method1(ArrayList<Integer> someList){
        System.out.println(someList);
    }

    public void methodCallForMethod1(){
        ArrayList<Integer> param = new ArrayList<>();
        param.add(1);
        param.add(2);
        param.add(3);
        method1(param);
    }
```

### Current behavior:

Without local variable generation:

```
    public void method1(){
        System.out.println(new ArrayList<Integer>());
    }
```

With local variable:

```
    public void method1(){
        ArrayList<Integer> someList = new ArrayList<>();
        System.out.println(someList);
    }
```

### Desirable behavior:

object method calls are identified and suggested to be copied to `method1` in interactive manner.

If at least one call is selected, then local variable generation is forced and cannot be untoggled.

Resulting code:

```
    public void method1(){
        ArrayList<Integer> someList = new ArrayList<>();
        someList.add(1);
        someList.add(2);
        someList.add(3);
        System.out.println(someList);
    }

    public void methodCallForMethod1(){
        ArrayList<Integer> param = new ArrayList<>();
        param.add(1);
        param.add(2);
        param.add(3);
        method1();
    }
```

### Reason

Straight-forward copy may lead to semantic being broken (see also [IDEA-52165](https://youtrack.jetbrains.com/issue/IDEA-52165/Refactor-Inline-parameter-object-method-call-between-object-variable-initialization-and-passing-variable-to-method-is-lost))

## Use case 2

### Code sample:

```
    private class TaxPayer{
        String name;
        String surname;
        Integer yearlyProfit;
        Double taxAmount;
        public void setName(String name) {this.name = name;}
        public void setSurname(String surname) {this.surname = surname;}
        public void setYearlyProfit(Integer yearlyProfit) {this.yearlyProfit = yearlyProfit;}
        public void setTaxAmount(Double taxPercentage){this.taxAmount = yearlyProfit * taxPercentage;}
        //toString omited 
    }
    
    public void printTaxpayer(TaxPayer person){
        System.out.println(person);
    }
    
    public void checIRA(){
        Double carWashTaxingPercentage = 0.39;
        TaxPayer heizenberg = new TaxPayer();
        heizenberg.setName(""Walter"");
        heizenberg.setSurname(""White"");
        heizenberg.setYearlyProfit(10000000);
        heizenberg.setTaxAmount(carWashTaxingPercentage);
        printTaxpayer(heizenberg);
    }
```

### Desirable behavior:

Local variable `carWashTaxingPercentage` is paired with `heizenberg.setTaxAmount(carWashTaxingPercentage);` for copying.","0"
"IDEA-309171","IntelliJ IDEA","","""Inline parameter"" does not replace parameter usage in lambda","Artem Miagkov","21/12/2022 14:17","21/12/2022 14:17",,"Normal","Bug",,"artem.miagkov","Java. Refactorings","Not specified",,"Submitted","Not specified","artem.miagkov","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Code sample:**

```
    interface Sayable{
        public String say(String someWord);
    }

    public void speakUp(){
        Sayable phrase =(theWord)->{return theWord + "" is the word!"";};

        System.out.println(phrase.say(""Bird""));
    }
```

**Steps:**

* Use `inline parameter` on `someWord` in the interface

**Actual result:**

```
    interface Sayable{
        public String say();
    }

    public void speakUp(){
        Sayable phrase =()->{return theWord + "" is the word!"";};

        System.out.println(phrase.say());
    }
```

**Expected result:**

```
    interface Sayable{
        public String say();
    }

    public void speakUp(){
        Sayable phrase =()->{return ""Bird"" + "" is the word!"";};

        System.out.println(phrase.say());
    }
```","0"
"IDEA-309168","IntelliJ IDEA","","""Inline parameter"" performs inline for side-effect action/assignment operation","Artem Miagkov","07/12/2022 11:39","21/12/2022 14:02",,"Normal","Bug",,"artem.miagkov","Java. Refactorings","Not specified",,"Submitted","Not specified","artem.miagkov","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Code sample:**

```
public class InlineParameterLab {
    public Integer number1;
    private String line1;

    public void method1(String innerLine1){
        innerLine1= line1 +""Some text"";
    }

    public String method2(){
        String tempString = ""ABC"";
        method1(tempString);
        return  tempString;
    }
}
```

**Steps:**

1. Invoke `inline parameter` on innerLine1

**ER:**
Error message (smth like ""Cannot inline parameter to assignment"")

**AR:**

```
public void method1(){
    ""ABC"" = line1 +""Some text"";
} 
```","0"
"IDEA-308979","IntelliJ IDEA","","Show confirmation popup for inline parameter refactoring interaction on class constructor.","Artem Miagkov","19/12/2022 20:26","20/12/2022 03:03",,"Minor","Cosmetics",,"sergei.riabinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Pre-condition:**

* Class with field that set in class constructor as constructor parameter
* Single instance of that class with corresponding construction call

**Current behavior:**

Inline parameter refactoring on constructor shows same confirmation window as for any other method

**Suggested behavior:**

Show warning as part of confirmation popup.
Suggested text: TBD","0"
"IDEA-308977","IntelliJ IDEA","","inline parameter for recursive call generates unreachable local variable","Artem Miagkov","19/12/2022 19:26","20/12/2022 03:03",,"Normal","Bug",,"sergei.riabinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Code sample:**

```
    class InnerClass1{

        public void recursiveCountdown(Integer a){
            if (a == 1){
                return;
            }
            recursiveCountdown(a-1);

        }

    }
```

**Steps:**

1. Call ""inline parameter"" on `a` 

**Actual result:**

With creation of local variable

```
       public void recursiveCountdown(){
            Integer a = a-1;
            if (a == 1){
                return;
            }
            recursiveCountdown();
            
        }
```

Without creation of local variable

```
        public void recursiveCountdown(){
            if ((a-1) == 1){
                return;
            }
            recursiveCountdown();
            
        }
```

**Potential solutions:**

1. Suggest to introduce global private variable on class level
2. Do not allow ""Inline parameter"" for recursive call","0"
"IDEA-306678","IntelliJ IDEA","","Check 'Inline Parameter' functionality","Sergei Riabinin","24/11/2022 06:55","05/12/2022 16:03",,"Normal","Task",,"artem.miagkov","Java. Refactorings","Not specified",,"In Progress","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown",,"0"
"IDEA-159807","IntelliJ IDEA","","Rename: Offer original choice for autocompletion","Carsten  Otto","13/08/2016 19:41","01/12/2022 09:02",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When renaming variables/methods/... I often press the rename shortcut and delete the original name, only to realize (after some failed attempts?) that I cannot come up with a better name despite my original intention. In these situations, I could press ESC, CTRL+z to revert, but this is cumbersome and not really intuitive. Instead, I often just re-type the original name (hopefully without introducing a typo!).<br/><br/>Depending on the original name, this name is not recommended by IntelliJ IDEA after deleting it. I propose that the list of suggestions is extended to include the original name, so that it can easily be selected/completed after typing the first few characters.<br/><br/>Example:<br/><br/><pre class=""wikicode prettyprint"">LocalDate today;</pre><br/>If I start renaming the variable, the options <code class=""inline-code"">localDate, date, today</code> are suggested. After deleting the name using backspace, I only get <code class=""inline-code"">localDate, date</code> as suggestions. As such, if I want to stick with <code class=""inline-code"">today</code>, I either have to use ESC, CTRL+z or type <code class=""inline-code"">today</code> again. As a solution, I&#39;d like to see <code class=""inline-code"">localDate, date, today</code> as suggestions, which collapse to <code class=""inline-code"">today</code> after typing <code class=""inline-code"">t</code>.<br/><br/>PS: I assigned this to Java Refactoring, but I guess this also applies to other languages and more general renamings.<br/><br/>IntelliJ IDEA 2016.2.2 EAP<br/>Build #IU-162.1628.17, built on August 8, 2016<br/>Licensed to Carsten Otto<br/>You have perpetual fallback license for this version<br/>Subscription is active until March 15, 2018<br/>JRE: 1.8.0_76-release-b216 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o</div>
","0"
"IDEA-153400","IntelliJ IDEA","","Rename refactoring: exclude current name from suggestions","Timur Yuldashev","21/03/2016 14:52","01/12/2022 08:06",,"Normal","Usability Problem",,"sergei.riabinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","2022.3 (223.7571.182)","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Seems in most cases (if not all) suggestions include the same name as current one. Is it possible to exclude it? Seems it doesn&#39;t make sense.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","3"
"IDEA-306378","IntelliJ IDEA","","'Inline Parameter' could be smarter in handling expression which depends on other parameters","Andrey Turbanov","19/11/2022 17:20","24/11/2022 06:56",,"Normal","Usability Problem",,"anet","Java. Refactorings","2022.3 RC (223.7571.58)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
package org.bench;

public class InlineUsedParam {
    private String line;

    void perform() {
        System.out.println(new SomeBean(line, Integer.parseInt(line)));
    }
}

class SomeBean {
    private final String line;
    private final Integer value;

    public SomeBean(String line, Integer value<caret>) {
        this.line = line;
        this.value = value;
    }
}
```

Try to invoke `Inline Parameter`

**Expected**
IDEA could be smart here and notice that expression depends on the field which is already passed as a parameter to the same constructor.
```
    public SomeBean(String line) {
        this.line = line;
        this.value = Integer.parseInt(line);
    }
```


**Actual**
IDEA shows warning and then uses reference to the original field.
While it's technically correct, I think it would be very helpful for refactoring, if IDEA be able to use parameter instead of field.
```
    public SomeBean(String line) {
        this.line = line;
        this.value = Integer.parseInt(InlineUsedParam.this.line);
    }
```","0"
"IDEA-217583","IntelliJ IDEA","","Inline Method should not report ""Method body will be transformed to single exit point form"" in ""Problems detected"" dialog","Dmitry Jemerov","04/07/2019 11:28","15/11/2022 11:50",,"Normal","Usability Problem",,"Tagir.Valeev","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">This doesn&#39;t sound like a problem, and it&#39;s not clear why the user needs to be offered a choice (the other option is the refactoring not working, which doesn&#39;t look useful). I think this just needs to be performed silently, possibly with a non-modal notification after a refactoring (&quot;Method body has been transformed to single exit point form&quot;).</div>
","0"
"IDEA-202307","IntelliJ IDEA","","Intention to replace 'computeIfAbsent' & Co with 'get - null check - put' combo","Dmitry Cherniachenko","15/11/2018 12:24","15/11/2022 11:50",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","During a refactoring a method used in `computeIfAbsent` lambda gained `throws IOException` clause.
So the lambda cannot be used anymore. And I need to replace it back with a ""classic"" approach of 'get - null check - put'.
It would be nice if IDEA was able to help me with this.","0"
"IDEA-71792","IntelliJ IDEA","","Support inlining of abstract methods","Alexander Torstling","05/07/2011 09:38","15/11/2022 11:48",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently IntelliJ does not support inlining of abstract methods. If you for instance try to inline a method in an interface, you get the error &quot;Inline Method refactoring cannot be applied to abstract methods&quot;. <br/><br/>Supporting inlining of abstract methods is something which would be helpful to our team when eliminating interface methods having just one implementation. We have not yet found any effective workaround for this problem. The only workaround we have come up with is to convert the interface to an abstract class, move the (only) implementation of the method up to this abstract class, and then inline. This causes problems due to Java not supporting multiple inheritance, so you cannot use this trick if your implementors already inherit. It also involves changing the code of every implementor.</div>
","4"
"IDEABKL-7157","IntelliJ IDEA: Backlog","","Inline variable refactoring produces incorrect result","Dmitry Cherniachenko","09/02/2015 12:17","08/11/2022 20:26",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Here is the example:<br/><pre class=""wikicode prettyprint"">        StringBuilder sb = new StringBuilder();<br/>        sb.append(&quot;test&quot;);<br/>        return sb.toString();</pre><br/>Pressing Ctrl+Alt+N when cursor is on the <code class=""inline-code"">sb</code> in the last line produces the following:<br/><pre class=""wikicode prettyprint"">        new StringBuilder().append(&quot;test&quot;);<br/>        return new StringBuilder().toString();</pre><br/>While something like this is expected instead:<br/><pre class=""wikicode prettyprint"">        return new StringBuilder().append(&quot;test&quot;).toString();</pre><br/><br/>FYI: The same issue was reported in ReSharper ... 3 years ago - <a href=""/issue/RSRP-287531"" target=""_self"" data-issue-id=""25-376387"" title=""Incorrect code is generated when inlining a variable that is a collection"">RSRP-287531</a></div>
","0"
"IDEA-305541","IntelliJ IDEA","","Introduce variable: uncheck 'var' should use the preferred type for the extraction","Anton Arhipov","08/11/2022 05:53","08/11/2022 06:43",,"Normal","Usability Problem",,"Tagir.Valeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Example: a variable is declared as ""var"" and has a type of ArrayList\<String\>. If I want to change it to the explicit type declaration then the quick action suggests ArrayList\<String\> but it should rather offer List\<String\> unless this variable is used as an ArrayList specifically

![](image.png){width=70%}

The same happens during extract variable refactoring. Type: ArrayList\<String\>() and call extract variable refactoring:

![](image1.png){width=70%}

Now call the options popup via Option+Shift+O and declare the new variable as var type:

![](image2.png){width=70%}

Unclick var to the  explicit type again, and we get an ArrayList\<String\> instead of List\<String\>

![](image3.png){width=70%}








","0"
"IDEA-304969","IntelliJ IDEA","","Cannot create a new class while moving members","Sergei Riabinin","31/10/2022 05:29","31/10/2022 05:29",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Start with a class like this:<br/><pre class=""wikicode prettyprint"">package org;<br/><br/>public class Demo<br/>{<br/>    public static String generateId() {<br/>        return &quot;42&quot;;<br/>    }<br/>}</pre><br/>Invoke Refactor | Move (F6) for the <code class=""inline-code"">generateId()</code> method.<br/>Here is the first problem: IDEA asks for the fully qualified name of the target class. So if I want to create a new class (<code class=""inline-code"">IdUtil</code>) in the same package I have to copy and paste the package name from the source class field.<br/><br/>Enter <code class=""inline-code"">org.IdUtil</code> as the target class. The class name is highlighted in red and a QuickFix &quot;bulb&quot; appears.<br/>Press Alt+Enter and select &quot;Create class <code class=""inline-code"">IdUtil</code>&quot;. Now cancel the &quot;Create Class&quot; dialog with Esc and return to &quot;Move Members&quot;.<br/>Here is another bug - there is no &quot;Create class&quot; QuickFix option anymore. Only &quot;Create enum&quot; and &quot;Create interface&quot;.<br/>&quot;Create class&quot; appears again after editing the target class name. Proceed to &quot;Create Class&quot; once more.<br/><br/>And here is the final bug. Pressing OK in &quot;Create Class&quot; dialog shows error message &quot;Destination not found for package &#39;org&#39;&quot;.<br/><br/>If I ignore the QuickFix and just press OK in the Move Members the questions appear in the wrong order.<br/>First IDEA asks about the destination directory. And then asks if I want to create the <code class=""inline-code"">IdUtil</code> class. Why would I have to select the directory if I didn&#39;t intend to create a new class in the first place?<br/>By the way, if I proceed to create the new class this way it is created successfully, no &quot;destination not found&quot; error.<br/><br/>How I would prefer it working:<br/><ul class=""wiki-list0""><li> if I only enter class name for target, without any packages - assume it&#39;s in the same package as the source class (who creates classes in default package anyway?)<br/></li><li> selecting &quot;Create class&quot; QuickFix should do just that - create the class - don&#39;t bother me with questions about the package (again!) and the source root, I&#39;ll move the class to another source root later if needed<br/></li><li> same for pressing OK in the &quot;Move Members&quot; - just ask if I want the new class created, and don&#39;t ask about target directory<br/></li></ul></div>
","0"
"IDEA-276333","IntelliJ IDEA","","Convert anonymous to inner not presented in Refactor This","momomo","18/08/2021 15:46","28/10/2022 06:05",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","See video. Stuff missing from refactor popup dialog requiring clicking instead. 

More things should be added there that is missing. Perhaps more. ","3"
"IDEA-304479","IntelliJ IDEA","","Not resolved annotation attributes usages after Refactor | Rename","Irina Petrovskaya","24/10/2022 11:55","26/10/2022 09:28",,"Major","Bug",,"Alexandr.Suhinin","Java. Refactorings","2022.3 EAP 4 (223.7126.7)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","231.272, 232.7126.7

- create some custom annotation with some members:
```java
@Retention(RUNTIME)
public @interface MyAnnotation {

    String foo();
    String bar();
}
```
- annotate some classes with this annotation.
- refactor | rename the annotation attribute:

as a result the usages are updated, but are shown in red as if they are not resolved:
![](image.png){width=50%}


Another strange effect:

- create a copy of your annotation class, say MyAnnotation2.
- change the members names in this new class (not by refactoring, but just by typing in-place - there are no usages, nothing to refactor:
look at the Project view: you can notice that the updated names are incorrect there, like 'a()' instead of 'aaa()' etc. The new-added members appear correctly.

![](image1.png){width=50%}","0"
"IDEA-265809","IntelliJ IDEA","","Move directory to other gradle subproject: ""Analyze module conflicts"" randomly hangs","Carsten  Otto","04/04/2021 07:13","09/10/2022 14:44",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**

0. Have a Gradle project with subproject `subproject-one`
1. Have package in `subproject-one/src/main/java/foo/bar`
2. Create subproject `subproject-two` with `src/main/java` sourceset
3. Move `subproject-one/src/main/java/foo/bar` directory to `subproject-two/src/main/java` (F6 on `bar`, ""Move directory /home/.../bar to another source root"")

**What is the expected result?**
Directory is moved

**What happens instead?**
Roughly ever 1/10 tries: Popup titled ""Analyze module conflicts..."" appears and does not go away.

Log contains:
`Node com.intellij.ide.util.DirectoryChooser$ItemWrapper@66cb64c4 is already added to Module`

IntelliJ IDEA 2021.1 RC (Ultimate Edition)
Build #IU-211.6693.65, built on March 31, 2021
Licensed to Carsten Otto
Subscription is active until March 15, 2022.
Runtime version: 11.0.10+9-b1341.35 amd64
VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o.
Linux 5.10.0-5-amd64
GC: G1 Young Generation, G1 Old Generation
Memory: 4096M
Cores: 16
Non-Bundled Plugins: AWSCloudFormation (211.6693.44), org.jetbrains.kotlin (211-1.4.32-release-IJ6693.72)
Kotlin: 211-1.4.32-release-IJ6693.72
Current Desktop: Undefined","2"
"IDEA-265312","IntelliJ IDEA","warm-up","'Create method' from unresolved method reference can use parameter names from interface method","Andrey Turbanov","26/03/2021 11:43","09/10/2022 14:43",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**
```
public class MethodReferenceParameters {

    public static void main(String[] args) {
        MethodReferenceParameters m = new MethodReferenceParameters();
        performJob(m::myJob);
    }

    private static void performJob(ExpirationJob job) {
    }
}


interface ExpirationJob {
    void doJob(long expirationTime, Collection<String> accounts);
}
```

Invoke quick-fix `Create method 'myJob'` on unresolved method reference.

**What is the expected result?**
IDEA creates method 'myJob' and suggests to use parameter names `expirationTime`, `accounts`. According to interface method parameters.

**What happens instead?**
IDEA suggests some generic parameter names `l` and `strings`.
![](изображение.png)","0"
"IDEA-264069","IntelliJ IDEA","","Renaming a class shouldn't affect code in auto-generated folders","Сергей Цыпанов","11/03/2021 07:30","09/10/2022 14:39",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**

1. Take any project with JMH and build it.
2. Rename a benchmark in that project

**What is the expected result?**

Only benchmark class is renamed because auto-generated code will be recompiled at next build time.

**What happens instead?**

IDEA suggests to rename autogenerated classes that are located under `/targer/generated-sources`
![](image.png)","0"
"IDEA-264011","IntelliJ IDEA","","Inspection 'Result of method call ignored' shouldn't warn on 'java.lang.Character#toChars(int, char[], int)' by default","Andrey Turbanov","10/03/2021 15:37","09/10/2022 14:38",,"Normal","Bug",,"basleijdekkers","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
    private char[] b2cSupp;

    public void decodeSurrogate(char[] cc, int i) {
        int end = b2cSupp.length / 2;
        Character.toChars(b2cSupp[end + i] + 0x20000, cc, 0);
    }
```

Run inspection `Java | Probable bugs | Result of method call ignored`

**Expected**
No warnings. Character.toChars modifies second argument - `cc` array.

**Actual**
IDEA shows warning `Result of 'Character.toChars()' is ignored `","0"
"IDEA-166420","IntelliJ IDEA","reproduced","Inlining methods of nested classes that access outer class produce wrong code","Daniel Vega","10/01/2017 17:34","07/10/2022 05:48",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When you inline a method of a nested class that access the outer instance IntelliJ IDEA generates wrong java code.<br/><br/>Example:<br/><br/><pre class=""wikicode prettyprint"">class A {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>class Nested {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>A getOuter() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return A.this;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>boolean cmpOuter(Nested n) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return getOuter().equals(n.getOuter());<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><br/>class B {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>void mm(A.Nested an) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(an.getOuter());<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre><br/>If you inline <span class=""monospace"">getOuter()</span> method, this wrong code is generated<br/><br/><pre class=""wikicode prettyprint"">class A {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>class Nested {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>boolean cmpOuter(Nested n) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return A.this.equals(A.this);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><br/>class B {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>void mm(A.Nested an) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(A.this);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre></div>
","2"
"IDEA-302391","IntelliJ IDEA","","'create local variable' for argument introduces annotations taken from method signature","Sergei Riabinin","23/09/2022 13:57","27/09/2022 05:34",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2022.2.2 (222.4167.29)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2022.3 (223.7571.182)","No zendesk mentions",,"No assigned support","Unknown","consider

```java
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import org.jetbrains.annotations.NotNull;

public class A {

    void xx(){
        yy(nonExistingVar); //caret on 'nonExistingVar'
    }

    void yy(@NotNull @Email @Size Object value){
    }
}
```

if alt+enter, 'create field':

```
private Object nonExistingVar;
```

if alt+enter, 'create local variable':

```java
    void xx(){
        @NotNull @Email @Size Object nonExistingVar;
        yy(nonExistingVar);
    }
```","1"
"IDEA-73679","IntelliJ IDEA","","Inline method and move method should give the option to move private methods with the method to be inlined/moved","Karianne Berg","29/08/2011 16:16","25/09/2022 17:29",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If I have code that looks like below and try to inline the b method:<br/><br/><pre class=""wikicode prettyprint"">public class A {<br/>  public void a() {<br/>    B b = new B();<br/>    b.foo();<br/>  }<br/>}<br/><br/>public class B {<br/>  public void b() {<br/>    bar();<br/>    baz();<br/>  }<br/><br/>  private void bar() {<br/>    ..<br/>  }<br/><br/>  private void baz() {<br/>    ..<br/>  }<br/>}</pre><br/>I would like IDEA to give me the options to move the private methods (at least if they&#39;re used only by the method that is to be inlined) with it, make the private methods public or nothing at all (as it is today). The code should then end up like this:<br/><br/><pre class=""wikicode prettyprint"">public class A {<br/>  public void a() {<br/>    B b = new B();<br/>    b.bar();<br/>    b.baz();<br/>  }<br/><br/>  private void bar() {<br/>    ..<br/>  }<br/><br/>  private void baz() {<br/>    ..<br/>  }<br/>}<br/><br/>public class B {<br/>  <br/>}</pre><br/>I would like a similar thing to happen when a move method refactoring is done on a method that is the single invoker of one or more private methods.</div>
","1"
"IDEA-122752","IntelliJ IDEA","reply needed,reproduced","Introduce variable behaviour changes if there is no semicolon at the end of the line","Chris Kent","24/03/2014 06:49","21/09/2022 08:22",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"To be discussed","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Put the caret on &quot;bar&quot; and invoke introduce variable. IDEA suggests introducing a variable for the string &quot;bar&quot; which is the expected behaviour.<br/><br/>Delete the semicolon from the end of the line and repeat. IDEA suggests introducing a variable for the whole line which is a) inconsistent and b) not what you&#39;d expected. It should suggest the most specific object first.<br/><br/>I think this is a regression, I&#39;m sure it used to work the way I expect.<br/><br/><pre class=""wikicode prettyprint"">class Foo {<br/><br/>  void foo() {<br/>    new StringBuilder(new String(&quot;bar&quot;));<br/>  }<br/>}</pre></div>
","0"
"IDEA-166472","IntelliJ IDEA","","Refactor rename and home/end","Brice Broquere","11/01/2017 13:50","20/09/2022 11:50",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","2022.2 (222.3345.118)","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Sometimes, but regularly, when home/end is pressed just after refactor/rename the caret can be moved at the beggining/end of the line instead of the identifier.</div>
","1"
"IDEA-223920","IntelliJ IDEA","","Make method static breaks usages from Kotlin","Tagir Valeev","01/10/2019 06:22","15/09/2022 03:49",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Java:
```java
public class TestJava {
    void foo(String arg) {
        System.out.println(arg);
    }
}
```

Kotlin:
```java
fun main() {
    val x = TestJava()
    x.foo(""Hello World"");
}
```

There's a warning in Java code: ""Method 'foo()' may be 'static'"". If I apply the fix, it doesn't update the call-site from the Kotlin silently breaking the compilation. It should either update it or at least show a warning that compilation could be broken due to the references from non-Java code (probably showing a standard ""Conflicts"" view).

The explicit ""Make static"" refactoring behaves in the same way.","1"
"IDEA-297282","IntelliJ IDEA","","Extract delegate as enum breaks code","Jino Bettinelli","03/07/2022 15:56","14/09/2022 09:56",,"Normal","Bug",,"anet","Java. Refactorings","2022.1.3 (221.5921.22)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2022.2 (222.3345.118)","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Consider the codebase below:

```
public class Game {
    public static final String SCIENCE = ""Science"";
    public static final String SPORTS = ""Sports"";

    public void askQuestion(int position) {
        System.out.println(""Current category is "" + getCategory(position));
        if (getCategory(position).equals(SCIENCE))
            System.out.println(""Asking a science question..."");
        if (getCategory(position).equals(SPORTS))
            System.out.println(""Asking a sports question..."");
    }

    private String getCategory(int position) {
        if (position % 2 == 0) return SCIENCE;
        return SPORTS;
    }
}
```


2\. Use the Refactor -\> extract delegate functionality to create the Category enum, check the ""extract as enum"" option, and select both string constants

![](image.png)
***What is the expected result?***

First of all, when using refactoring functionalities, I'd expect the code to work similarly as before the refactoring.

For this one, I'd expect a new enum to be created, and the occurences of the SPORTS and SCIENCE constants to be replaced by the enum value. 

Something like: 

```
public class Game {
    public void askQuestion(int position) {
        System.out.println(""Current category is "" + getCategory(position));
        if (getCategory(position).equals(Category.SCIENCE.getValue()))
            System.out.println(""Asking a science question..."");
        if (getCategory(position).equals(Category.SPORTS.getValue()))
            System.out.println(""Asking a sports question..."");
    }

    private String getCategory(int position) {
        if (position % 2 == 0) return Category.SCIENCE.getValue();
        return Category.SPORTS.getValue();
    }
}
```

Intellij seems to go one step further (which is great) and it sees that the getCategory always returns a Category, so its return type is set to Category... by doing that the expected result would be either: 

```
public class Game {
    public void askQuestion(int position) {
        System.out.println(""Current category is "" + getCategory(position).getValue());
        if (getCategory(position).getValue().equals(Category.SCIENCE.getValue()))
            System.out.println(""Asking a science question..."");
        if (getCategory(position).getValue().equals(Category.SPORTS.getValue()))
            System.out.println(""Asking a sports question..."");
    }

    private Category getCategory(int position) {
        if (position % 2 == 0) return Category.SCIENCE;
        return Category.SPORTS;
    }
}
```

or even better:

```
public class Game {
    public void askQuestion(int position) {
        System.out.println(""Current category is "" + getCategory(position).getValue());
        if (getCategory(position).equals(Category.SCIENCE))
            System.out.println(""Asking a science question..."");
        if (getCategory(position).equals(Category.SPORTS))
            System.out.println(""Asking a sports question..."");
    }

    private Category getCategory(int position) {
        if (position % 2 == 0) return Category.SCIENCE;
        return Category.SPORTS;
    }
}
```

***What happens instead?***

See the comments below to see where the problem happens:

```
public class Game {

    public void askQuestion(int position) {
        System.out.println(""Current category is "" + getCategory(position)); // The getValue() method is not called, so we get the name of the constant instead of its value 
        if (getCategory(position).equals(Category.SCIENCE.getValue())) // The getCategory() method returns a Category, but is compared to a String since the right half of the equals stayed a String
            System.out.println(""Asking a science question..."");
        if (getCategory(position).equals(Category.SPORTS.getValue()))
            System.out.println(""Asking a sports question..."");
    }

    private Category getCategory(int position) {
        if (position % 2 == 0) return Category.SCIENCE;
        if (position % 2 == 1) return Category.SPORTS;
        throw new RuntimeException();
    }
}
```


","0"
"IDEA-296311","IntelliJ IDEA","","Inline method generates wrong code for inner class reference","Andrey Turbanov","18/06/2022 16:21","14/09/2022 09:38",,"Normal","Bug",,"anet","Java. Refactorings","2022.2 (222.3345.118)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
package org.some;

public class PatternInner<T> {

    class Basis {
        String key;

        private PatternInner<T> outer() {
            return PatternInner.this;
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof @SuppressWarnings(""rawtypes"")PatternInner.Basis that)) {
                return false;
            }
            return this.outer() == that.outer() && this.key.equals(that.key);
        }
    }
}
```

Try to inline `outer()` method

**Actual**
IDEA silently changes semantic of the code
```
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof @SuppressWarnings(""rawtypes"")PatternInner.Basis that)) {
                return false;
            }
            return PatternInner.this == PatternInner.this && this.key.equals(that.key);
        }
```

**Expected**
IDEA shows warnings/refuses to inline `outer()` method for cases when it's not _this_ reference.","0"
"IDEA-295366","IntelliJ IDEA","","""Extract parameter"" refactoring does not honor ""Preselect current symbol for Rename refactoring"" setting","Dmitry Cherniachenko","03/06/2022 09:55","14/09/2022 09:29",,"Normal","Usability Problem",,"anet","Java. Refactorings","2022.2 (222.3345.118)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I have this setting disabled. But whenever I extract a parameter the suggested name is pre-selected:
![](image.png)
(I have no idea what the ""Delegate"" hint is trying to say here.)

On top of that it seems that some old offsets are still being used. So when I press Right once to remove the selection the caret is moved 5 characters to the right:
![](image1.png)","0"
"IDEA-287118","IntelliJ IDEA","","Suggest change signature refactoring when call site is edited","Tagir Valeev","21/01/2022 07:34","13/09/2022 15:51",,"Normal","Feature",,"Tagir.Valeev","Java. Refactorings","2022.1 (221.5080.210)",,"Submitted","2022.1","No tester","No","No","Not specified","221.3925","Not specified","No zendesk mentions",,"No assigned support","Unknown","We have suggested refactoring when the method signature is edited. However, often it's more natural to edit one of the call sites. In this case, if would be user-friendly to suggest a declaration signature change:

E.g., start with this code:

```java
public class Sample {
    void method(int a, int b) {
        System.out.println(a+b);
    }

    void call() {
        method(1, 2);
        
        
        method(3, 4);
    }
}
```

Add a parameter to the call site:

![](image.png)

Invoke ""Update declaration"":

![](image1.png)

Agree on suggested update:

![](image2.png)

Type name and default value for new parameter:

![](image3.png)

And get the updated signature and all the call sites:

```java
public class Sample {

    void method(int a, int xyz, int b) {
        System.out.println(a+b);
    }

    void call() {
        method(1, 566, 2);


        method(3, 566, 4);
    }
}
```","0"
"IDEA-293329","IntelliJ IDEA","","coalesce local variable assignment in specific order","KisaragiEffective","30/04/2022 09:17","13/09/2022 06:04",,"Normal","Feature",,"Tagir.Valeev","Java. Refactorings","2021.3.3 (213.7172.25)",,"Shelved","Not specified","No tester","No","Reproduced","Not specified","Not specified","2022.2 (222.3345.118)","No zendesk mentions",,"No assigned support","Unknown","***What behavior would you like to see in the IDE?***
assuming this code:
```java
// String s = ...
String path = s;
// continuous line
path = ModLib.correctFileSeparator(path);
```

In this code, there's no another assignment between first one and second one, so above code is equivalent with following snippet:

```java
// String s = ...
String path = ModLib.correctFileSeparator(s);
```

***In what scenarios would you like to use this feature?***
I think it is useful when working with decompiled code.

***What steps do you currently take to achieve your desired outcome?***
I inlined such sequences manually.
","0"
"IDEA-291559","IntelliJ IDEA","","Extract Delegate refactoring incorrectly forces creation of getters","Joshua Kerievsky","05/04/2022 13:10","13/09/2022 06:01",,"Normal","Bug",,"anet","Java. Refactorings","2021.3.3 (213.7172.25)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","2022.1 (221.5080.210)","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Create a class with package-protected fields and some methods that use those fields.
2\. Perform the Extract Delegate refactoring on the methods - do *not* check the Generate Getters checkbox
3\. The newly extracted Delegate class insists on using getters to the fields, even though package protection access to the fields means no getters are required
***What is the expected result?***

The methods in the extracted Delegate class should directly access the package-protected fields from the host class

***What happens instead?***

IntelliJ forces the creation of the getters. ","0"
"IDEA-283235","IntelliJ IDEA","","'Cancel' should be at left in move directory dialog","Timur Yuldashev","24/11/2021 10:02","12/09/2022 12:48",,"Normal","Cosmetics",,"lobas","Java. Refactorings","2022.1 (221.5080.210)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-221.1576

**IDE** - `Cancel` in the middle
![](image.png)

**Figma**
![](image2.png)
","0"
"IDEA-288825","IntelliJ IDEA","","'Infer Nullity' should allow to exclude fields","Andrey Turbanov","15/02/2022 10:10","12/09/2022 12:42",,"Normal","Feature",,"anet","Java. Refactorings","2022.1 (221.5080.210)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I want to use 'Code -> Analyze Code -> Infer nullity' to batch add `@Nonnull` annotations to my project (see IDEA-287718).
I tried to use it, but it also adds annotation to fields. Not only to methods/parameters.
We rarely add nullity annotations to fields. I would like to have an option to disable it. For example it could be a checkbox, as it's done with locals.
![](изображение.png)","0"
"IDEA-290936","IntelliJ IDEA","","Pull up javadoc","tr","23/03/2022 17:21","09/09/2022 13:24",,"Normal","Feature",,"anet","Java. Refactorings","2022.1 (221.5080.210)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***feature request. Wrote javadoc  on a class which is an implementation of an interface . Would like the Javadoc to actually be attending to the interface. Wrote it on class because that's where things became clear enough to write javadoc. That is often the case.  It properly belongs  on the interface so that  CTRL+Q  would  work on the interface method and not just the implementation (class) method. Sure I can move it manually, but it's a PITA and seems like a natural assist to me.*** 



Thanks. ","0"
"IDEA-290507","IntelliJ IDEA","","""Inline method"" should use method reference if possible","Carsten  Otto","15/03/2022 09:12","09/09/2022 13:22",,"Normal","Usability Problem",,"anet","Java. Refactorings","2022.1 (221.5080.210)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
```
public class Something {
    public Object foo() {
        return bar();
    }

    public Object bar() {
        return """";
    }

    public static void main(String[] args) {
        Something something = new Something();
        Stream.of(something).map(Something::foo).forEach(System.err::println);
    }
}
```
Inline method ""foo"".
***What is the expected result?***
`Stream.of(something).map(Something::bar).forEach(System.err::println);`

***What happens instead?***
`Stream.of(something).map(something1 -> something1.bar()).forEach(System.err::println);` (with a warning that this can be simplified with a lambda expression)

Note that this also when, for example, manually converting classes to records (by delegating to the implicit getter from the old getter, then inlining the old getter).

This seems to be a regression of IDEA-148481.","0"
"IDEA-288664","IntelliJ IDEA","","`Infer Nullity` should allow to skip modules which don't have dependency on findbugs annotations","Andrey Turbanov","13/02/2022 17:54","09/09/2022 12:27",,"Normal","Usability Problem",,"anet","Java. Refactorings","2022.1 (221.5080.210)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1. Open some multi-module maven project. Project is configured to use findbugs annotation `@Nonnull` as nonnull
2. Code -> Analyze Code -> Infer Nullity...
3. Select `Project Production Files` as scope
![](изображение.png)
4. Click `Analyze`

***What is the expected result?***
IDEA is smart enough to skip modules which don't depend on findbugs jar.
Perhaps show some warning.

***What happens instead?***
IDEA offers only 2 possible solutions: add dependency or `Cancel` whole analyzis
![](изображение1.png)","0"
"IDEA-258139","IntelliJ IDEA","","'Move Method' incorrectly updates static imports","Andrey Turbanov","18/12/2020 09:03","06/09/2022 14:54",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
package org.come.movestatic;

public class OriginalWithStatic {
    public static void <caret>perform(String a) {
    }

    public static void perform(String a, boolean b) {
    }
}
```

```
package org.come.movestatic;

public class StaticDestination {
}
```

```
package org.come.movestatic;

import static org.come.movestatic.OriginalWithStatic.perform;

public class StaticUsage {
    public static void main(String[] args) {
        perform(""123"", true);
    }
}
```

Move static method `org.come.movestatic.OriginalWithStatic#perform(java.lang.String)` to class `StaticDestination`

**Expected**
No code changes in `StaticUsage` class

**Actual**
IDEA updates static import incorrectly which leads to uncompilable code:
```
package org.come.movestatic;

import static org.come.movestatic.StaticDestination.perform;

public class StaticUsage {
    public static void main(String[] args) {
        perform(""123"", true);
    }
}
```","0"
"IDEA-253182","IntelliJ IDEA","","All occurrences of object reference variable are within unnecessary parentheses after extraction of a common expression result to it","Petar Šestak","17/10/2020 07:11","06/09/2022 13:41",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
Let's say we have typed the following code so far:
```
    public static void main(String[] args)
    {
        Object a = ""str1"";
        /*

            some code

        */
        String c = ((String) a).concat(""str2"");
        String d = ((String) a).concat(""str3"");
    }
```
At that moment we realize that we are casting the same object reference variable with the identifier *a* to a String, so we decide to assign the result of a common expression to the new variable. So to achieve that, we write `(String) a;` in some line before other lines which contain that same expression, and after that we hit Alt + Enter to open *Show Context Actions* menu. If we then select *Introduce local variable* option, IntelliJ will notify us that the multiple occurrences of that expression were found and they all could be replaced with the reference of a newly-created variable. In case we navigate to the *Replace all 3 occurrences* option, common expressions which can be replaced are highlighted - even with the parentheses around them as they would no longer be required. Image shown below:
![](image.png)
Finally, we select that option in order to apply suggested *refactoring*.

***What is the expected result?***
Highlighted code of all occurrences is replaced with the identifier of the newly-created variable (except of the first one which is replaced with that variable initialization). Therefore, extra unnecessary parentheses are removed.
```
    public static void main(String[] args)
    {
        Object a = ""str1"";
        String a1 = (String) a;
        /*

            some code

        */
        String c = a1.concat(""str2"");
        String d = a1.concat(""str3"");
    }
```

***What happens instead?***
Extra unnecessary parentheses remain around object reference variables, even though from the preview we would expect them to be removed.
```
    public static void main(String[] args)
    {
        Object a = ""str1"";
        String a1 = (String) a;
        /*

            some code

        */
        String c = (a1).concat(""str2"");
        String d = (a1).concat(""str3"");
    }
```","0"
"IDEA-252968","IntelliJ IDEA","","Update implementations to reflect signature changes for array argument","Sergey Chernov","15/10/2020 05:50","05/09/2022 16:33",,"Normal","Bug",,"anet","Java. Refactorings","2020.2.3 (202.7660.26)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.3 (203.5981.155)","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Define interface and impl like this:
```java
interface Base {
    String apply(String[] args);
}

class Impl implements Base {
    @Override
    public String apply(String[] args) {
        return args == null ? null : Arrays.toString(args);
    }
}
```
2. Change signature of `Base.apply` - add `@org.jetbrains.annotations.Nullable` annotation for argument:
```java
interface Base {
    String apply(@Nullable String[] args);
}
```
3. IDEA suggests to update implementation to reflect signature changes (the ""R"" button on left border), the preview of changes looks correct
4. Follow advice - click ""Update""

What is the expected result?
Correct signatures on the class

What happens instead?
New Code looks like:
```java
class Impl implements Base {
    @Override
    public String apply(@Nullable String @Nullable [] args) {
        return args == null ? null : Arrays.toString(args);
    }
}
```

Please attach idea.log (go to Help | Show Log in ... to discover it easily). You can use 'Attach File Privately' item to make attachments visible to 'jetbrains-team' group only. If you don't want to share IDE logs even with JetBrains team please at least paste information about IDE build and your environment below (it can be copied from Help | About dialog).

Consider attaching a screenshot, screencast, or a code sample when it's hard to articulate the problem. Note that you can easily drag & drop files of any type into the issue.

If you are experiencing performance issues, please also [attach the snapshots](https://intellij-support.jetbrains.com/hc/en-us/articles/207241235).","0"
"IDEA-250195","IntelliJ IDEA","","""Add type annotation"" refactoring adds an excessive annotation on derived methods","Vladimir Sitnikov","05/09/2020 16:52","05/09/2022 13:56",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.2.2 (202.7319.50)","No zendesk mentions",,"No assigned support","Unknown","1. Prerequisites:

```java
interface Base {
  void varargsMethod(Object[][][] args);
}

interface Derived extends Base {
  void varargsMethod(Object[][][] args);
}
```

2. Add `@Nullable` annotation to `Object`:

```java
import org.checkerframework.checker.nullness.qual.Nullable;

interface Base {
  void varargsMethod(@Nullable Object[][][] args);
}
```

3. Click ""refactor""
![](add_nullable_annotation.png)

4. Click ""Update""

5. Actual result:

```java
interface Derived extends Base {
  void varargsMethod(@Nullable Object[][] @Nullable [] args);
}
```

What is the expected result?

```java
interface Derived extends Base {
  void varargsMethod(@Nullable Object[][][] args);
}
```

The same issue happens with varargs.

Actual value (invalid):

```java
interface Derived extends Base {
  void varargsMethod(@Nullable Object @Nullable ... args);
}
```","0"
"IDEA-249141","IntelliJ IDEA","","Inline Rename Parameter refactoring grayed out if unused method parameters are renamed though used in body","Jörg Thönnes","26/08/2020 11:03","05/09/2022 13:52",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.3 (203.5981.155)","No zendesk mentions",,"No assigned support","Unknown","# What steps will reproduce the issue?
1. Create class with methods, fields etc.
2. Create unused method with parameter used in the method body.
3. Rename the parameter inline.

# What is the expected result?
Inline rename refactoring is offered. Pressing the blue button renames the parameter both in the signature and in the body.

# What happens instead?
Inline rename button is grayed out. Hover ""There are changes in signature but nothing can be updated in usages"" is obviously wrong since there are local parameter usages in the method body.

```
   private void someMethod( final String parameter )
   {
      System.out.println( parameter );
   }
```

Normal Rename Parameter refactoring works.

# Version
IntelliJ IDEA 2020.2.1 (Community Edition)
Build #IC-202.6948.69, built on August 24, 2020
Runtime version: 11.0.8+10-b944.31 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
Linux 4.19.0-10-amd64
GC: ParNew, ConcurrentMarkSweep
Memory: 4029M
Cores: 8
Registry: debugger.watches.in.variables=false, ide.tooltip.initialDelay=604
Non-Bundled Plugins: Key Promoter X, com.genuitec.codetogether, com.intellij.ideolog, DBN, FitNesse, GrepConsole, String Manipulation, com.dubreuia, com.yiycf.plugins.mavenDependencyHelper, org.jetbrains.jumpToLine, indent-rainbow.indent-rainbow, krasa.CpuUsageIndicator, net.seesharpsoft.intellij.plugins.csv, org.jetbrains.plugins.hocon, me.artspb.hackathon.git.bisect.run, org.sonarlint.idea, pw.unbear.ijplug, MavenRunHelper, org.intellij.scala, org.jetbrains.kotlin, com.jetbrains.packagesearch.intellij-plugin, PythonCore, com.jetbrains.edu, training
Current Desktop: XFCE","0"
"IDEA-248587","IntelliJ IDEA","","'Inline Super Class' adds incorrect qualifier to nested enum","Andrey Turbanov","20/08/2020 04:02","05/09/2022 13:35",,"Normal","Bug",,"anet","Java. Refactorings","2020.2.1 (202.6948.69)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.3 (203.5981.155)","No zendesk mentions",,"No assigned support","Unknown","```
package org.ll;

public class PropertyRef {
    public PropertyRef(String group) {
        PropertyGroup p = PropertyGroup.valueOf(group);
    }

    public enum PropertyGroup {
        SIMPLE, COMPLEX
    }
}

class FixPropertyRef extends PropertyRef {
    public FixPropertyRef() {
        super(""SIMPLE"");
    }
}
```
Try to inline super class `PropertyRef`

**Expected**
```
class FixPropertyRef {
    public FixPropertyRef() {
        PropertyGroup p = PropertyGroup.valueOf(""SIMPLE"");
    }

    public enum PropertyGroup {
        SIMPLE, COMPLEX
    }
}
```

**Actual**
Uncompilable code
```
class FixPropertyRef {
    public FixPropertyRef() {
        PropertyGroup p = PropertyRef.PropertyGroup.valueOf(""SIMPLE"");
    }

    public enum PropertyGroup {
        SIMPLE, COMPLEX
    }
}
```","0"
"IDEA-248105","IntelliJ IDEA","","Inline rename blocks UI analyzing non-code usages","Jörg Thönnes","12/08/2020 14:14","05/09/2022 13:04",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","2021.1","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","# What steps will reproduce the issue?
1. Inline rename of private member field of a class with a getter and field assignment by constructor parameter.
2. Click on blue rename button on the left.
3. Click ""rename""

# What is the expected result?

Renaming starts and completes in reasonable time.

# What happens instead?

Modal dialog ""Searching for Variables"" with ""Analyzing non-code usages..."" blocks whole UI. Have to kill the Java process.","0"
"IDEA-243062","IntelliJ IDEA","","Support inline method parameter for vararg","Andrey Turbanov","10/06/2020 09:14","01/09/2022 12:43",,"Normal","Feature",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
public enum InlineVararg {
    A, B;
    
    private static void toInline(InlineVararg... args<caret>) {
        System.out.println(Arrays.asList(args));
    }
    
    public static void call() {
        toInline(InlineVararg.values());
    }
}
```

It would be nice if IDEA was able to inline vararg parameters for some simple cases. For example if method called only in one place.
Now IDEA show error that such inline is not supported.
![](изображение.png)","0"
"IDEA-300763","IntelliJ IDEA","","Refactoring error when viewing older version of a file","Daniel Chýlek","26/08/2022 14:29","29/08/2022 13:14",,"Normal","Bug",,"anet","Java. Refactorings","2022.2.1 (222.3739.54)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***

1. Create a Java project with Git
2. Commit these two files:

**TestA.java**

```java
public class TestA {
	
	public void main() {
		TestB b = new TestB();
	}
}
```

**TestB.java**

```java
public class TestB {}
```

3. Open Git Log and use ""Show Repository at Revision"" for the commit that added these 2 files
   * You can create some more commits to simulate showing an actually older revision, but it doesn't matter.
4. Open **TestA.java** in two editor tabs
   * One from the ""Project"" tool window
   * One from the ""Revision"" tool window
5. Use ""Split and Move Right"" on the tab from Revision
6. In the tab from Project, delete the line that instantiates `TestB`
7. Delete **TestB.java** from the project

***What is the expected result?***
Delete `TestB` since there are no more usages in the actual project.

***What happens instead?***
A dialog appears that there are still usages. If I confirm it I get an error:

![](image.png){width=70%}

If I omit step 6 and keep the **TestA.java** in a tab that's not visible on the screen, then the refactoring opens the Find tool window, and clicking ""Do Refactor"" does nothing:

![](image1.png){width=70%}","0"
"IDEA-300134","IntelliJ IDEA","","""Introduce Field"" in an interface should probably be disabled","Bas Leijdekkers","17/08/2022 09:59","23/08/2022 04:43",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Example:
```java
interface Date {

  default int getMonth() {
    int result = 0;
    return result;
  }
}
```
It's possible to invoke ""Introduce field"" on the `result` variable. A private field is then generated, which naturally does not compile. It gets worse when the initialization is put in the current method or the constructor by the refactoring. 

Trying to introduce a field for the `0` literal is not allowed as expected. However, a constant is a kind of field. Thus, it may be more user-friendly to delegate ""Introduce Field"" to ""Introduce Constant"" when inside an interface.","0"
"IDEA-90739","IntelliJ IDEA","","Uncompilable code: Extract to Class on static methods using default of escalate","Rob Leland","28/08/2012 17:28","18/08/2022 09:34",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2022.2.1 (222.3739.54)",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am seeing four problems with refactoring which breaks code(see attached project).<br/>data.Issue #1 reference ExtractClassTest.java<br/>  1) Extract to Class for static methods using escalate leaves the original class uncompilable because the scope of methods remained private. If one line of code is commented out this works, see ExtractClassWorksTest.java<br/><br/><br/>  2)  Inlining a single factory method createString() causes a Class name collision and uncompilable code.Again see ExtractClassTest.java<br/>  <pre class=""wikicode prettyprint"">        gov.niem.proxy.v20.String npStatus = npObjectFactory.createString();</pre><br/>results in<br/><pre class=""wikicode prettyprint"">        gov.niem.proxy.v20.String npStatus = new String();</pre>and adds an import for &#39;gov.niem.proxy.v20.String&#39;. This collides with java.lang.String which is in method signatures. <br/><br/>The correct result should be <br/><pre class=""wikicode prettyprint"">        gov.niem.proxy.v20.String npStatus = new gov.niem.proxy.v20.String();</pre>with no import added.</div>
","0"
"IDEA-298985","IntelliJ IDEA","","""Move class"" for non static inner class with generic usage does not change the class signature and ends in a red code","momomo","30/07/2022 16:07","16/08/2022 11:20",,"Normal","Bug",,"bart.vanhelvert","Java. Refactorings","2022.1.4 (221.6008.13), 2022.2 (222.3345.118)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
public class ClassOuter<THIS extends ClassOuter<THIS>> {
    protected final THIS THIS() {
        return (THIS) this;
    }

    {
        new ClassNested(THIS());
    }
    public final class ClassNested {
        private final THIS outer;

        public ClassNested(THIS outer) {
            this.outer = outer;
        }
    }
}
```

Move ClassNested to the upper level:
![](Screenshot 2022-08-04 at 11.58.09.png){width=70%}

**Result:**
![](Screenshot 2022-08-04 at 11.56.58.png){width=70%}

**Expected:**

```
public final class ClassNested<THIS extends ClassOuter<THIS>> {
    private final ClassOuter superOuter;
    private final THIS outer;

    public ClassNested(ClassOuter superOuter, THIS outer) {
        this.superOuter = superOuter;
        this.outer = outer;
    }
}
```

Note: if refactor ClassNested to static (with ""replace instance qualifiers"" as yes) using the original sample code above, result the signature is correct:

Moving the refactored static class to the upper level doesn't cause issues.

![](Screen Recording 2022-07-30 at 20.58.55.mov.compressed.1.mp4)


","0"
"IDEA-299295","IntelliJ IDEA","","""Make static"" introduces a warning for a generic class","Sergei Riabinin","04/08/2022 08:22","11/08/2022 04:53",,"Normal","Bug",,"bart.vanhelvert","Java. Refactorings","2022.1.4 (221.6008.13), 2022.2 (222.3345.118)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
public class ClassOuter<THIS extends ClassOuter<THIS>> {
    protected final THIS THIS() {
        return (THIS) this;
    }

    {
        new ClassNested(THIS());
    }
    
    public final class ClassNested {
        private final THIS outer;

        public ClassNested(THIS outer) {
            this.outer = outer;
        }
    }
}
```



refactor ClassNested to static (with ""replace instance qualifiers"" as yes), as a result the usage is not adjusted and gives the warning:


![](Screenshot 2022-08-04 at 12.02.01.png){width=70%}



Expected:

```java
    {
        new ClassNested<>(THIS());
    }
```","0"
"IDEA-299319","IntelliJ IDEA","","In-place refactoring options popup not activated with default shortcut","momomo","04/08/2022 10:28","08/08/2022 11:14",,"Normal","Bug",,"anet","Java. Refactorings","2022.2 (222.3345.118)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","![](image.png)



Option L does not work, and neither does any other shortcut I might assign to it: 



![](image1.png){width=70%}



What is going on? This was destroyed 1.5 years ago. 



Still not a fix?","0"
"IDEA-298834","IntelliJ IDEA","","'Infer Nullity...' doesn't allow any modules to miss nullability library dependency","Andrey Turbanov","28/07/2022 09:44","02/08/2022 06:25",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2022.2 (222.3345.118)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1. Open attached project
2. Code -> Analyze Code -> Infer Nullity...
3. Select 'Whole project' and click Analyze
***What is the expected result?***
IDEA notifies me that some of modules don't have dependency on jsr305 library. And continues to analyze all other modules

***What happens instead?***
There are only 2 buttons: add dependency or cancel whole session.
![](изображение.png)","0"
"IDEA-241036","IntelliJ IDEA","","'Inline super class' called on interface should make nested classes static","Andrey Turbanov","16/05/2020 13:13","27/07/2022 14:00",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.1.2 (201.7846.76)","No zendesk mentions",,"No assigned support","Unknown","```
package some.sec6;

public interface IMessage {
    class Topic {
        public static String of() { return """"; }
    }
}

class Message implements IMessage {
}
```

Try to inline `IMessage` interface

**Expected**
```
class Message {
    public static class Topic {
        public static String of() { return """"; }
    }
}
```


**Actual**
Uncompilable code
```
class Message {
    public class Topic {
        public static String of() { return """"; }
    }
}
```","0"
"IDEA-241056","IntelliJ IDEA","","'Inline parameter' in static method which refer to field should remove 'static' modifier","Andrey Turbanov","17/05/2020 08:20","27/07/2022 13:59",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2020.1.2 (201.7846.76)","No zendesk mentions",,"No assigned support","Unknown","```
public class InlineParameterInStaticMethod {
    private final int myVal;

    public InlineParameterInStaticMethod(int myVal) {
        this.myVal = myVal;
    }

    public void doWork() {
        call2(myVal);
    }

    private static int call2(int myVal) {
        int q = myVal / 2;
        System.out.println(""q = "" + q);
        int b = myVal / 3;
        System.out.println(""b = "" + b);
        return q;
    }
}
```

Try to inline parameter `myVal` in `call2` method

**Expected**
It would be nice if IDEA is able to remove `static` modifier from method to produce compilable code
```
    private int call2() {
        int q = myVal / 2;
        System.out.println(""q = "" + q);
        int b = myVal / 3;
        System.out.println(""b = "" + b);
        return q;
    }
```

**Actual**
Uncompilable code
```
    private static int call2() {
        int q = this.myVal / 2;
        System.out.println(""q = "" + q);
        int b = this.myVal / 3;
        System.out.println(""b = "" + b);
        return q;
    }
```","0"
"IDEA-232943","IntelliJ IDEA","","Change Signature doesn't give feedback when no 'any' variable is found","Sebastian Aigner","13/02/2020 14:33","27/07/2022 13:32",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Expected**: There is some kind of warning/feedback when there exists a callsite where no variable can be picked by the 'any variable' setting. (Note that it's also not possible to choose a ""fallback"" value.) Especially across multiple files, this is kind of uncomfortable from a user's perspective.

![](nofeedback.gif)","0"
"IDEA-232939","IntelliJ IDEA","","""Create parameter"" quickfix to use new inplace change signature UI","Sebastian Aigner","13/02/2020 14:04","27/07/2022 13:31",,"Normal","Feature",,"valentin","Java. Refactorings","2020.1 (201.6668.121)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Expected: new UI for ""Change Signature"", including ""Add values for new parameters"" pop-up to update callsites.

![](wrong-ui.gif)","0"
"IDEA-232173","IntelliJ IDEA","","Confusing warning when I inline parameter","Andrey Turbanov","04/02/2020 14:21","27/07/2022 11:51",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.3.3 (193.6494.35)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","2020.1 (201.6668.121)","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class TryInline {<br/>    private final StringBuilder field;<br/><br/>    private TryInline(StringBuilder field) {<br/>        this.field = field;<br/>    }<br/><br/>    public static TryInline create(StringBuilder param&lt;caret&gt;) {<br/>        return new TryInline(param);<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        create(new StringBuilder());<br/>    }<br/>}</pre><br/>Try to inline <code class=""inline-code"">param</code><br/><br/><strong>Expected</strong><br/>Inline without any warnings<br/><br/><strong>Actual</strong><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>I re-read this problem description 3 times, but still doesn&#39;t understand what does it means.</div>
","0"
"IDEA-231969","IntelliJ IDEA","javadoc","'Pull `@Override` method to' should move javadoc","Andrey Turbanov","31/01/2020 14:21","27/07/2022 11:02",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.3.3 (193.6494.35)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public abstract class AbstractClass {<br/>}<br/><br/>class ClassImpl extends AbstractClass {<br/>    /**<br/>     * Do something useful<br/>     *<br/>     * @return work result<br/>     */<br/>    @Override<br/>    public int run() {<br/>        System.out.println(&quot;1&quot;);<br/>        return 2;<br/>    }<br/>}</pre><br/>Invoke <code class=""inline-code"">Pull method &#39;run&#39; to &#39;AbstractClass&#39;</code><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">public abstract class AbstractClass {<br/>    /**<br/>     * Do something useful<br/>     *<br/>     * @return work result<br/>     */<br/>    public abstract int run();<br/>}</pre><br/><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">public abstract class AbstractClass {<br/>    public abstract int run();<br/>}</pre></div>
","0"
"IDEA-231547","IntelliJ IDEA","","Type migration preview broken","Chris","27/01/2020 13:04","27/07/2022 09:52",,"Normal","Bug",,"anet","Java. Refactorings","2019.3.2 (193.6015.39)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Type migration preview needs a progress spinner and should disable the ""Migrate"" button while calculations are in progress.

My type migration preview showed me three things that would be changed by the migration. I disabled two of them (hit delete on them), only a constructor was still listed, no further child nodes.

I went ahead and hit migrate, IJ changed upwards of 200 files!
That ctor is used in one or two files. I turns out IJ changed children of one of the disabled nodes because it wasn't done calulating all these usages yet and didn't ""delete"" them, because they were probably computed after I hit delete.","1"
"IDEA-90607","IntelliJ IDEA","","I would like to be able to move class and all of it's dependency to the other source root","Danila Galimov","25/08/2012 08:25","25/07/2022 10:38",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I&#39;m trying to move the class, which have a dependency for another class, to another source root, warning window appears (see attach). However, it only allows you to go further or cancel the action. I would like to have an option like &quot;move this class(es) as well&quot;, so I can refactor the bunch of classes by 1 operation instead of moving all of the dependent classes manually.</div>
","1"
"IDEA-228673","IntelliJ IDEA","","F6: Extract nested/inner class does not correctly format default file header","Kevin Connor Arpe","07/12/2019 13:32","21/07/2022 14:43",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.3.1 (193.5662.53)","No zendesk mentions",,"No assigned support","Unknown","Related: https://youtrack.jetbrains.com/issue/IDEA-228674

When I extract a Java class to separate file, the default file header is missing trailing newline.

Original class as inner / nested:
![](image2.png)

After extract to separate file: (notice the newline after */ is missing.
![](image1.png)

My config: (not clear from screenshot, but it definitely has a trailing newline)
![](image.png)

I have seen this issue on both Linux (home) and Windows (office) for a long time.  Apologies I wait so long to raise an issue!
Of course, this is a very minor, low priority issue.  :-)

~~~~~~~~~~~~~~~~~~~~~~

IntelliJ IDEA 2019.3.1 Preview (Community Edition)
Build #IC-193.5662.14, built on December 5, 2019
Runtime version: 11.0.5+10-b520.17 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Linux 5.3.0-2-amd64
GC: ParNew, ConcurrentMarkSweep
Memory: 1956M
Cores: 4
Registry: ide.tooltip.initialDelay=0
Non-Bundled Plugins:","0"
"IDEA-227738","IntelliJ IDEA","","JUnit. Extract field with initialization in 'setUp' method should assign field before field usages in 'setUp' method","Andrey Turbanov","27/11/2019 09:06","21/07/2022 14:24",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">import org.junit.Before;<br/>import org.junit.Test;<br/><br/>import java.math.BigDecimal;<br/><br/>import static org.junit.Assert.assertEquals;<br/>import static org.junit.Assert.assertNotNull;<br/><br/>public class MultiGetterCallTest {<br/><br/>    @Before<br/>    public void setUp() {<br/>        Integer bigDecimal = get();<br/>        System.out.println(bigDecimal.intValue());<br/>    }<br/><br/>    @Test<br/>    public void testCall1() {<br/>        Integer big = get();<br/>        assertNotNull(big);<br/>    }<br/><br/>    @Test<br/>    public void testCall2() {<br/>        Integer val = get();<br/>        assertEquals(3, val.intValue());<br/>    }<br/><br/>    private static Integer get() {<br/>        String property = System.getProperty(&quot;my.big.decimal&quot;);<br/>        return new Integer(property);<br/>    }<br/>}</pre><br/>Try to <code class=""inline-code"">Extract Field</code> from <code class=""inline-code"">get()</code> method call.<br/>Check <code class=""inline-code"">Replace all occurrences (3)</code> and make sure IDEA selects method <code class=""inline-code"">setUp</code> in <code class=""inline-code"">Initialize in</code> dropdown.<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">    @Before<br/>    public void setUp() {<br/>        big = get();<br/>        Integer bigDecimal = big;<br/>        System.out.println(bigDecimal.intValue());<br/>    }</pre><br/><strong>Actual</strong><br/>IDEA places <code class=""inline-code"">big = get();</code> at the end of <code class=""inline-code"">setUp</code> method which will lead to NPE.<br/><pre class=""wikicode prettyprint"">    @Before<br/>    public void setUp() {<br/>        Integer bigDecimal = big;<br/>        System.out.println(bigDecimal.intValue());<br/>        big = get();<br/>    }</pre></div>
","0"
"IDEA-223229","IntelliJ IDEA","","IDEA allows renaming Enum#values if invoked from inside enum type","Taras Tielkes","20/09/2019 10:30","21/07/2022 14:14",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
public enum Dummy {
    FOO,BAR;

    @Override
    public String toString() {
        Dummy.values<caret>();
        return """";
    }
}
```
Invoking _rename_ at caret location corrupts content in the current file (typically in the package declaration).","0"
"IDEA-223306","IntelliJ IDEA","","Refactoring: ""Rename class"" leads to freeze. Deep recursion in EDT.","Alexander Münch","23/09/2019 04:58","21/07/2022 14:14",,"Normal","Bug",,"develar","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**
1. Place the caret on the class name in definition line `class MyClassName`
2. Shift+F6 to rename
3. Enter new name and hit return key.

**What is the expected result?**
- File gets renamed
- References get renamed.

**What happens instead?**
- IDE freezes. I still can see the selected class name.
- After killing IntelliJ, only the file got renamed. No changes on the code were made.

**Attachments**
I dumped a stacktrace. It looks like the EDT has a very deep recursion.
`idea.log` shows a `Cyclic service initialization`.","0"
"IDEA-196974","IntelliJ IDEA","","Renaming a method loses external parameter annotations","Chris","08/08/2018 09:21","21/07/2022 14:08",,"Normal","Bug",,"anet","Java. Refactorings","2018.2 (182.3684.101)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>What steps will reproduce the issue?</strong><br/>1. Have some method that is annotated externally<br/>2. Use Shift-F6 to rename the method<br/><br/><strong>What is the expected result?</strong><br/><br/><br/><strong>What happens instead?</strong><br/>Only the external annotation on the method itself is preserved/updated.<br/>The annotation for the parameter(s) are ignored, because they are postfixed with &quot;&lt;space&gt;&lt;paramIndex&gt;&quot;<br/><br/><div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/><br/>Before<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>After<br/><div class=""wiki picture""><img src=""[](image1.png)""/></div><br/><br/><a href=""https://upsource.jetbrains.com/idea-ce/file/idea-ce-b98275b31d20a8d9331b5be5b8ceeb3a08e864c9/java/java-impl/src/com/intellij/codeInsight/ExternalAnnotationsRefactoringListenerProvider.java?nav=1708:1817:focused&amp;line=0&amp;preview=false"" target=""_blank"" rel=""noopener noreferrer"">https://upsource.jetbrains.com/idea-ce/file/idea-ce-b98275b31d20a8d9331b5be5b8ceeb3a08e864c9/java/java-impl/src/com/intellij/codeInsight/ExternalAnnotationsRefactoringListenerProvider.java?nav=1708:1817:focused&line=0&preview=false</a><br/><br/><br/>IntelliJ IDEA 2018.2.1 (Ultimate Edition)<br/>Build #IU-182.3911.36, built on August 6, 2018<br/>Subscription is active until March 14, 2019<br/>JRE: 1.8.0_152-release-1248-b8 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 10 10.0</div>
","0"
"IDEA-194748","IntelliJ IDEA","","Improve usability for accepting/rejecting refactorings / template placeholders with red outlines","Chris","28/06/2018 09:16","21/07/2022 13:37",,"Normal","Usability Problem",,"anet","Java. Refactorings","2018.2 (182.3684.101)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">This is basically a new version of  <a href=""/issue/IDEA-193059"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-2008098"" title=""Use &quot;Create field&quot; fix, F2 (jump to other inexisting field), no quick fix until red outline is dismissed"">IDEA-193059</a>, explicitly framed as a usability issue.<br/><br/>Red outlines while &quot;refactoring&quot; (fix intentions, templates etc) block all other intentions. <br/><br/><strong>Primary issue</strong>: The user isn&#39;t told why Alt-Enter and other inspections suddenly stop working. Further, dismissing the red outlines (&quot;accepting the refactoring&quot;) isn&#39;t really intuitive either and the current behavior seems to have <strong>no upside for the user</strong>.<br/><br/><strong>Solution</strong>: Alt-Enter should simply accept the refactoring and then suggest intentions based on the new, &quot;accepted&quot; code.<br/>The mouse-triggered light-bulb should appear as well, of course.<br/><br/><br/><hr/><br/>Detailed thoughts:<br/><br/>This happens because:<br/><br/>1. The user can click somewhere else in the code while the refactoring is active, <strong>alternatively</strong> (escape if a popup is open), press F2 to navigate to the next error<br/>2. IntelliJ will tell the user what the problem is (mouse over after cursor has been placed or hit F2)<br/>3. IntelliJ doesn&#39;t tell the user why quick fix doesn&#39;t work anymore<br/><br/><br/>In both cases, the red outlines are still there. Worse, using F2 to jump may scroll somewhere, where no red boxes are. The user loses any indicator that a refactoring is still going on! Even if there were red boxes still visible, why should they care?<br/><br/> <div class=""wiki picture""><img src=""[](image3.png)""/></div><br/><br/><br/><br/>If the user has placed the cursor somewhere else, the only way to accept the refactoring <strong>without changing the source code</strong> that I&#39;ve found, is to hit Escape. <strong>That doesn&#39;t really make sense.</strong><br/><br/><br/>Since when does &quot;Escape&quot; signify &quot;accept refactoring&quot;? If I have a refactoring popup, Escape will <strong>cancel</strong> it, Enter/Control-Enter will confirm it (default button)<br/><br/>Hitting anything else, Enter, Ctrl-Shift-Enter, Tab, Shift-Tab will complete the refactoring <strong>and</strong> insert those keys. That&#39;s usually annoying.<br/><br/>Good: Any regular letter: Accepting the refactoring makes sense when I type a letter, inserting the letter also makes sense. obviously I want to type some text at my current cursor position.<br/><br/>Bad: Tab/Shift-Tab, I would expect IntelliJ to jump and select the contents of the next red box, or do whatever it does when I&#39;m on the last red box, but no, intellij treats it as a regular keystroke because I&#39;m outside the magical red box.<br/><br/>Probably bad: Enter, adding a newline wherever I am and accepting the refactoring doesn&#39;t make sense. Especially if I used the mouse to go to some other &quot;error location&quot;, I probably don&#39;t want to insert a newline, I just want the refactoring to be complete.<br/>Probably bad: Ctrl-Shift-Enter: Both should just accept the refactoring without doing anything else.<br/><br/><br/>To summarize:<br/><br/><ul class=""wiki-list0""><li> User isn&#39;t told why intentions don&#39;t work anymore<br/></li><li> Intentions shouldn&#39;t just stop working while these refactorings are in progress, simply &quot;accept the refactoring&quot;<br/></li><li> No way to jump back to the red boxes without placing the cursor there manually<br/></li><li> Tab/shift-Tab/Enter/Ctrl-Shift-Enter don&#39;t silently accept the refactoring<br/></li><li> Escape as the only way to accept the refactoring and do nothing more once I&#39;m outside the red boxes is poor usability<br/><br/>----</li></ul><br/>Some other thoughts:<br/><br/>Based on the other comments, I&#39;ve come to learn about what <a href=""https://youtrack.jetbrains.com/users/anet"" title=""anet"" data-user-id=""11-49"">Anna Kozlova</a> called &quot;accepting&quot; and &quot;rejecting&quot; a refactoring. My interpretation is that this is an implementation detail and explains why IntelliJ behaves the way that it does. I, as a user, don&#39;t think in these terms. The user shouldn&#39;t have to think about &quot;rejecting&quot; or &quot;accepting&quot; a refactoring. Especially if the only way to &quot;reject&quot; it is &quot;undo&quot;, and accepting (when the cursor is somewhere else) is escape.<br/><br/><br/><hr/><br/><br/>Even as a long time IntelliJ user, this bothers me. <br/>I simply hit Escape a couple of times by instinct to get the &quot;editor to behave&quot;, because maybe a popup is still open, maybe I have a popup and a selection. That&#39;s why I simply hit escape 3 times without thinking after having done some refactoring with &quot;red boxses&quot;. <br/><br/>A new user doesn&#39;t have this reflex. This issue has come up with both my coworkers that are taking the plunge with IntelliJ after years of Eclipse usage. Please take this seriously.<br/><br/>Thanks for listening.<br/><br/><hr/><br/>Sidenote: In  <a href=""/issue/IDEA-193059"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-2008098"" title=""Use &quot;Create field&quot; fix, F2 (jump to other inexisting field), no quick fix until red outline is dismissed"">IDEA-193059</a>, <a href=""https://youtrack.jetbrains.com/users/anet"" title=""anet"" data-user-id=""11-49"">Anna Kozlova</a> mentioned that there is a traffic light which shows that analysis is paused. This isn&#39;t the case in the latest EAP at least, the analysis is updated as soon as the popup is gone, at the very least:<br/><br/> <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/><br/>As you can see here, the analysis was updated with the error I introduced manually in the red box. The line was marked as an error as soon as I dismissed the popup, which seems to have triggered an analysis.<br/><br/> <div class=""wiki picture""><img src=""[](image4.png)""/></div><br/><br/><br/><hr/><br/>I understand that changing Escape to reject the refactoring will break the muscle memory of a lot of users. Even my own, maybe it&#39;s worth it, maybe not. It should not be the only way, however, to accept the refactoring.<br/><br/><br/><pre class=""wikicode prettyprint"">package com.company;<br/><br/>import java.util.List;<br/><br/>public class UninitializedVariable {<br/>    public static void main(String[] args) {<br/>        List&lt;String&gt; undefined = new List&lt;String&gt;();<br/>        List&lt;String&gt; variable = abc1();<br/>        abc1();<br/>        iNeedAList(undefined);<br/>    }<br/><br/>    private static Object abc1() {<br/>    }<br/><br/><br/>    public static void iNeedAList(List&lt;String&gt; list) {<br/><br/>    }<br/>}</pre></div>
","0"
"IDEA-190494","IntelliJ IDEA","","Change signature: No blinking cursor in preview if focused","Chris","18/04/2018 06:21","21/07/2022 07:53",,"Normal","Feature",,"kb","Java. Refactorings","2018.1.5 (181.5284.24)",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">As shown in <a href=""/issue/IDEA-190493"" target=""_self"" data-issue-id=""25-1958059"" title=""Change signature: Moving focus into list of params is only possible when moving backwards from &quot;Method calls&quot; radio buttons"">IDEA-190493</a>, the preview participates in the tab order.<br/><br/>While the focus is inside that editor, there is no visual cue. However, shortcuts such as Expand selection, select all, home, end etc all work.<br/><br/>Expected behavior<br/><br/><ul class=""wiki-list0""><li> There needs to be a visual cue whenever the focus is inside the preview editor.<br/></li><li> Maybe the preview shouldn&#39;t participate in the tab order at all and only be manually focusable (but Tab/Shift-Tab should move the focus to sensible elements)<br/></li></ul></div>
","0"
"IDEA-222418","IntelliJ IDEA","","""Replace 'forEach' with loop"" quick-fix should prefer defined variable names instead of generic ""key""","Andrey Turbanov","10/09/2019 18:18","14/07/2022 11:55",,"Normal","Usability Problem",,"Tagir.Valeev","Java. Refactorings","2019.2.3 (192.6817.14)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    void convertCycles(Map&lt;String, Integer&gt; m, Map&lt;String, Exception&gt; e) {<br/>        m.forEach((className, counter) -&gt; {<br/>            System.out.println(className);<br/>            System.out.println(counter);<br/>        });<br/><br/>        e.forEach((className, exc) -&gt; {<br/>            System.out.println(className);<br/>            System.out.println(exc.toString());<br/>        });<br/>    }</pre><br/>Invoke quick-fix <code class=""inline-code"">Replace &#39;forEach&#39; with loop</code> for first <code class=""inline-code"">forEach</code> call<br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">        for (Map.Entry&lt;String, Integer&gt; entry : m.entrySet()) {<br/>            String className = entry.getKey();<br/>            Integer counter = entry.getValue();<br/>            System.out.println(className);<br/>            System.out.println(counter);<br/>        }</pre><br/><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">        for (Map.Entry&lt;String, Integer&gt; entry : m.entrySet()) {<br/>            String key = entry.getKey();<br/>            Integer counter = entry.getValue();<br/>            System.out.println(key);<br/>            System.out.println(counter);<br/>        }</pre></div>
","0"
"IDEA-221808","IntelliJ IDEA","","Create local variable proposes raw type instead of generic","Andrey Turbanov","02/09/2019 09:45","14/07/2022 09:31",,"Normal","Bug",,"anet","Java. Refactorings","2019.2.2 (192.6603.28)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.3 (193.5233.102)","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class MyObjectParameterDescriptor&lt;T&gt; {<br/>    public Holder createHolder() {<br/>        return new Holder();<br/>    }<br/><br/>    public class Holder {<br/>    }<br/>}<br/><br/>class UsageObjectParameterDescriptor {<br/>    void use(MyObjectParameterDescriptor&lt;BigDecimal&gt; descriptor) {<br/>        holder&lt;caret&gt; = descriptor.createHolder();<br/>    }<br/>}</pre><br/>Invoke quick-fix create local variable<br/><br/><strong>Expected</strong><br/>IDEA shows generic type <code class=""inline-code"">MyObjectParameterDescriptor&lt;BigDecimal&gt;.Holder</code> in popup as first item<br/><br/><strong>Actual</strong><br/>IDEA shows raw type <code class=""inline-code"">MyObjectParameterDescriptor.Holder</code> in popup as first item<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-222063","IntelliJ IDEA","","IDEA adds unnecessary cast on generic method inline which makes code uncompilable","Andrey Turbanov","05/09/2019 12:01","14/07/2022 09:31",,"Normal","Bug",,"anet","Java. Refactorings","2019.2.2 (192.6603.28)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.3 (193.5233.102)","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public abstract class RedundantGenericOnInline {<br/><br/>    Collection&lt;Integer&gt; findIntegers() {<br/>        return findByType(ObjectReturnType.INTEGER);<br/>    }<br/><br/>    Collection&lt;Long&gt; findLongs() {<br/>        return findByType(ObjectReturnType.LONG);<br/>    }<br/><br/>    private &lt;K&gt; Collection&lt;K&gt; findByType(ObjectReturnType&lt;K&gt; integer) {<br/>        return findByType(integer, 1);<br/>    }<br/><br/>    protected abstract &lt;K&gt; Collection&lt;K&gt; findByType(ObjectReturnType&lt;K&gt; integer, int some);<br/><br/>    private static final class ObjectReturnType&lt;T&gt; {<br/>        private static final ObjectReturnType&lt;Integer&gt; INTEGER = new ObjectReturnType&lt;&gt;();<br/>        private static final ObjectReturnType&lt;Long&gt; LONG = new ObjectReturnType&lt;&gt;();<br/>    }<br/>}</pre><br/>Inline method <code class=""inline-code"">RedundantGenericOnInline#findByType(RedundantGenericOnInline.ObjectReturnType&lt;K&gt;)</code><br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">    Collection&lt;Integer&gt; findIntegers() {<br/>        return findByType(ObjectReturnType.INTEGER, 1);<br/>    }<br/><br/>    Collection&lt;Long&gt; findLongs() {<br/>        return findByType(ObjectReturnType.LONG, 1);<br/>    }</pre><br/><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">    Collection&lt;Integer&gt; findIntegers() {<br/>        return findByType((ObjectReturnType&lt;K&gt;) ObjectReturnType.INTEGER, 1);<br/>    }<br/><br/>    Collection&lt;Long&gt; findLongs() {<br/>        return findByType((ObjectReturnType&lt;K&gt;) ObjectReturnType.LONG, 1);<br/>    }</pre></div>
","0"
"IDEA-221533","IntelliJ IDEA","","Replace constructor with factory does nothing","Régis Caspar","28/08/2019 08:48","14/07/2022 09:19",,"Normal","Bug",,"anet","Java. Refactorings","2019.2.2 (192.6603.28)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.3 (193.5233.102)","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**
1. right click in some class on a constructor call
2. select refactor > replace constructor with factory
3. click the refactor button

**What is the expected result?**
The refactoring is done when 

**What happens instead?**
Nothing

**Please attach idea.log (go to Help | Show Log in ... to discover it easily). You can use 'Attach File Privately' item to make attachments visible to 'jetbrains-team' group only. If you don't want to share IDE logs even with JetBrains team please at least paste information about IDE build and your environment below (it can be copied from Help | About dialog).**

```stacktrace
2019-08-28 13:37:49,835 [191337412]  ERROR - llij.ide.plugins.PluginManager - Argument for @NotNull parameter 'first' of com/intellij/psi/impl/source/tree/CompositeElement.rawAddChildren must not be null 
java.lang.IllegalArgumentException: Argument for @NotNull parameter 'first' of com/intellij/psi/impl/source/tree/CompositeElement.rawAddChildren must not be null
	at com.intellij.psi.impl.source.tree.CompositeElement.$$$reportNull$$$0(CompositeElement.java)
	at com.intellij.psi.impl.source.tree.CompositeElement.rawAddChildren(CompositeElement.java)
	at com.intellij.psi.impl.source.tree.ChangeUtil.copyToElement(ChangeUtil.java:121)
	at com.intellij.psi.impl.source.tree.SharedImplUtil.doReplace(SharedImplUtil.java:210)
	at com.intellij.psi.impl.source.JavaStubPsiElement.replace(JavaStubPsiElement.java:112)
	at com.intellij.refactoring.replaceConstructorWithFactory.ReplaceConstructorWithFactoryProcessor.createFactoryMethod(ReplaceConstructorWithFactoryProcessor.java:267)
	at com.intellij.refactoring.replaceConstructorWithFactory.ReplaceConstructorWithFactoryProcessor.preprocessUsages(ReplaceConstructorWithFactoryProcessor.java:181)
```

**Сonsider attaching a screenshot, screencast, or a code sample when it's hard to articulate the problem. Note that you can easily drag & drop files of any type into the issue.**
![screencast](2019-08-28 13.44.34.gif)

**Version**
>IntelliJ IDEA 2019.2.1 (Ultimate Edition)
Build #IU-192.6262.58, built on August 20, 2019
Licensed to *Me*
You have a perpetual fallback license for this version
Subscription is active until ...
Runtime version: 11.0.3+12-b304.39 x86_64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
macOS 10.14.6
GC: G1 Young Generation, G1 Old Generation
Memory: 4096M
Cores: 8
Registry: ide.editor.tabs.open.at.the.end=true, ide.mac.allowDarkWindowDecorations=true
Non-Bundled Plugins: Lombook Plugin, com.chainstaysoftware.assertions2assertj, Pythonid, org.sylfra.idea.plugins.linessorter","0"
"IDEA-221226","IntelliJ IDEA","","Find and Replace Code Duplicates: false positive","Thomas Singer","23/08/2019 05:40","13/07/2022 13:19",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","In the attached sample code, invoking ""Refactoring | Find and Replace Code Duplicates"" on com.foobar.test.Test2#getPath finds the `toString` invocation in Test1 and turns it into uncompilable code.

IU-192.5728.98, JRE 11.0.3 12-b304.10x64 JetBrains s.r.o, OS Windows 10(amd64) v10.0 , screens 1280x720, 1920x1080e","0"
"IDEA-209331","IntelliJ IDEA","","'Extract variable' produces variable with incorrect type","Andrey Turbanov","20/03/2019 14:46","13/07/2022 12:47",,"Normal","Bug",,"anet","Java. Refactorings","2018.2.7 (182.5107.41)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.2 (192.5728.98)","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class GenericWildcardSetter&lt;T&gt; {<br/>    void call(DataProvider&lt;? extends T&gt; provider) {<br/>        provider.query()&lt;caret&gt;;<br/>    }<br/>}<br/><br/>interface DataProvider&lt;T&gt; {<br/>    CompletableFuture&lt;List&lt;AtomicReference&lt;T&gt;&gt;&gt; query();<br/>}</pre><br/>Invoke <code class=""inline-code"">Extract variable</code> refactoring<br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">CompletableFuture&lt;? extends List&lt;? extends AtomicReference&lt;? extends T&gt;&gt;&gt; query = provider.query();</pre><br/><strong>Actual</strong><br/>Uncompilable code:<br/><pre class=""wikicode prettyprint"">CompletableFuture&lt;List&lt;? extends AtomicReference&lt;? extends T&gt;&gt;&gt; query = (CompletableFuture&lt;List&lt;? extends AtomicReference&lt;? extends T&gt;&gt;&gt;) provider.query();</pre></div>
","0"
"IDEA-215569","IntelliJ IDEA","","Moving inner class together with implementing interface can result in invalid code","Jonathan Widén","04/06/2019 11:13","13/07/2022 07:27",,"Normal","Bug",,"anet","Java. Refactorings","2019.1.2 (191.7141.44)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","2019.2 (192.5728.98)","No zendesk mentions",,"No assigned support","Unknown","## Steps to reproduce
(Note that the names used here are the same as the ones used in the code snippets, but you can of cource use your own names)
1. Make an outer class `OuterClass`
2. Make an inner interface `Interface`
3. Make a static inner class `InnerClass` which is implementing that interface (`static class InnerClass implements Interface`)
4. Make another outer class `SecondClass`
5. Go back to the inner class `InnerClass`, right click, and choose `Refactor -> Move`, or press `F6`
6. You will get a question of whether you want to move the class to upper level or move it to another class. Choose `Move inner class InnerClass to another class`
7. You will get a dialog box about the refactoring
7.1 Enter the other outer class `SecondClass` as the destination class
7.2 In the list of members to move, choose to move both the inner class `InnerClass` and the interface `Interface`
8. Confirm the refactoring

## Expected result
The expected result is that both the inner class `InnerClass` and the interface `Interface` gets moved to the class `SecondClass`, and that the signature `InnerClass implements Interface` stays as-is since the interface is moved to the same destination.

## Actual result
The actual result is that both `Interface` and `InnerClass` gets moved, but `InnerClass` is changed to implement `OuterClass.Interface` (`OuterClass` is the old outer class). But `Interface` was moved to `SecondClass` during the refactoring, which means that `OuterClass.Interface` is invalid and an error occurs since that symbol isn't found (it is located in `SecondClass.Interface`). Please see the code snippets below.

## Code snippets
#### This is how the files looked like before the refactoring:
`OuterClass.java`
```java
public class OuterClass {
    public static class InnerClass implements Interface {}
    public interface Interface {}
}
```

`SecondClass.java`
```java
public class SecondClass {}
```

#### This is how the files looks after the refactoring:
`OuterClass.java`
```java
public class OuterClass {}
```

`SecondClass.java`
```java
public class SecondClass {
    public interface Interface {}
    public static class InnerClass implements OuterClass.Interface {}
}
```

#### This is how the files should have looked after the refactoring:
`OuterClass.java`
```java
public class OuterClass {}
```

`SecondClass.java`
```java
public class SecondClass {
    public interface Interface {}
    public static class InnerClass implements Interface {}
}
```

## Build info
I have tested this on two computers, and I was able to reproduce it on both of them. I am including build info for both of the computers below:
```text
IntelliJ IDEA 2019.1.2 (Ultimate Edition)
Build #IU-191.7141.44, built on May 7, 2019
Licensed to Jonathan Widén
Subscription is active until May 10, 2020
For educational use only.
JRE: 1.8.0_202-release-1483-b49 amd64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0
```

```text
IntelliJ IDEA 2019.1.3 (Ultimate Edition)
Build #IU-191.7479.19, built on May 28, 2019
Licensed to Jonathan Widén
Subscription is active until May 10, 2020
For educational use only.
JRE: 1.8.0_202-release-1483-b49 amd64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0
```","0"
"IDEA-283810","IntelliJ IDEA","","Suggested refactoring blinks","Alexander Kass","02/12/2021 04:52","11/07/2022 10:32",,"Normal","Bug",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","If I change something near the function signature, suggested refactoring icon is shown on gutter and then hidden, that is distracting. See video attached.
```
IntelliJ IDEA 2022.1 EAP (Ultimate Edition)
Build #IU-221.1516, built on November 22, 2021
IntelliJ IDEA EAP User
Expiration date: December 22, 2021
Runtime version: 11.0.13+8-b1845.1 amd64
VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o.
Linux 5.15.4-arch1-1
GC: G1 Young Generation, G1 Old Generation
Memory: 2000M
Cores: 16
Registry:
    debugger.auto.attach.from.console=true
    analyze.exceptions.on.the.fly=true
    show.editor.diff.preview=false
    vcs.show.affected.files.as.tab=false
    linux.native.menu.force.disable=true
    editor.distraction.free.mode=true
    ide.new.editor.tabs.vertical.borders=true
    focus.follows.mouse.workarounds=true
    credentialStore.linux.prefer.kwallet=true

Non-Bundled Plugins:
    jetbrains.team.auth (221.1516)
    com.jetbrains.colorful.toolwindow.icons (1.0)
    com.jetbrains.ChooseRuntime (1.2)
    org.jetbrains.idea.grammar (2021.1.2)
    com.intellij.sisyphus (221.1516)
    com.github.kassak.dg-test-helper (0.12)
    JOL (1.10.0)
    com.jetbrains.idea.safepush (221.1516)
    Jetbrains TeamCity Plugin (2021.2.99542)
    com.jetbrains.intellij.api.watcher (6.56.0)

Kotlin: 221-1.5.10-release-955-IJ1516
Current Desktop: Undefined
```","1"
"IDEA-109669","IntelliJ IDEA","","""Ctrl+right arrow"" should jump on the end of the word that is being renamed, not on the beginning of next one","Vojtěch Krása","26/06/2013 15:50","21/06/2022 11:58",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">same as the right arrow jumps on the end when it is the first thing pushed after shift+f6</div>
","2"
"IDEA-295708","IntelliJ IDEA","","Asking for replacement when deleting class","Christian Packenius","09/06/2022 03:39","20/06/2022 12:17",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Hello, when I delete a java class (with or without ""safe delete"" selected) then I get  a message box for asking if I really want to delete it (including checkboxes for ""safe delete"", ""search in ..."" and ""search for ..."").



It would be great to have the possibility to choose a concrete class that would replace the deleted one at every occurence it was placed (e.g. when I am refactoring my code).



Currently when I delete a class (ignoring ""safe deletion"") I get errors at every place this class was used.



I am using:

IntelliJ IDEA 2022.1.2 (Ultimate Edition)

Build #IU-221.5787.30, built on May 31, 2022



Thanks for your great work! :-)","0"
"IDEA-295829","IntelliJ IDEA","","Introduce Variable doesn't allow `var`, but code does not compile without it","Bas Leijdekkers","10/06/2022 05:17","10/06/2022 05:28",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Example:
```
class NonDenotable {
    void x() {
        y(createCloseableIterator()); // introduce variable for createCloseableIterator()
    }

    private static <T extends Closeable & Iterator<String>> T createCloseableIterator() {
        return (T) new Scanner(System.in);
    }

    private static <T extends Closeable & Iterator<String>> void y(T elements) {
    }
}
```
I expected to be able to create a 
```
var c = createCloseableIterator();
```
variable, but IntelliJ IDEA does not allow me. It tries to create a variable with type Closeable, but this does not compile. The expected type is non-denotable, so it should suggest `var` by default in this case IMO.","0"
"IDEA-293367","IntelliJ IDEA","","""migrate packages and classes"" add stuctural search&replace rules","Igor Konoplyanko","02/05/2022 08:30","25/05/2022 04:57",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Migrate packages and classes is a great tool, though it lacks flexibility and not sufficient for most real life use-cases.

It will be simple and straightforward to extend it with structural search&replace rules. Then it could cover much more sophisticated migrations.

If needed can provide some real life examples.","0"
"IDEA-179620","IntelliJ IDEA","","Extract variable to class places member variable inside of formatter comment block","Chris Carini","26/09/2017 17:40","19/05/2022 10:33",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">This issue was found on OSX 10.12.6, using IntelliJ CE 2017.2.4; complete information below:<br/><pre class=""wikicode prettyprint"">IntelliJ IDEA 2017.2.4<br/>Build #IC-172.4155.36, built on September 11, 2017<br/>JRE: 1.8.0_152-release-915-b11 x86_64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Mac OS X 10.12.6</pre>Additionally, it was reproducible on: <code class=""inline-code"">Build #IU-172.4155.36, built on September 11, 2017</code>.<br/><br/><h1>Description</h1><br/>When the last member variable is surrounded by <code class=""inline-code"">// @formatter:[on|off]</code> and the user extracts a variable from within a method to class level, the extracted variable will end up in the formatted block.<br/><br/><br/><h1>Expected Behavior</h1><br/>The extracted variable is below the <code class=""inline-code"">// @formatter:...</code> block.<br/><br/><br/><h1>Actual Behavior</h1><br/>The extracted variable is within the <code class=""inline-code"">// @formatter:...</code> block.<br/><br/><br/><h1>Example</h1><br/><pre class=""wikicode prettyprint"">package com.example;<br/><br/>public class TestClass {<br/>    // @formatter:off<br/>    private static int x = 0;<br/>    // @formatter:on<br/><br/><br/>    public TestClass() {<br/>        int cat = 100;<br/>    }<br/>}</pre><br/>Placing your cursor on <code class=""inline-code"">cat</code> on line 10 in the above example, then hitting the shortcut for extract to class (<code class=""inline-code"">[Alt]+[Cmd]+[C]</code> on OSX 10.12.6), will yield the below:<br/><br/><pre class=""wikicode prettyprint"">package com.example;<br/><br/>public class TestClass {<br/>    // @formatter:off<br/>    private static int x = 0;<br/>    public static final int CAT = 100;<br/>    // @formatter:on<br/><br/><br/>    public TestClass() {<br/>    }<br/>}</pre><br/>I would expect this to be below the formatting block, like so:<br/><br/><pre class=""wikicode prettyprint"">package com.example;<br/><br/>public class TestClass {<br/>    // @formatter:off<br/>    private static int x = 0;<br/>    // @formatter:on<br/>    public static final int CAT = 100;<br/><br/><br/>    public TestClass() {<br/>    }<br/>}</pre></div>
","0"
"IDEA-294310","IntelliJ IDEA","","""Edit migration map"" dialog is not saving mappings","Igor Konoplyanko","18/05/2022 18:11","19/05/2022 04:56",,"Normal","Bug",,"yopox","Java. Refactorings","2021.3.3 (213.7172.25)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***

Prerequesite: have one custom mapping with 1 class mapping element. 
1\. Go to ""Refactor"" -\> ""Migrate Packages and classes"" -\> Select your custom mapping
2\. Click edit element
3\. Add new mapping in the dialog

4\. Click ""save""

5\. Restart intellij
***What is the expected result?***

Added mapping in Step 3 should be persisted.

***What happens instead?***

Mapping from Step 3 was not saved","0"
"IDEA-293981","IntelliJ IDEA","plugin solution available","Improve builder pattern refactoring","Alexandr Sokolov","13/05/2022 06:27","13/05/2022 08:38",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Open a class with fields/getters/setters/constructor
***What is the expected result?***

Now I can for the set of fields generate constructor. Great. For this generation, there are no requierement, only a set of fields. That's all.

Now I want to generate builder. I do not invoke constructor yet. I only have a class. I want to have the same workflow as with constructor generation, go in the menue: Code -\> Generate -\> Builder  

or via ""Refactore"" menu item.

***What happens instead?***

*Instead, according to your documentation, I have to invoke constructor, put the mouth pointer to invokation and only then Replace constructor with the Builder. But even this option is not availeble to me. Not clear, why. I locate* the caret at the constructor, or at the constructor invocation, I still do not see the option to replace a constructor.



Actually I've found IDEA-121030, but it was created 8 years ago and no changes here.","0"
"IDEA-293054","IntelliJ IDEA","","Incorrect refactoring of read-only files","欣芸 万","26/04/2022 19:14","28/04/2022 05:11",,"Normal","Bug",,"dima","Java. Refactorings","2022.1 (221.5080.210)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***

1. Create ""A.java"".
2. Click the lock icon to make it read-only.
   *It shows Reader Mode and ✅︎ in the upper right corner.*
3. Close tab.
4. Rename ""A.java"" to ""B.java"".
   *Follow the instructions to clear its read-only status.*
5. Open ""B.java"".

***What is the expected result?***

Or, the file becomes writable, with a ⚠︎ in the upper right corner (no Reader Mode anymore)

***What happens instead?***

The file becomes writable, but with a ✅︎ in the upper right corner.

After closing the project, this is found in ""workspace.xml"":

```xml
  <component name=""HighlightingSettingsPerFile"">
    <setting file=""file://$PROJECT_DIR$/src/B.java"" root0=""SKIP_INSPECTION"" />
  </component>
```","0"
"IDEA-221675","IntelliJ IDEA","multiple carets","unable to customize name of extracted variables with multiple cursor","Yusuke Yamamoto","30/08/2019 03:52","13/04/2022 11:26",,"Normal","Bug",,"ideasupport","Java. Refactorings","2019.3 (193.5233.102), 2019.2.1 (192.6262.58)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. select multiple elements with Ctrl + G
2. extract variable with Opt + Cmd + V
3. select ""Replace all n occurrences""
4. type to customize the variable name

What is the expected result?
Multi-cursor mode is cancelled and typed variable name is applied.

What happens instead?
Typed characters are inserted into multiple places.","0"
"IDEA-153209","IntelliJ IDEA","","Move Element Right / Left for condition clauses","Dmitry Cherniachenko","18/03/2016 06:18","13/04/2022 04:34",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;ve realized that the nice new feature of moving element right/left with a single keystroke could be useful in the multi-clause conditions too.<br/><code class=""inline-code"">if (condA || condB)</code> =&gt; <code class=""inline-code"">if (condB || condA)</code></div>
","1"
"IDEA-176796","IntelliJ IDEA","","Move Left/Right action does not suggest to apply signature change","Aleksey Kladov","28/07/2017 05:48","12/04/2022 05:15",,"Normal","Bug",,"elena.kozlova","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Docs say that after I move function parameters with <code class=""inline-code"">Ctrl+Shift+Alt+Left/Right</code>, I should be able to hit <code class=""inline-code"">Alt+Enter</code> make this into a refactoring and fix callsites: <a href=""https://www.jetbrains.com/help/idea/adding-deleting-and-moving-code-elements.html#r_Adding_Deleting_and_Moving_Lines.xmld7346e240"" target=""_blank"" rel=""noopener noreferrer"">https://www.jetbrains.com/help/idea/adding-deleting-and-moving-code-elements.html#r_Adding_Deleting_and_Moving_Lines.xmld7346e240</a><br/><br/>However, this does not seem to happen, see the attached video</div>
","0"
"IDEA-253490","IntelliJ IDEA","Jigsaw","java9+ - inner class movement does not update `module-info.java`","Ilyas Selimov","21/10/2020 09:38","30/03/2022 00:37",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Given the JPMS module *module1*, the packages *pack1*, *pack1.pack2* belong to *module1*.
*pack1* contains a  class:
```
package pack1;

public class Test {
  public static class Inner {
  }
}
```
*module-info*:
```
module module1 {
  exports pack1;
}
```

We move *Inner* class to the package *pack1.pack2*.

**Actual result:**
*module-info* isn't changed after the movement
**Expected result:**
*module-info*:
```
module module1 {
  exports pack1;
  exports pack1.pack2;
}
```

PS
Probably, we should fix com.intellij.refactoring.move.moveInner.MoveInnerProcessor and reuse the logic of the related task [IDEA-179260](https://youtrack.jetbrains.com/issue/IDEA-179260)","0"
"IDEA-290679","IntelliJ IDEA","","Extract functional parameter ignores the function's parameter type","Yves Stadler","18/03/2022 06:32","18/03/2022 13:14",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When using extract functional parameter from the refactoring menu, it seems that InteliJ does not check correctly for types when the call argument is a parameter, rather than a variable. It will instead consider the functional parameter to be extracted as being `() -> return type` instead of `(call arg type) -> return type` .

Step to reproduce (see figure 1)

Have a function that uses a call to `extract(parameter)` into an int where ` parameter`  is a parameter of the current function (of type `type` ). Extracting functional parameter on ` extract`  opens the dialog to extract as `() -> int` instead of  `(type) -> int` 

If the parameter is extracted to a local variable first, the refactoring works as expected (see figure 2 for the setup).

IU-213.6777.52, JRE 11.0.13+7-b1751.25x64 JetBrains s.r.o., OS Linux(amd64) v5.14.0-1027-oem, screens 3840.0x2160.0, 1920.0x1080.0","0"
"IDEA-162407","IntelliJ IDEA","javadoc","'Replace constructor with builder' should create javadoc for setters","Andrey Turbanov","11/10/2016 14:06","17/03/2022 08:15",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It would be nice if &#39;Replace constructor with builder&#39; have ability to automatically create javadoc for setters in builder<br/><br/>E.g.<br/><pre class=""wikicode prettyprint"">public class VeryLongConstructor {<br/>    private final int quantity;<br/><br/>    /**<br/>     * Create a new VeryLongConstructor<br/>     *<br/>     * @param quantity trade quantity<br/>     */<br/>    public VeryLongConstructor(int quantity) {<br/>        this.quantity = quantity;<br/>    }<br/>}</pre>When invoke &#39;Replace constructor with builder&#39; I expect this setter in builder:<br/><pre class=""wikicode prettyprint"">    /**<br/>     * Sets trade quantity<br/>     *<br/>     * @param quantity trade quantity<br/>     * @return this<br/>     */<br/>    public VeryLongConstructorBuilder setQuantity(int quantity) {<br/>        this.quantity = quantity;<br/>        return this;<br/>    }</pre></div>
","0"
"IDEA-250024","IntelliJ IDEA","","Inline rename: selection (rectangle highlighted in blue) is far behind the caret when name of the symbol is cleared","Tatiana Shabaeva","03/09/2020 10:59","09/03/2022 05:16",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","`IntelliJ IDEA 2020.3 Snapshot (Ultimate Edition) Build #IU-203.3225, built on September 3, 2020`
Applies to both Java and Kotlin. Also seeing the same in minor IDEs (e.g. AppCode, CLion).

This is new in master comparing to 2020.2.x.

```
// .java
void ba<caret>r() { } // invoke Rename -> remove method name
```

Actual: selection (rectangle highlighted in blue) is behind the caret, right after `//` and corresponding icon. See screencast.

Expected: selection should be at the same position where the caret is.","0"
"IDEA-288314","IntelliJ IDEA","","Unexpected behavior on using feature 'introduce variable' followed by 'start new line'","Mala Gupta","08/02/2022 17:29","02/03/2022 04:17",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Sample code:

```
public class Person {
    private final String firstName;
    private final String lastName;

    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    void createPerson() {
    }
}
```



Expected behavior: Step (3) is unexpected behavior.



Actual behavior:

1. I create a local variable using the feature 'introduce variable' by using Alt+enter
2. Without modifying any default values, I use Shift+enter to start a new line.
3. When I type any character on the new line, the focus returns to the end of the previous line.



Gif attached.




","0"
"IDEA-236226","IntelliJ IDEA","","Intellij re formatting on extract to variable and other scenarios.","momomo","27/03/2020 13:24","21/02/2022 08:31",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","See video. 

Intellij always does this. You fight to keep things aligned and intellij breaks everything. Annotations and what not. It needs to pay better attention. 

It happens on import and what not. Why does it reformat? Why does it place things on a separate line?

From : 

![](image.png)

to: 

![](image1.png)","0"
"IDEA-288388","IntelliJ IDEA","","Safe Delete does not propagate class deletion for unused class in some cases","Sergei Riabinin","09/02/2022 11:33","09/02/2022 17:24",,"Normal","Bug",,"anet","Java. Refactorings","2021.3.2 (213.6777.52)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Refactor | Safe Delete works differently for unused class with unused method:

example 1. Class is propagated for deletion:
`public class CascadeWorks {

    public StringReader gett() {
        return new StringReader("""");
    }
}`

![](cascadeWorks.png){width=467px}

example 2. Class is not propagated for deletion, method is deleted without Select Members dialog:
`public class CascadeDoesntWork {

    public StringReader gett() {
        System.out.println(""bla"");
        return null;
    }
}`

![](cascadeDoesntWork.png){width=281px}

Sample project for reproducing is attached","1"
"IDEA-286903","IntelliJ IDEA","","renaming static method and its overloaded sibling adds class qualification to some calls.","Marcin Mikosik","18/01/2022 10:40","20/01/2022 10:59",,"Normal","Bug",,"anet","Java. Refactorings","2021.3.1 (213.6461.79)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1\. Create two classes in separate files:

`Library` class with two overloaded methods

```
public class Library {
  public static int method(String string) {
    return 0;
  }

  public static int method(String string, String otherString) {
    return 0;
  }
}
```

`Client` class that imports methods name statically and calls both methods without class qualification.

```
import static org.smoothbuild.bytecode.obj.Library.method;

public class Client {
  public static void doStuff() {
    int result = method(""abc"") + method(""def"", ""ghi"");
  }
}
```

2\. Rename first `method` method to `methodB`. When IDE suggests renaming the other one accept suggestion.

***What is the expected result?***

Methods are renamed. Both calls are without class qualification.

```
import static org.smoothbuild.bytecode.obj.Library.methodB;

public class Client {
  public static void doStuff() {
    int result = methodB(""abc"") + methodB(""def"", ""ghi"");
  }
}
```

***What happens instead?***

One of calls to \`methodB\` is qualified with class name.

```

import static org.smoothbuild.bytecode.obj.Library.methodB;

public class Client {
  public static void doStuff() {
    int result = Library.methodB(""abc"") + methodB(""def"", ""ghi"");
  }
}
```



**Output from ""Help -\> About -\> Copy""**

IntelliJ IDEA 2021.3.1 (Community Edition)

Build #IC-213.6461.79, built on December 28, 2021

Runtime version: 11.0.13+7-b1751.21 amd64

VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.

Linux 5.10.89-1-manjaro

GC: G1 Young Generation, G1 Old Generation

Memory: 1930M

Cores: 4

Non-Bundled Plugins:

&nbsp;&nbsp;&nbsp;&nbsp;org.antlr.intellij.plugin (1.17)

&nbsp;&nbsp;&nbsp;&nbsp;intellij.haskell (1.0.0-beta88)

Kotlin: 213-1.6.10-release-923-IJ5744.223

Current Desktop: KDE","0"
"IDEA-286569","IntelliJ IDEA","","Changing the parameter order of a generic method parameters moves generic parameter javadoc to the top","Jeff Kirby","12/01/2022 17:03","13/01/2022 08:43",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2021.3.1 (213.6461.79)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***
1. have a method with a generic parameter and with more than one input parameter, like ```private <X> Object f(X x, int y)```
2. generate javadoc for it. Note that the automatically generated javadoc will be in this order
```
  /**
   * @param x line 1
   * @param y line 2
   * @param <X> line 3
```
3. Run  Change Signature on the method.

***What is the expected result?***
The `@param <X>` line shall not move

***What happens instead?***
The `@param <X>` line becomes line 1. That is, the generic parameters are always moved to the top of the list. This is really frustrating when unchanged code is changed in source control. 


*If possible, please attach a code sample, screenshot, or screencast that illustrates the problem.*
see attached video 



*If you can’t provide IDE logs, please provide information about the IDE version and the OS you are using. You can copy these details from the About dialog in the Help or App menu.*
IntelliJ IDEA 2021.3.1 (Ultimate Edition)
Build #IU-213.6461.79, built on December 28, 2021
Runtime version: 11.0.13+7-b1751.21 aarch64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
macOS 12.0.1
GC: G1 Young Generation, G1 Old Generation
Memory: 2048M
Cores: 10
Non-Bundled Plugins:
    com.intellij.guice (213.6461.21)
    Pythonid (213.6461.79)

Kotlin: 213-1.5.10-release-949-IJ6461.79

","0"
"IDEA-210010","IntelliJ IDEA","","Introduce variable splits loop condition unnecessarily","Bas Leijdekkers","29/03/2019 09:24","12/01/2022 14:20",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","211.3553","Not specified","No zendesk mentions",,"No assigned support","Unknown","In the following code I want to extract `t.toString()` into a variable, to avoid the method call every loop iteration (because `t` is not modified inside the loop).
```
class X {
  void f(String s, Object t) {
    while (s != null && s.equals(t.toString())) {
      s = g(s);
    }
  }
  
  String g(String s) {
    return s.length() > 10 ? null : s + ""+"";
  }
}
```
However the result on introducing a variable is:
```
class X {
  void f(String s, Object t) {
    while (s != null) {
      String s1 = t.toString();
      if (!s.equals(s1)) break;
      s = g(s);
    }
  }
  
  String g(String s) {
    return s.length() > 10 ? null : s + ""+"";
  }
}
```
Now `t.toString()` is still calculated inside the loop and the loop condition is split for no good reason. I expected:
```
class X {
  void f(String s, Object t) {
    String s1 = t.toString();
    while (s != null && s.equals(s1)) {
      s = g(s);
    }
  }
  
  String g(String s) {
    return s.length() > 10 ? null : s + ""+"";
  }
}
```","1"
"IDEA-189402","IntelliJ IDEA","","Unnecessary fully qualified package name during refactor to move inner class to upper level","Kevin Connor Arpe","03/04/2018 03:46","10/01/2022 17:34",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">IntelliJ IDEA 2018.1.1 EAP (Ultimate Edition)<br/>Build #IU-181.4445.4, built on March 29, 2018<br/>Licensed to Kevin Arpe<br/>Subscription is active until November 27, 2018<br/>JRE: 1.8.0_152-release-1136-b27 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 7 6.1<br/><br/>~~~~~~~~~~~~~~~~~~~~~<br/><br/>To be clear, this is not a bug.   The code is still correct, but can be more compact.  =)<br/><br/><pre class=""wikicode prettyprint"">public interface Dummy {<br/>    <br/>    public static final class DummyImp<br/>    implements Dummy {       // ^^ Cursor here, then F6 (Windows) to move to upper level<br/>        <br/>        public static final DummyImp INSTANCE = new DummyImp();<br/>        <br/>        private DummyImp() {<br/>            // Empty<br/>        }<br/><br/>        @Override<br/>        public void foobar() {<br/>            // Intentional: Do nothing<br/>        }<br/>    }<br/>    <br/>    void foobar();<br/>}</pre><br/> <div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>Result:<br/><br/><pre class=""wikicode prettyprint"">public final class DummyImp<br/>    implements Dummy {<br/><br/>    public static final ia.quant.nextgen.sbl.locate_recycler.kdblog.DummyImp INSTANCE = new ia.quant.nextgen.sbl.locate_recycler.kdblog.DummyImp();<br/><br/>    private DummyImp() {<br/>        // Empty<br/>    }<br/><br/>    @Override<br/>    public void foobar() {<br/>        // Intentional: Do nothing<br/>    }<br/>}</pre><br/>Notice public static member <span class=""monospace"">INSTANCE</span> uses unnecessary fully qualified package name.</div>
","1"
"IDEA-196125","IntelliJ IDEA","","`Changes detected` is a redundant popup","Anton Konovalov","26/07/2018 04:31","09/01/2022 09:21",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Try to delete a file that is in use and check a checkbox to perform a search of its usages.
2. Click on 'View Usages' button
3. Get a 'Safe Delete Conflicts' pane opened with search results.
4. Remove usages.
5. Click 'Do refactor'.

What is the expected result?
Do refactor after manual resolving conflicts.

What happens instead?
Popup appeared asking you to do a re-search with a single button 'OK'.

When I do manual resolve I expecting to have a refactor happens after that. If your checker detected some changes and conflicts are still haven't been solved - it should automatically remove/disable 'Do refactor' button, or do re-search automatically, or, at least, allow more options than single 'OK' like 'Search again' and 'Force refactor'.","0"
"IDEA-284635","IntelliJ IDEA","","Optimize cursor movement during rename refactor","Erik van Oosten","10/12/2021 11:45","16/12/2021 09:22",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","During the rename refactor a lot of time could be saved by temporarily interpreting the 'move caret to next/previous word' key combinations as a jump to the next part of the camelcase/snakecase name. Especially with long constructed names this will remove a lot of friction.

I know there is 'move caret to next word in different camelhumps mode' action, but it is not mapped to a key combination by default, and movement of the caret is limited to the word anyway.","0"
"IDEA-224156","IntelliJ IDEA","","""Unwrap 'else'"" should insert return/break/continue to avoid changing semantics","Pr0methean","03/10/2019 16:25","14/12/2021 02:55",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Create a Java program such as the following:
```
public class Main {
  public static void main(String[] args) {
    int a = 0;
    for (int i = 0; i < 10; i++) {
      if (a > 40) {
        a -= i;
      } else {
        a += i;
      }
    }
  }
}
```
2. Move the cursor to the else and press Alt-Enter.

What is the expected result?

One of the suggested actions is ""Unwrap 'else' branch."" To avoid changing the semantics, applying this action inserts a `continue` statement at the end of the `if` branch.

What happens instead?

The suggested action is  ""Unwrap 'else' branch (changes semantics)"" and does not insert `continue`.

Inserting one statement can also avoid changing the semantics if the else branch continues to the end of the parent block, and the parent block is one of:
* A void method or a constructor (insert `return`)
* if, else, or switch (insert `break`)
* a for, while or do-while loop (insert `continue`)
* a try or finally block, where the try-catch-finally construction extends to the end of its own parent, and that parent is something on this list.","1"
"IDEA-249070","IntelliJ IDEA","","Move declaration closer to usages missed opportunity","Dave Yost","25/08/2020 22:01","29/11/2021 11:51",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","“Move declaration closer to usages” is offered on the first `chg` but not the second.
![](image.png)

IU-202.6948.5, JRE 11.0.8+10-b944.31x64 JetBrains s.r.o., OS Mac OS X(x86_64) v10.15.6, screens 3200x1800; Retina","0"
"IDEA-155505","IntelliJ IDEA","","Collect suggestions from assigned expression when renaming a class field","Dmitry Cherniachenko","02/05/2016 12:36","24/11/2021 16:53",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When launching Rename refactoring for either of <code class=""inline-code"">time</code> in the code below IDEA does not put <code class=""inline-code"">timeMillis</code> &amp; Co. on the suggestions list.<br/>This however would have been very useful (just like it is for local variables).<br/><br/><pre class=""wikicode prettyprint"">public MyClass() {<br/>    this.time = System.currentTimeMillis();<br/>}<br/><br/>public void setTime(long timeMillis) {<br/>    this.time = timeMillis;<br/>}</pre></div>
","1"
"IDEA-269277","IntelliJ IDEA","","Migrate process can apply package rename twice","Vladimir Kravets","13/05/2021 16:16","24/11/2021 05:17",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","***What steps will reproduce the issue?***

1. Create migrate confiuration for RxJava (2.x -\> 3.x)
2. Add new pakckage migration: io.reactivex -\> io.reactivex.rxjava3
3. Run Migration
4. Run Migration again

***What is the expected result?***
Already changes lines will not be touched

***What happens instead?***
&nbsp;import io.reactivex.rxjava3.rxjava3.SingleTransformer

I think need to add except strict sting detection  may be regexp will more prefered here and resolve this issue... as one of solution","0"
"IDEA-282994","IntelliJ IDEA","","""Extract variable"" gets confused, declares the new variable before input is initialized","Aleksey Ratushny","19/11/2021 18:55","23/11/2021 17:13",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Given code:
```
    public static void main(String[] args) {
        final String s;

        {
            s = ""Foo"";

            final int l1 = s.length();
        }

        {
            final int l2 = s.length();
        }
    }
```
Select `s.length();` and ctrl-v (""extract variable""), select ""Replace all 2 occurrences""

Actual result (doesnt compile):
```
    public static void main(String[] args) {
        final String s;

        final int length = s.length();
        {
            s = ""Foo"";

            final int l1 = length;
        }

        {
            final int l2 = length;
        }
    }
```

Expected result:
```
    public static void main(String[] args) {
        final String s;

        final int length;
        {
            s = ""Foo"";
            length = s.length();
            final int l1 = length;
        }

        {
            final int l2 = length;
        }
    }
```","0"
"IDEA-282685","IntelliJ IDEA","","Exceptions are hidden in change signature dialog","Bart van Helvert","16/11/2021 12:40","17/11/2021 06:05",,"Normal","Bug",,"Vassiliy.Kudryashov","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Exceptions aren't shown in the change signature dialog.
![](image.png)
When focusing on the list element the exception shows correctly.
![](image1.png)

Invoked on: 
```Java
<T> void foo(String foo) throws IllegalArgumentException {}
```","0"
"IDEA-58725","IntelliJ IDEA","","Refactoring: Move to other module","Johannes Schneider","15/09/2010 08:03","08/11/2021 09:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have several multi module projects. And often I want to move some classes from module to another one.<br/>But nearly all the time I have source files, test files and resources.<br/>Therefore I have to make 4 move refactorings manually. This takes a lot of time and is very error prone.<br/><br/>So I&#39;d like to see a move to other module refactoring that keeps the source folders.<br/><br/>Example (based on maven layout)<br/><br/>mod1 depends on mod2<br/>Now I want to move those classes from mod2 to mod1:<br/><br/>mod2/src/main/java/Foo<br/>mod2/src/test/java/FooTest<br/>mod2/src/main/resources/FooResource.txt<br/>mod2/src/test/resources/FooTestResource.txt<br/><br/>those should result into:<br/><br/>mod1/src/main/java/Foo<br/>mod1/src/test/java/FooTest<br/>mod1/src/main/resources/FooResource.txt<br/>mod1/src/test/resources/FooTestResource.txt<br/><br/><br/>What seems to be an easy task, becomes quite complicated using the move refactoring...</div>
","1"
"IDEA-234570","IntelliJ IDEA","","""Introduce Constant""  fail with long string and ensure right margin option enabled","Michael Ward","05/03/2020 00:32","29/10/2021 05:08",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I have a very long string constant being passed into a method as an argument
For example:
`someMethod(""aaaaaaaaa..."")` but with many more `a`'s
If I were to format this, intelliJ would split this string into multiple lines, as expected.

But if I want to pull this long string out into a constant (by right clicking it, Refactor -> Introduce Constant), it will let me name the constant but stop there, and instead will just break the string over multiple lines in the same way that formatting the document would.

This doesn't just happen with `Introduce Constant`, but also `Introduce Variable` and `Introduce Field` as well.

I would expect that it would create the variable / field / constant. The formatting could still happen but not until after it has actually performed the action I have selected.

IU-193.6015.39, JRE 11.0.5+10-b520.30x64 JetBrains s.r.o, OS Mac OS X(x86_64) v10.15.1, screens 3008x1692, 1680x1050; Retina","0"
"IDEA-281136","IntelliJ IDEA","","Safe delete in a big project often doesn't suggest to delete properties which become unused","Nikolay Chashnikov","25/10/2021 07:23","28/10/2021 08:22",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111), 2021.2 (212.4746.92), 2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","In a big project (like intellij) 'Safe delete' for a method often doesn't suggest to delete properties which were used from the deleted methods only. It happens because it uses `PsiSearchHelper::isCheapEnoughToSearch` method to determine whether it should search for usages of a property, and it often returns `false` because of big text files which mentions all words from the property key.","0"
"IDEA-281085","IntelliJ IDEA","","Move inner class to upper level changes the annotations formatting","momomo","24/10/2021 02:07","28/10/2021 08:03",,"Normal","Bug",,"anet","Java. Refactorings","2021.2 (212.4746.92), 2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Related ticket, similar issues, but there related to moving classes out and getting this behaviour: 

<https://youtrack.jetbrains.com/issue/IDEA-281075>

If you spend time on your code to format it the way you want then you refactor it, often times intellij will reformat and destroy your custom formatting. 

I do not care much for auto indentation or formatting as non of them are good enough ways to optimately structure code. 

See video to see what the problem is this time. 

![](Screen Recording 2021-10-24 at 07.01.54.mov)","0"
"IDEABKL-3561","IntelliJ IDEA: Backlog","","Refactoring ""Rename"" optimizes import allways","Carsten Manshusen","11/08/2005 09:54","19/10/2021 12:40",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Open",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Renaming an object with the &quot;Rename&quot;-Refactoring allways optimizes the imports. The corresponding editor setting for imports are ignored.<br/><br/>Environment: Windows 2000/XP</div>
","6"
"IDEA-199599","IntelliJ IDEA","","Incorrect style after extracting a variable","Egor Ryashin","27/09/2018 11:18","19/10/2021 10:43",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2018.3 (183.4284.148)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","After extracting a variable from a line which exceeds the limit, the original line got broken redundantly.

Version 2016.3.4","0"
"IDEA-119502","IntelliJ IDEA","","Keep imports sorted when moving an imported member to another package","Dennis Homann","16/01/2014 16:47","30/09/2021 08:28",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When moving a class to another package, all imports for that class will be out of order, because only the import line itself is changed and it is not moved to the new &quot;correct&quot; location.<br/>Maybe a new option is needed to force sorted imports.</div>
","3"
"IDEA-164078","IntelliJ IDEA","","Reverse refactor of the Introduce Parameter refactor","Derrill Dabkoski","16/11/2016 22:39","16/09/2021 08:21",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am requesting a Refactor feature that lets me push an expression into a method, introducing new parameter(s) and deleting the old parameter.  It is essentially, the opposite of the Introduce Parameter refactor.<br/><br/>E.g.:<br/><br/>foo(x+y);  // my function call<br/>void foo(int p) {<br/>// body<br/>}<br/><br/>I would select the expression &quot;x + y&quot; and &quot;Push Expression into Method&quot; resulting in:<br/><br/>void foo(int x, int y) {<br/>   int p = x + y;<br/>  // body<br/>}<br/><br/>The reason this is a reverse of Introduce Parameter is because if I &quot;Introduced Parameter&quot; on the variable p, it would return to the original above.<br/><br/>Thanks<br/><br/>Filing this because Anna Kozlova said in the forum I should file a bug:<br/><a href=""https://intellij-support.jetbrains.com/hc/en-us/community/posts/205971404-Exists-a-reverse-refactor-of-the-Introduce-Parameter-refactor-?flash_digest=2c466e8dc8b50c87416c4b526ef4de82430fd2c4&amp;page=1"" target=""_blank"" rel=""noopener noreferrer"">https://intellij-support.jetbrains.com/hc/en-us/community/posts/205971404-Exists-a-reverse-refactor-of-the-Introduce-Parameter-refactor-?flash_digest=2c466e8dc8b50c87416c4b526ef4de82430fd2c4&page=1</a></div>
","1"
"IDEA-277920","IntelliJ IDEA","","Introduce parameter: add option to declare parameter type as vararg when selecting multiple expressions of same type","Kirill Smelov","10/09/2021 06:35","10/09/2021 08:00",,"Normal","Feature",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","It'll be convenient to have `PhpDfaBasedTypeState...` as type option
![](Screen Shot 2021-09-10 at 12.34.23.png)","0"
"IDEA-277418","IntelliJ IDEA","","Action to splice a block of code into two valid blocks","Trejkaz","03/09/2021 00:07","03/09/2021 04:20",,"Normal","Feature",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","The behaviour I would like is:

* Given I am in a block of code
* When I execute the ""Splice Code Block"" action
* Then there are now valid two blocks of code

Specific scenarios:

1\. If I am in a block ( `|` representing the caret position):

```
class A {
    void method() {
        while (true) {
            above();
            |
            below();
        }
    }
}
```

There is a ""Splice Code Block"" or ""Splice Block"" action which does this:

```
class A {
    void method() {
        while (true) {
            above();
        }
        |
        while (true) {
            below();
        }
    }
}
```

2\. In the case of being inside a method or function:

```
class A {
    void method() {
        above();
        |
        below();
    }
}
```

Then I get this ( `[` and `]` now representing the selection:

```
class A {
    void method() {
        above();
    }
    
    void [method2]() {
        below();
    }
}
```

Actually it might be better if it selected [method1] and then lets me tab to [method2] after completing the first name?

3\. In the case of being inside a type:

```
interface A {
    void methodAbove();
    |
    void methodBelow();
}
```

It could perhaps end up with:

```
interface A {
    void methodAbove();
}

interface [A2] {
    void methodBelow();
}
```

But honestly the case of splitting a class or interface rarely comes up so it could just be that it only works on methods/functions/blocks.



Currently this is a manual process which happens quite a lot while fixing code written by others.

For methods, frequently the issue is not that I want to extract a method, but rather that one method is doing two entirely different things and should be two completely unrelated methods. I can currently do ""Extract Method"" twice (once for the above and once for the below blocks) and then delete the method, to get roughly the same result.

For blocks, I don't think there is a sensible way to do it using current IDEA refactorings but maybe it's possible using some combination of extracting methods and then inlining them again…


","0"
"IDEA-276198","IntelliJ IDEA","","Change signature: applying the refactoring doesn't warn about possible compilation error","Ilyas Selimov","17/08/2021 08:33","17/08/2021 10:06",,"Normal","Bug",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Consider:

```
class Clazz {
    public static void main(String[] args) {
        I i = x -> System.out.println(x);
    }
}

interface I {
    void <caret>execute(int i);
}
```



1. Choose ""Change signature"" refactoring

2. Delete `i` parameter

3. Apply the refactoring

4. The code becomes broken:

   ```
   I i = () -> System.out.println(x); // red code is here
   ```

Possibly we may suggest a conflict window in this case to prevent the compilation error?","0"
"IDEA-275602","IntelliJ IDEA","","Convert to instance method silently introduces infinite recursion","Tagir Valeev","09/08/2021 04:16","09/08/2021 04:29",,"Normal","Bug",,"anet","Java. Refactorings","2021.3 (213.5744.223)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Code:

```java
public class Test {
  void run() {}

  static Test getDelegate(Test test) {
    return new Test() {
      @Override
      void run() {
        test.run();
      }
    };
  }
}
```

Invoke refactoring ""Convert to instance method"" on `getDelegate`, bind `this` to parameter. Result:

```java
public class Test {
  Test getDelegate() {
    return new Test() {
      @Override
      void run() {
        run(); // infinite recursion
      }
    };
  }

  void run() {}

}
```
The resulting code is broken. Something like this could fix the problem:

```java
public class Test {
  Test getDelegate() {
    Test test = this;
    return new Test() {
      @Override
      void run() {
        test.run();
      }
    };
  }

  void run() {}

}
```

Well, at the very least if code is going to be broken, a conflict should be displayed.

IntelliJ IDEA 2021.3 EAP (Ultimate Edition)
Build #IU-213.1915, built on August 4, 2021
IntelliJ IDEA EAP User
Expiration date: September 3, 2021
Runtime version: 11.0.11+9-b1584.1 amd64
VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o.
Windows 10 10.0
GC: G1 Young Generation, G1 Old Generation
Memory: 4096M
Cores: 8
Registry: ide.projectView.PackageViewTreeStructure.BuildChildrenInBackground=true, analyze.exceptions.on.the.fly=true, completion.show.intention.icon=false, vcs.force.non.modal.commit=true, vcs.log.index.limit.minutes=200, compiler.process.debug.port=5005, editor.adjust.right.margin=true, idea.batch.inspections.injected.psi.option=true, vcs.code.analysis.before.checkin.show.only.new.threshold=0, twooh.userid=16ee6c57-3e18-4058-ac29-b0b5bbfee9ba
Non-Bundled Plugins: org.nik.presentation-assistant (1.0.9), one.util.ideaplugin.screenshoter (1.7), com.jetbrains.idea.safepush (213.1915), com.intellij.sisyphus (213.1915), jetbrains.team.auth (213.1915), Jetbrains TeamCity Plugin (2021.1.98821), com.jetbrains.recommenders.twooh (0.0.54-super-early-bird), com.jetbrains.intellij.api.watcher (6.55.0)
Kotlin: 213-1.5.10-release-IJ1915","0"
"IDEA-274454","IntelliJ IDEA","","Unable to show folder entry after moving the java class in the Packages view","Lejia Chen","27/07/2021 01:48","28/07/2021 10:38",,"Normal","Bug",,"anet","Java. Refactorings","2021.2 (212.4746.92), 2021.3 (213.5744.223)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Steps (see the attached video for details):

1. Create a sample java project or using the attached sample.
2. Switch to the Package view.
3. Select a Java file and choose Refactor | Move class, choose the ""To package"", select a parent folder in the current folder as a new package destination.
4. Click refactor.

Result:
![](image1.png)
The new moved class is not shown in ""Package"" view.
Though I can see the class has moved to the new package if I choose the ""Project"" view.
Reload the disk not helps.

![](Screen Capture_jetbrains-idea_20210727124434.mp4)","0"
"IDEA-152899","IntelliJ IDEA","","Allow empty ""default value"" column for ""Change Class Signature"" refactoring","Timur Yuldashev","11/03/2016 11:13","19/07/2021 11:52",,"Normal","Bug",,"anet","Java. Refactorings","2021.2 (212.4746.92)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Copy of <a href=""/issue/IDEA-21728"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-60864"" title=""Allow empty &quot;default value&quot; column for &quot;Change Class Signature&quot; refactoring"">IDEA-21728</a>, but as it&#39;s closed ages ago, decided to open new one.<br/><br/>Even there is no any usages of the class it asks to specify default value. Furthermore it complains when user enters <em>1</em>, but allows to refactor when enters <em>blah_blah_blah</em> or some other non meaningful literal.<br/><br/>If needed we may do this verification (if empty should be allowed) when user clicks &#39;Refactor&#39; button and show Conflict dialog with Continue, Cancel options.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-143848","IntelliJ IDEA","","New refactoring - smarter changing a method signature","Pawel Bartoszek","12/08/2015 18:59","19/07/2021 11:48",,"Normal","Feature",,"anet","Java. Refactorings","2021.2 (212.4746.92)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Adding a new parameter to existing method via hints works flawlessly(see add_parameter_existing.png). Having said that, I really miss this hint also when adding a parameter directly in a method signature. Currently I need to open &quot;Change signature&quot; dialog, which make whole refactoring much slower. Please see add_parameter_proposal.png for my suggestion of adding a hint in a new context. </div>
","0"
"IDEA-273504","IntelliJ IDEA","","Renaming class with a single capital letter prefix suggests renaming its usage variables to a non camel case name by default","Hesham Saleh","11/07/2021 03:35","12/07/2021 10:07",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.1.3 (211.7628.21)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Steps to reproduce the issue:**

1. Start renaming a class to prefix it with a single capital character with  (e.g. ClassA -\> QClassA)
2. Dialog appears suggesting renaming other variables of this class (e.g. ClassA classA; -\> ClassA QClassA;)

**Expected result:**

Suggested new variable names to follow the camel case naming convention.

**Actual result:**

Suggested new variable names doesn't follow the camel case naming convention.

IU-211.7628.21, JRE 11.0.11+9-b1341.60x64 JetBrains s.r.o., OS Mac OS X(x86_64) v11.4, screens 900.0x1600.0, 3840.0x1600.0, 3584.0x2240.0; Retina","0"
"IDEA-217232","IntelliJ IDEA","resource-bundle","file rename window picks wrong file in resource bundle","Dmitriy Kuleshov","28/06/2019 18:05","12/07/2021 05:59",,"Normal","Bug",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-192.5438.14, JRE 11.0.3 12-b304.2x64 JetBrains s.r.o, OS Linux(amd64) v4.15.0-54-generic, screens 1920x1080","0"
"IDEA-205939","IntelliJ IDEA","","Auto Camel Case on rename","Philip Buhr","23/01/2019 17:03","12/07/2021 05:07",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","As a user, 
When renaming members I want to be able to type, separating the individual words with spaces. On pressing enter or leaving the renaming state, the words should be concatenated and transformed  into Camel Cases (Java).
This adds comfort in renaming long method names.
Example:
// while in rename mode
public void some method name() 
// leaving rename mode
public void someMethodName()

Would also apply when generating new test methods.","0"
"IDEA-60803","IntelliJ IDEA","","Bug unlocking files for editing","Serge Baranov","04/11/2010 17:48","09/07/2021 07:49",,"Normal","Bug",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Support feedback:<br/><br/><br/>Imagine a file with this line of code:<br/><br/>JButton cancelButton = new JButton(&quot;Cancel&quot;));<br/><br/>I get a &quot;Hard Coded String&quot; warning on the String. So when I click inside this String, I have two ways to put it into the resource file. I can hit Alt-enter, to bring up a list of intentions, and choose the &quot;I18nize hard coded String literal&quot; option, or I can choose &quot;Internationalize&quot; from the Refactor menu. (The properties file exists, and already has lots of Strings.)<br/><br/>So far, everything is fine.<br/><br/>I&#39;m using Perforce, and the files are write-locked because I haven&#39;t checked them out. Here&#39;s where the bug shows up:<br/><br/>The properties file already has a property for &quot;Cancel&quot;, so when I internationalize this line, it doesn&#39;t change the properties file, it just changes this file. <br/><br/>In fact, the properties files is locked, so I can&#39;t change it without unlocking it. But I don&#39;t do this, because it doesn&#39;t need to change.<br/><br/>And when I choose &quot;I18nize Hard Coded String Literal&quot; from the Intentions pop-up menu, it doesn&#39;t ask me to unlock (and check-out) the properties file.<br/><br/>But (and here&#39;s the bug) If I choose Internationalize from the Refactor menu, it asks me to unlock the properties file.<br/><br/>It shouldn&#39;t do that. It should just make the change in my source file and not attempt to unlock the properties file.<br/><br/>&mdash;<br/>OS: Linux<br/>JDK: JDK 1.6.0 64-bit<br/>IDEA: 9.0<br/>Build: #IU-95.429</div>
","0"
"IDEA-12170","IntelliJ IDEA","","Allow the ""renaming"" refactoring on properties to also change related properties","Thibaut","29/03/2007 19:56","09/07/2021 07:48",,"Normal","Feature",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">ex :<br/><br/>log4j.appender.console=org.apache.log4j.ConsoleAppender<br/>log4j.appender.console.immediateFlush=true<br/>log4j.appender.console.target=System.out<br/>log4j.appender.console.layout=org.apache.log4j.PatternLayout<br/>log4j.appender.console.layout.conversionPattern=%c;%p;%t;%d;%m%n<br/><br/><br/><br/>If I decide to rename the property &quot;log4j.appender.console&quot; to &quot;log4j.appender.myAppender&quot;  it does not rename all the following ones.<br/><br/>It could allow enlarging the scope of the renaming, probably best achieved using the confirmation window</div>
","1"
"IDEA-35191","IntelliJ IDEA","","Refactor | Internationalize: for not imported classes it is necessary to use alt+enter twice: in dialog and in editor","Alexander Chernikov","02/11/2006 12:29","09/07/2021 07:48",,"Normal","Usability Problem",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Get any java source with hardcoded string literal. Invoke Refactor | i18n. In dialog type any expression with not yet imported class. E.g. ResourceBundle.getBundle(&quot;bundle.id&quot;). &quot;ResourceBundle&quot; is highlighted as not yet imported. Alt+Enter to import - all is Ok.<br/>Press Ok in dialog. I18n is done, but ResourceBundle is highlighted in source editor again. User has to Alt+Enter again.<br/><br/>Probably import statement should be inserted to source without questions if user already specified the class in the dialog.</div>
","0"
"IDEA-35076","IntelliJ IDEA","","Refactor | Internationalize: accept user's choice of existing key","Alexander Chernikov","31/10/2006 13:12","09/07/2021 07:48",,"Normal","Usability Problem",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Refactor | Internationalize: dialog does not allow user to select existing property key. On attempt to enter it, the message like &quot;the key is exists&quot; is just output.<br/>Is this limitation really needed? A number of common texts like &quot;New&quot;, &quot;Paste&quot; or, say, copyright statement can be used in several places in code. Would be nice to allow user to select existing key.</div>
","0"
"IDEA-35117","IntelliJ IDEA","resource-bundle","Refactor | Internationalize: suggest ResourceBundle.getBundle(""*"") expression if properties bundle is selected","Alexander Chernikov","27/10/2006 09:54","09/07/2021 07:48",,"Normal","Usability Problem",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Refactor | Internationalize searches for existing resourceBundle expressions in code and shows only red &quot;resourceBundle&quot; in dialog if nothing is found. But if Properties file field has a value, then one expression always can be suggested: <pre class=""wikicode prettyprint""> ResourceBundle.getBundle(&quot;properties.bundle.path&quot;) </pre>. Suggest it, please. Otherwise user has to type it every time manually.<br/><br/>The expression could be also updated in case of changes in Properties file field.</div>
","1"
"IDEA-39072","IntelliJ IDEA","resource-bundle","Refactor / Rename, Move properties resource bundle: handle references to the bundle in ResourceBundle methods","Alexander Chernikov","08/06/2007 07:24","07/07/2021 10:03",,"Normal","Feature",,"nikita.eshkeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Get a java module, packages pack and qack, properties file pack/pack.properties, class pack.Some with source:<br/><pre class=""wikicode prettyprint"">package pack;<br/><br/>import java.util.ResourceBundle;<br/><br/>public class Some {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>private static final String CONST = ResourceBundle.getBundle(&quot;pack/pack&quot;).getString(&quot;val&quot;);<br/>}</pre><br/>Refactor / Rename pack/pack.properties to pack/pack2.properties. Or Refactor / Move pack/pack.properties to qack/pack.properties. In all listed cases getBundle() argument is not updated. IDEA could update it.<br/>Would be also nice to have the same for a string variable (constant), which value is used in getBundle().</div>
","1"
"IDEA-271286","IntelliJ IDEA","","Java refactoring gone error","momomo","10/06/2021 05:08","10/06/2021 14:01",,"Normal","Bug",,"anet","Java. Refactorings","2021.2 (212.4746.92)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","See video. 




","0"
"IDEA-270870","IntelliJ IDEA","javadoc","Moving a class referenced in Javadoc @link tag changes fully qualified name to an import","M. Justin","04/06/2021 13:22","07/06/2021 12:03",,"Normal","Bug",,"anet","Java. Refactorings","2021.2 (212.4746.92)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Renaming a class that's linked using the `@link` Javadoc tag switches the reference from a fully qualified name to an import, even if the ""Use fully qualified class names in JavaDoc"" setting is set to ""If not already imported"".

This has caused build failures for me on multiple occasions when built using my build tool outside of IDEA, as my [Checkstyle](https://checkstyle.sourceforge.io) rules are configured to disallow imports unless they're used within the code, and not just within the Javadoc.

**Steps to reproduce the issue:**

1. Ensure ""Use fully qualified class names in JavaDoc"" setting is set to ""If not already imported"" in Editor =\> Code Style =\> Java
2. Reference another project class in a `@link` tag using the fully qualified name without any other references in the file
3. Move the referenced class
4. The JavaDoc reference changes from a fully qualified class name to an import

```java
package com.example;

/**
 * Fully qualified reference: {@link com.example.nested.ReferencedClass}.
 */
public class ClassWithJavadoc {
}
```

```java
package com.example.nested;

public class ReferencedClass {
}
```

Rename `ReferencedClass` =\> `RenamedClass` using Refactor =\> Rename.

**Expected result:**

```java
package com.example;

/**
 * Fully qualified reference: {@link com.example.nested.RenamedClass}.
 */
public class ClassWithJavadoc {
}
```

**Actual result:**

```java
package com.example;

import com.example.nested.RenamedClass;

/**
 * Fully qualified reference: {@link RenamedClass}.
 */
public class ClassWithJavadoc {
}
```

IntelliJ IDEA 2021.1.2 (Ultimate Edition)
Build #IU-211.7442.40
Runtime version: 11.0.11+9-b1341.57 x86_64
VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o","0"
"IDEA-78801","IntelliJ IDEA","","Simplify expressions after inline","Alexander Kirillin","12/12/2011 15:42","02/06/2021 04:01",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    int x = 1, y = 2;<br/>    boolean b1 = !(x&gt;y);<br/>    boolean b2 = !b1;</pre><br/>Try to inline b1 and get:<br/><br/><pre class=""wikicode prettyprint"">    int x = 1, y = 2;<br/>    boolean b2 = !!(x&gt;y);</pre></div>
","6"
"IDEA-258844","IntelliJ IDEA","","Wrong order of method parameter annotations vs. final modifier","Vojtěch Hora","04/01/2021 10:24","27/04/2021 08:27",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I'm using final keyword on method parameters where possible and I have configured @NonNull and @Nullable annotations.

When creating method automatically using Refactor - Extract method, IDEA correctly generates both final modifer (where applicable) and the annotation,
but I think it's generated in wrong order first `final` and then `annotation`, eg:
```java
/** Please do not try to find any sense of this method. */
@NonNull
String bigDecimalToString(final @NonNull BigDecimal bigDecimal) {
    return bigDecimal.toString();
}
```

I think there should be a setting on this (but I couldn't find any), or the default order should be `annotation` and then `final`, like this:
```java
/** Please do not try to find any sense of this method. */
@NonNull
String bigDecimalToString(@NonNull final BigDecimal bigDecimal) {
    return bigDecimal.toString();
}
```

It's quite similar to method or field declarations, which are already covered in Google Java Style Guide: https://google.github.io/styleguide/javaguide.html#s4.8.5-annotations.

As far as I can tell, there is still no convention on method parameter annotations, I searched Oracle Java conventions, Goole, and Apache conventions.

On my projects, I ended up using modifier final and annotations @NonNull or @Nullable almost with all method parameters, because it makes the code more error-prone.

Thank you for looking into this.

Cheers

IU-203.6682.168, JRE 11.0.9.1+11-b1145.63x64 JetBrains s.r.o., OS Windows 10(amd64) v10.0 , screens 1920.0x1080.0","10"
"IDEA-247727","IntelliJ IDEA","","Java refactoring totally broken in too many cases to actually document","momomo","07/08/2020 03:15","23/04/2021 15:34",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I am not going to list all of the cases where Intellij refactoring BREAKS our code, over and over again, almost on a daily basis. 

The cases are too many, but you need to know in case you are living in a fantasy. We've reported on a number of cases but this is not our job. 

There is nothing typesafe about refactoring in Intellij, not even in Java. Javascript refactoring failures has also been reported earlier. 

We might start using this space to list them one by one as they occur, but I doubt it. Takes too much time. This happens almost on a daily basis, where manual fix and check has to be applied afterwards. 

Yesterday Intellij refactored a lombok @Setter annotation because I had an interface named Setter renamed. They are not even connected. 

Moving classes breaks code in about 3 cases.

Intellij really adopted its name and tried to be intelligent and failed. It should not be intelligent. It should just be doing safe shit, that is 100% guaranteed. 

It doesnt help that Intellij also won't show errors unless you open the files so you detect shit many times way too late. 

Eclipse not far away now. Stop using Groovy. Kotlin does not seem to have made your code base more stable either. It is getting worse by the year.","0"
"IDEA-267364","IntelliJ IDEA","","Moving classes from one module works fine, and issues warnings where there are issues, moving packages does not. Leads to big issues.","momomo","19/04/2021 07:50","23/04/2021 04:48",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Try it. 

Moving a class: 
![](image.png)


Moving the package containing the class, yields nothing for this nor for any other class contained within.","0"
"IDEA-266537","IntelliJ IDEA","","Intellij, extract to parameter, field, etc. Prefer supertype, say CharSequence over String","momomo","11/04/2021 06:48","13/04/2021 16:36",,"Normal","Feature",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When you extract a ""aaaa"" say in a method, intellij will automatically, always generate a String parameter, whereas for all my parameters i no longer use String, and always almost CharSequence. 

So this gets kind of tedious and PRONE TO ERROR / INTENTION ... that i always get a String when I then need to manually change this to a  CharSequence. 

Is there, or should there not be a way to extract to a specific type? 

See video. It contains specific example.","0"
"IDEA-110154","IntelliJ IDEA","","When I move the comment down (structurally), it becomes sticked to the declaration and vice versa","Alexander Kirillin","05/07/2013 10:46","11/04/2021 09:08",,"Normal","Bug",,"basleijdekkers","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">//Comment to move down<br/><br/>void foo() {<br/>}</pre><br/>Becomes:<br/><pre class=""wikicode prettyprint"">//Comment to move down<br/>void foo() {<br/>}</pre><br/>After this, the comment and the function are moved together.</div>
","2"
"IDEA-263921","IntelliJ IDEA","","Inline introduce constant refactoring clears selection if any of the options are ticked","Alexey Yudichev","09/03/2021 14:46","10/03/2021 05:28",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**

1. Select a string constant in code that occurs more than once
2. Invoke introduce constant refactoring. The name of the constant is suggested and is selected in the editor.
3. Press Alt+A to check ""Apply to all"" box

**What is the expected result?**
The name of the constant is still selected

**What happens instead?**
The name of the constant loses selection, which is annoying.

IntelliJ IDEA 2021.1 Beta (Ultimate Edition)
Build #IU-211.6305.21, built on March 4, 2021
IntelliJ IDEA EAP User
Expiration date: April 3, 2021
Runtime version: 11.0.10+9-b1341.18 amd64
VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o.
Windows 7 6.1
GC: ParNew, ConcurrentMarkSweep
Memory: 8042M
Cores: 24
Registry: debugger.click.disable.breakpoints=true, analyze.exceptions.on.the.fly=true
Non-Bundled Plugins: com.ppolivka.plugin.gitcleaner (1.1.4), zielu.gittoolbox (203.4.8), GrepConsole (11.6.211.6085.0), Jetbrains TeamCity Plugin (2020.2.85899), YourKit Java Profiler 2018.04-b88 Integration (2018.4.88.0), ru.artyushov (1.2.0)
Kotlin: 211-1.4.21-release-IJ6305.1","0"
"IDEA-262872","IntelliJ IDEA","","Suggest variants without prefix at field rename","AndroidDeveloperLB","24/02/2021 11:20","25/02/2021 01:55",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**

1. Just have a class like this, and choose to rename the field mFirstName:

```
public class ContactObject {
    String mFirstName;
    String mLastName;
}
```

**What is the expected result?**
The first option (or at least one of the first ones) should be ""firstName"".

**What happens instead?**
It doesn't even get offered. 
Even worse. I get all impossibly weird options:
1. First option is ""string"", which should be probably the last...
2. Second option is ""mfirstname"" which isn't common at all for fields.
3. Third option is identical to the original name, which is very useless: ""mFirstName"" ...

And, that's it. No other variant is offered. Not even ""name"" or ""mName"", or ""first"" or ""mFirst""....

On Kotlin, it's a bit better :

```
class ContactObject {
    var mFirstName: String? = null
    var mLastName: String? = null
}
```

The options that are offered:
1. First one is identical to the original, completely useless: ""mFirstName""
2.  Second one is ""firstName"", which is what I expected
3. Third one is ""name"", which I guess is ok.
4. The last one is just ""s"" for some reason.

Android Studio 4.1.2
Build #AI-201.8743.12.41.7042882, built on December 20, 2020
Runtime version: 1.8.0_242-release-1644-b01 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0
GC: ParNew, ConcurrentMarkSweep
Memory: 3916M
Cores: 12
Registry: ide.new.welcome.screen.force=true, external.system.auto.import.disabled=true, debugger.watches.in.variables=false
Non-Bundled Plugins: Show As ..., String Manipulation, com.dubreuia, org.intellij.plugins.markdown, com.intellij.marketplace, org.jetbrains.kotlin, com.google.mad-scorecard","0"
"IDEA-75334","IntelliJ IDEA","","Preselect name without a prefix in rename dialog if name matching code style prefix","Alexey Pegov","10/10/2011 05:36","25/02/2021 01:53",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">see attached screenshots.</div>
","2"
"IDEA-262586","IntelliJ IDEA","","Extract method forget to add 'static' when keep original method signature","Timur Yuldashev","20/02/2021 08:01","20/02/2021 08:01",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-211.6085.23

```
public class ExtractStaticMethod {
    static boolean compare(int a, int b) {
        // selection start
        if (a == b) return true;
        else return false;
        // selection end
    }

    static boolean condition(boolean b) {
        if (b) return true;
        else return false;
    }
}
```

 * Use code above to reproduce the issue
 * Select two marked lines from the first method and invoke `Extract Method` refactoring
 * Proceed with refactoring - IDEA suggests to change signature to extract code from the second method - instead `Keep original signature` - as result instance method created instead of static one, which results in red code.

```
...
    static boolean compare(int a, int b) {
        // selection start
        return extracted(a, b);
        // selection end
    }

    private boolean extracted(int a, int b) {
        if (a == b) return true;
        else return false;
    }
...
```","0"
"IDEA-262320","IntelliJ IDEA","","Annotation is not inserted after Extract Method","Timur Yuldashev","17/02/2021 13:48","17/02/2021 13:48",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-211.6085.1

 * Use attached project to reproduce
 * Open `org.ExtractMethod#calc` method or some other class
 * Extract line `Long timestamp = getaLong();`
 * Even though `Annotation` checkbox is enabled extracted method doesn't have annotation.
 * I could manually add that annotation because the lib is in dependencies of the module.

![](image.png)
![](image1.png)
![](image2.png)","0"
"IDEA-262251","IntelliJ IDEA","","Extract Variable adds unnecessary ""this"" qualifier","Peter Gromov","17/02/2021 05:32","17/02/2021 09:09",,"Normal","Usability Problem",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
class Foo {
  int bar;

  void m() {
    System.out.println(bar);
  }
}
```

Select the usage of `bar`, extract a variable. You'll have `int bar = this.bar;` which is fine. Now change `bar` to `bbb` while the refactoring is still active. The qualifier remains: `int bbb = this.bar;` although it's not necessary, and I have to remove it manually.","0"
"IDEA-155932","IntelliJ IDEA","","""Methods to delegate"" popup should not have already overridden super-methods (as well as static?)","Dmitry Cherniachenko","12/05/2016 08:57","28/01/2021 05:56",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">See the code sample below.<br/>I launched the &quot;Delegate methods&quot; action in the <code class=""inline-code"">ReadOnlyStorage</code> class. I then chose <code class=""inline-code"">delegate</code> as the target and the following popup appeared - see attached screenshot.<br/><br/><code class=""inline-code"">writeValue()</code> method is on the list. But even if I choose it, its implementation won&#39;t be changed - what&#39;s the point to show it then?<br/><code class=""inline-code"">newInstance()</code> method is also on the list. But it is static. IDEA will generate a proper static super-method call for it. But delegating static methods a) makes little sense (the super-method implementation is already visible via sub-class) and b) is error prone.<br/><br/>So I&#39;d say that the list should only show <code class=""inline-code"">readValue()</code> method in this case.<br/>(you could add a &quot;Show static methods&quot; checkbox at the bottom for those who need them).<br/>It will be much easier to figure out which methods are still not delegated.<br/><br/><pre class=""wikicode prettyprint"">public class Storage<br/>{<br/>    private String value;<br/><br/><br/>    public String readValue(String name)<br/>    {<br/>        return value;<br/>    }<br/><br/><br/>    public void writeValue(String name, String value)<br/>    {<br/>        this.value = value;<br/>    }<br/><br/><br/>    public static Storage newInstance(String value)<br/>    {<br/>        Storage d = new Storage();<br/>        d.writeValue(&quot;dummy&quot;, value);<br/>        return d;<br/>    }<br/><br/><br/>    public static class ReadOnlyStorage extends Storage<br/>    {<br/>        private Storage delegate;<br/><br/><br/>        @Override<br/>        public void writeValue(String name, String value)<br/>        {<br/>            // do nothing<br/>        }<br/>    }<br/>}</pre></div>
","0"
"IDEA-259798","IntelliJ IDEA","","Errors in refactoring to method object, as well as a poor approach to what the desired refactored result should be.","momomo","19/01/2021 10:34","20/01/2021 12:52",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","All of it is described in attached video. 6 minutes long. 

Error resulted in using method object ( see super.create()) , as well as almost unusable end result. 

In the video there is a proposed desired result, which could be customized through options using a dialog. 

**Options include: **

1. Require final. 
2. Use getters to access, or use fields directly. 
3. Use constructor for code rather than a separate mode (goes into 1.)","0"
"IDEA-152852","IntelliJ IDEA","","Extract Method Object: incompilable result in case of `this` and moving used method to created class","Alexander Chernikov","10/03/2016 18:21","20/01/2021 12:52",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Shelved","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Dummy Java:<br/><pre class=""wikicode prettyprint"">public class LambdaEmo {<br/>    private int ownField = 2;<br/>    private int ownMethod() { return ownField; }<br/>    public void context() {<br/>        queue(() -&gt; System.out.println(this.ownField + this.ownMethod()));<br/>    }<br/>    public void queue(Runnable runnable) { runnable.run(); }<br/>} </pre><br/>Refactor / Extract Method Object. Apply to the lambda.<br/>Select &quot;Create inner class&quot; option, Ok to go.<br/>Then you are asked do you want to move <code class=""inline-code"">ownMethod()</code> to new created class. Agree.<br/>Resulted code gets <code class=""inline-code"">LambdaEmo.this.ownMethod()</code> reference, but it is invalid, since the method has been moved.<br/>IDEA 145.333, 146.433.</div>
","0"
"IDEA-259103","IntelliJ IDEA","","Replace Select Override and Implement Method dialogs with popups","Alina Mishina","08/01/2021 13:30","08/01/2021 16:54",,"Normal","Task",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Make sure the multiselect works correctly (see Find Class popup).","0"
"IDEA-258283","IntelliJ IDEA","","refactoring ""rename"" should warn about conflicts","Alexey Kudravtsev","21/12/2020 22:06","22/12/2020 18:19",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
  void f() {
    Map<String,String> updated = null;
    new Predicate<List<String>>() {
      @Override
      public boolean test(List<String> events) {
        updated.put(null, null);
        return false;
      }
    };
  }
```
rename ""updated"" to ""events""
result: non-compliable code","0"
"IDEA-258214","IntelliJ IDEA","","Safe delete refactoring doesn't work corrctly for the java file with several classes","Ilyas Selimov","21/12/2020 04:40","22/12/2020 08:22",,"Normal","Bug",,"anet","Java. Refactorings","2021.1 (211.6693.111)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Given two java files:
1. *Main.java*
```
package pack;

import pack.inner.Inner;

public class Main {
    public static void main(String[] args) {
        Inner i;
    }
}
```
2. *Inner.java*
```
package pack.inner;

public class Inner {
}

class Inner2 {
}

```
Performing the safe delete refactoring for the *Inner.java* is not found the corresponding usages in *Main.java* and the code is getting broken.","0"
"IDEA-202375","IntelliJ IDEA","","Better inlining of 'builder' variable","Dmitry Cherniachenko","16/11/2018 10:45","21/12/2020 15:38",,"Normal","Feature",,"anet","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When inlining 'builder' variable in code like this:
```
SectionProviderFilterBuilder builder = new SectionProviderFilterBuilder();
builder.ignore(ignoreSectionProviders).allow(allowSectionProviders);
metadataLoader().setSectionProviderFilter(builder.build());
```

IDEA could have figured out this is actually a builder-like class and correctly replaced it with a chained method call:
```
metadataLoader().setSectionProviderFilter(new SectionProviderFilterBuilder()
        .ignore(ignoreSectionProviders)
        .allow(allowSectionProviders)
        .build());
```","1"
"IDEA-255588","IntelliJ IDEA","","""Extract method"" with default options creates red code in project with no external dependencies","Dmitry Jemerov","17/11/2020 14:43","17/12/2020 14:54",,"Major","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Reopened","2020.3.1","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","- Create a Hello World class in an empty Java project:

```
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(""Hello World"");
    }
}
```

- Select ""Hello World"" constant
- Invoke ""Extract method"" with default options
- Get red code (the NotNull class is unresolved):

```
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(helloWorldMessage());
    }

    @org.jetbrains.annotations.NotNull
    private static String helloWorldMessage() {
        return ""Hello World"";
    }
}
```

The refactoring should not generate any nullability annotations if the project has no dependency on any library which declares such annotations.","1"
"IDEA-258061","IntelliJ IDEA","","""IAE:  Failed requirement"" when opening options of extract method","Timur Yuldashev","17/12/2020 10:02","17/12/2020 10:02",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-203.6682.18

Was testing  IDEA-255352 when got this exception once, then was not able to reproduce.

* I've copied code from related case into `showDialogAdvertisement`
* Pressed `Option-Command-M` to start Extract Method refactoring
* Then clicked on gear icon to open menu and then clicked `More options` link in pop-up n- at that moment exception was thrown and dialog hadn't opened

```stacktrace
java.lang.IllegalArgumentException: Failed requirement.
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer.<init>(CodeFragmentAnalyzer.kt:27)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor.revertAndMapOptions(InplaceMethodExtractor.kt:383)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor.restartInDialog(InplaceMethodExtractor.kt:368)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor$afterTemplateStart$2.invoke(InplaceMethodExtractor.kt:247)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.InplaceMethodExtractor$afterTemplateStart$2.invoke(InplaceMethodExtractor.kt:52)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.ExtractMethodPopupProvider$createPanel$$inlined$panel$lambda$3$1.invoke(ExtractMethodPopupProvider.kt:70)
	at com.intellij.refactoring.extractMethod.newImpl.inplace.ExtractMethodPopupProvider$createPanel$$inlined$panel$lambda$3$1.invoke(ExtractMethodPopupProvider.kt:13)
	at com.intellij.ui.components.ComponentsKt$sam$java_lang_Runnable$0.run(components.kt)
	at com.intellij.ui.components.labels.LinkLabel.lambda$create$0(LinkLabel.java:61)
	at com.intellij.ui.components.labels.LinkLabel.doClick(LinkLabel.java:138)
	at com.intellij.ui.components.labels.LinkLabel.doClick(LinkLabel.java:348)
	at com.intellij.ui.components.labels.LinkLabel$MyMouseHandler.mouseReleased(LinkLabel.java:322)
	at java.desktop/java.awt.Component.processMouseEvent(Component.java:6652)
	at java.desktop/javax.swing.JComponent.processMouseEvent(JComponent.java:3345)
	at java.desktop/java.awt.Component.processEvent(Component.java:6417)
	at java.desktop/java.awt.Container.processEvent(Container.java:2263)
	at java.desktop/java.awt.Component.dispatchEventImpl(Component.java:5027)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2321)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4859)
	at java.desktop/java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4918)
	at java.desktop/java.awt.LightweightDispatcher.processMouseEvent(Container.java:4547)
	at java.desktop/java.awt.LightweightDispatcher.dispatchEvent(Container.java:4488)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2307)
	at java.desktop/java.awt.Window.dispatchEventImpl(Window.java:2780)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4859)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:778)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:727)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:721)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:85)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:95)
	at java.desktop/java.awt.EventQueue$5.run(EventQueue.java:751)
	at java.desktop/java.awt.EventQueue$5.run(EventQueue.java:749)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:85)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:748)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:976)
	at com.intellij.ide.IdeEventQueue.dispatchMouseEvent(IdeEventQueue.java:911)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:840)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$8(IdeEventQueue.java:454)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:773)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$9(IdeEventQueue.java:453)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:822)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:507)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)
```","1"
"IDEA-255384","IntelliJ IDEA","","Inline object with subsequent call doesn't work for records","Tagir Valeev","14/11/2020 02:39","16/12/2020 04:26",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","E.g.:

```java
void test() {
    System.out.println(new Person(""John"", 20).name());
  }

  record Person(String name, int age) {
  }
```

Doesn't work at all. If we add empty compact constructor it produces invalid code:

```java
String name;
System.out.println(name);
```","0"
"IDEA-197533","IntelliJ IDEA","","Move instance method together with a private field","Nikita Sheremet","17/08/2018 13:30","14/12/2020 07:43",,"Normal","Feature",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Look at the code:

```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

@Service
class MyService {
    @Autowired
    private MyComponent myComponent;

    @Autowired
    private MyFactory myFactory;


    public void someMethod() {
        someOtherMethod();
    }

    public void someOtherMethod() {
        myFactory.create();
    }
}

@Component
class MyComponent {

} 

@Component
class MyFactory {
    public void create() {
        
    }
} 
```

What steps will reproduce the issue?
1. Put cursor on `someOtherMethod` and press `f6`
2. select `myComponent` and click refactor
3. Intelli idea complains that: Field MyService#myFactory is private and will not be accessible from method `someOtherMethod()`.
4. click continue

What happens instead?

```
@Component
class MyComponent {
     public void someOtherMethod(MyService myService) {
         myService.myFactory.create();
    } 
}
```
 

What is the expected result?
```
@Component
class MyComponent {
    @Autowired
    private MyFactory myFactory;

     public void someOtherMethod() {
         myFactory.create();
    } 
}
```

The key point here is all classes marked with `@org.springframework.stereotype.Component` or `@org.springframework.stereotype.Service` are singletons and can be easy added.
(not sure, but there should be investigation about other spring annotations, or you can add a list of annotation to IDE settings). You can also check wether constructor with `@Autowired` annotation is present on target class and init field from constructor or even more ask user wether he wants to add this on constructor.

Also do not forget to check wether old field is used in first class in this example `myFactory` is unused in `MyService` and should be deleted after method moving.","0"
"IDEA-182722","IntelliJ IDEA","","Move instance method to a field of outer class","Adam Michalik","27/11/2017 08:17","11/12/2020 15:29",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider the following:<br/><br/><pre class=""wikicode prettyprint"">class Outer {<br/>    private OuterFieldClass outerField;<br/><br/>    class Inner {<br/>        private InnerFieldClass innerField;<br/><br/>        public void myMethod() {}<br/>    }<br/>}</pre><br/>Currently when I want to do the &quot;Move instance method&quot; refactoring on <code class=""inline-code"">myMethod()</code> I have an option to move it to <code class=""inline-code"">innerField</code>. It would be useful to be able to move it to <code class=""inline-code"">outerField</code>, too, especially if <code class=""inline-code"">myMethod</code> does not use any fields/methods of class <code class=""inline-code"">Inner</code>.</div>
","0"
"IDEA-256558","IntelliJ IDEA","","Difficult shortcut for opening inplace refactoring options","Timur Yuldashev","01/12/2020 13:32","08/12/2020 09:04",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","203.5981.155

Recently shortcut to open option during inplace renaming or extracting was changed from `Tab` to `Option-Shift-O`. Which seems significantly more difficult to quickly press than before. As not very experienced Mac user I spent about half-minute before get proper combination pressed (thanks to small font and 'O' letter which together with special keys symbols looks a bit cryptic). 

I think we should find something simpler for the options, for instance pressing the same refactoring shortcut for the second time. Then dialog would come on third press, but as we're not expecting it opened too often that's probably okay.

![](image.png)","0"
"IDEA-257123","IntelliJ IDEA","","Filter out ""copy class"" from ""refactor this""","Alexandr Suhinin","07/12/2020 08:20","07/12/2020 08:20",,"Normal","Usability Problem",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Show ""copy class"" only when caret/selection is on class delcaration.

![](image.png)","0"
"IDEA-257122","IntelliJ IDEA","","Filter out ""change signature"" from ""refactor this""","Alexandr Suhinin","07/12/2020 08:16","07/12/2020 08:17",,"Normal","Usability Problem",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","2021.1","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Options:
- Show change signature only when caret/selection is on method delcaration.
- Remove ""change signature"" completely or show ""got it"" for inplace change signature instead of dialog refactoring.

Sample:
```
public class RefactorThis {
    void test(String s){
        System.out.println(s/*caret or selection*/);
    }
}
```
![](image.png)","0"
"IDEA-188511","IntelliJ IDEA","","Select ""code / all occurrences"" popup position to avoid covering occurrences","Dmitry Cherniachenko","19/03/2018 10:32","06/12/2020 15:52",,"Normal","Usability Problem",,"Sergey_Malenkov","Java. Refactorings","Not specified",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The popup position currently uses a generic strategy. It appears below the caret at the top of the window and above the caret at the bottom.<br/>This is sub-optimal as sometimes the popup covers the occurrences that will be affected by the refactoring.<br/><br/>It would be great to take the occurrences positions into account and prefer the display that covers the least number of them.<br/><br/>Here is an example:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/>See the lingering &#39;e&#39; from &quot;value&quot; in the exception message on the right of the popup.<br/><br/>Shift+F6 was pressed when the caret was between &#39;a&#39; and &#39;l&#39; in &#39;value&#39;. If it was further in the name the &quot;value&quot; in the exception message would have been hidden completely by the popup.<br/><br/>In case both &#39;above&#39; and &#39;below&#39; positions cover some occurrences the following heuristic rules could be used:<br/><ul class=""wiki-list0""><li> prefer keeping &#39;code&#39; occurrence(s) visible at expense of &#39;all&#39; occurrence(s)<br/></li><li> prefer keeping occurrences(s) visible in the code at expense of occurrence(s) in the javadoc or comments<br/></li></ul></div>
","0"
"IDEA-256210","IntelliJ IDEA","","Cast is not added automatically if method rename causes overloading","Tagir Valeev","26/11/2020 01:34","26/11/2020 06:39",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Code:

```java
public class Overloading {
  void print(String string) {
    printObject(string);
  }

  private void printObject(Object obj) {
    System.out.println(obj);
  }
}
```

Rename `printObject` to `print`. The problem view is displayed which is nice:

![](image.png)

However, in this particular case (when we rename the method with a more generic signature than the existing one), we could keep the code semantically correct if we add an explicit cast to use sites. So I expect the following result:

```java
public class Overloading {
  void print(String string) {
    print((Object) string);
  }

  private void print(Object obj) {
    System.out.println(obj);
  }
}
```

While the actual result is the broken code (and `this.` qualifier is added for some reason):

```java
public class Overloading {
  void print(String string) {
    this.print(string);
  }

  private void print(Object obj) {
    System.out.println(obj);
  }
}
```","0"
"IDEA-256088","IntelliJ IDEA","","Unable to 'Extract Field' when caret is placed at 'return' keyworkd","Andrey Turbanov","24/11/2020 12:09","25/11/2020 05:12",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.2 (202.6397.94), 2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
    static Class<?> get() {
        <caret>return Integer.class;
    }
```

Try to invoke 'Extract Field' refactoring

**Expected**
IDEA is able to extract field from expression used with `return`

**Actual**
IDEA is unable to extract field
![](изображение.png)

For example 'Extract Variable' works fine.

PS. YouTrack doesn't allow me to select my IDEA version - 2020.2.3
![](изображение1.png)","0"
"IDEA-255682","IntelliJ IDEA","","Red code after extracting method with option to pass several fields as parameters","Timur Yuldashev","18/11/2020 14:05","18/11/2020 14:05",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-203.5981.20

```
class A {
    int i;
    int j;

    int foo() {
       if (i > 10) return 10;
       if (j > 1) return 12;

        return 0;
    }
}
```

![](image.png)

**Result code**
```
    ...
    private static Integer getInteger(int i) { // j not passed
        if (i > 10) return 10;
        if (j > 1) return 12;
        return null;
    }
```

 * Select both `if` lines in the method `foo()`
 * Invoke extract method and select option `Make static and pass fields`
 * Complete refactoring - only `i` passed to extracted method so code becomes red.

Works fine in 2020.2","0"
"IDEA-254412","IntelliJ IDEA","","After second opening of settings on Enter IDEA should complete extract method refactoring","Timur Yuldashev","02/11/2020 12:37","02/11/2020 12:37",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IC-211.658

 * Select some string for example and invoke inplace `Extract method` refactoring
 * `Tab` to open settings popup
 * `Esc` to close settings popup
 * `Tab` to open settings again
 * `Enter` to complete refactoring - nothing happens, expected that settings are closed.","0"
"IDEA-217722","IntelliJ IDEA","","Intention: replace field usages with accessors","Maksim Medvedev","07/07/2019 07:07","27/10/2020 11:20",,"Normal","Feature",,"maxmedvedev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","The intention should be suggested on a field and its accessors and may be on the field usage.","0"
"IDEA-253831","IntelliJ IDEA","","'Extract chained constructor' option is not available in 'Extract method' inplace options","Timur Yuldashev","26/10/2020 10:30","26/10/2020 10:30",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-211.277

```
class Tester {
        int f;
        int g;
        Tester(int x, int y) {
            f = x; // extract method
            g = y;
        }
    }
```

 * Invoke in place 'Extract method' refactoring on code above to extract `f = x` line
 * Open option with `Tab` - there is no option 'Extract chained constructor' which is available in the dialog

![](image.png)","0"
"IDEA-253827","IntelliJ IDEA","","'Make static and pass fields' option is disabled in dialog if pre-selected in popup settings","Timur Yuldashev","26/10/2020 09:59","26/10/2020 09:59",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-211.277


```
    Object o = new Object();
    void t() {
        System.out.println(o);
    }
```    

 * Use code above to reproduce
 * select `sout` line and invoke inplace `Extract method` refactoring
 * select option `Make static and pass fields`
 * then open settings dialog pressing 'Ctrl-Alt-M' - note that in opened dialog option 'Make static' is disabled for some reason and cannot be changed. If user invokes dialog before selecting option in the pop-up settings then option would be enabled in the dialog.

![](image1.png)
![](image.png)","0"
"IDEA-253200","IntelliJ IDEA","","Prevent extraction of assignment of final field in constructor","Timur Yuldashev","17/10/2020 17:39","17/10/2020 17:39",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","203.5066
Consider following code sample. Select whole body of the constructor and invoke 'Extract method' refactoring - refactoring performed and code becomes red. Expected warning  about code containing assignment to final field as it was in 2020.2.  Though in 2020.2 user could select only one line with assignment and then IDEA produce red code too.

```
public class ExtractMethod {
    final int i;
    final int j;

    public ExtractMethod(int i, int j) {
        // start selection
        this.i = i;
        this.j = j;
        // end selection
    }
}
```","0"
"IDEA-253196","IntelliJ IDEA","","Hide ellipsis from list of suggestions when extract method","Timur Yuldashev","17/10/2020 16:43","17/10/2020 16:43",,"Normal","Usability Problem",,"Alexandr.Suhinin","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","203.5066

The only option from menu which is potentially useful is 'Sort by Name' but it seems the list shouldn't be too long to make it helpful, so i suggest to remove that submenu complete.

![](image.png)","0"
"IDEA-253022","IntelliJ IDEA","","Renaming constructor(s) parameters is suggested as a separate step during a field rename","Dmitry Cherniachenko","15/10/2020 11:17","15/10/2020 14:00",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When renaming a field IDEA suggests to rename getter/setter as well as setter parameter too. This is very convenient.
![](image.png)

Why wouldn't constructor(s) parameters be listed there as well? And are instead processed as a separate step?
What is so different between a setter parameter and a constructor parameter to move the latter into a separate dialog? (and not enable it by default!)
![](image1.png)","0"
"IDEA-163019","IntelliJ IDEA","","Create class refactoring in a test should suggest production context by default","Marcin Zajaczkowski","22/10/2016 20:53","13/10/2020 09:32",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">With TDD it is very often to use ALT-Enter -&gt; Create class refactoring to create new class. Idea could (at least for Gradle and Maven) propose production sources (src/main/[java|groovy]) as a target dictionary by default instead of a test one.</div>
","0"
"IDEA-251849","IntelliJ IDEA","","Suggest method names based on parameters for Kotlin and Java","0xd","30/09/2020 10:47","30/09/2020 11:54",,"Normal","Feature",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Refactor or rename by typing directly some method 

What is the expected result?
Name is completed using parameter type names `download(images : List<Image>)` -> `downloadImages(images : List<Image>)`

What happens instead?
No such completion","0"
"IDEA-178686","IntelliJ IDEA","","Multiple indistinguishable parameters are shown in the Rename","Dmitry Cherniachenko","08/09/2017 06:36","10/09/2020 09:17",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Display of what&#39;s going to be changed could be improved for parameters involved in the Rename:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>For example, the method signature could be shown after the parameter name (in gray).<br/><br/>In the above case one parameter comes from the corresponding &#39;setter&#39; and the other from a constructor.<br/><br/>By the way, when I was prompted if I want to rename the parameters there was just one entry, for the constructor parameter.<br/>The setter parameter apparently is assumed to always be included in the Rename.<br/>(In this case constructor does not use direct assignment like <code class=""inline-code"">this.id = id;</code> but instead has something like <code class=""inline-code"">this.id = id.getValue();</code>. Maybe that&#39;s the reason why IDEA asked for a confirmation if this parameter should be renamed?)</div>
","0"
"IDEA-165987","IntelliJ IDEA","reply needed","Rename refactoring shouldn't suggest textual changes project-wide when applied to a parameter.","Sergey Shkredov","28/12/2016 06:31","10/09/2020 09:09",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Please take a look at the screencast. This is real pain. I often find it easier to rename references manually. <br/><br/><a href=""https://www.youtube.com/watch?v=NEU6VsUkm_s&amp;feature=youtu.be"" target=""_blank"" rel=""noopener noreferrer"">https://www.youtube.com/watch?v=NEU6VsUkm_s&feature=youtu.be</a></div>
","0"
"IDEA-115186","IntelliJ IDEA","reproduced","Rename interface does not cascade to tests","Jostein Gogstad","21/10/2013 10:42","10/09/2020 09:08",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When you rename an interface, IntelliJ will also automatically rename its implementors, but not the tests of the implementors.<br/><br/><ol class=""wiki-list0""><li> Create an interface <span class=""monospace"">FooSomething</span><br/></li><li> Create two classes that implements the interface: <span class=""monospace"">FooOneSomething</span> and <span class=""monospace"">FooTwoSomething</span><br/></li><li> Create unit tests for both classes: <span class=""monospace"">FooOneSomethingTest</span> and <span class=""monospace"">FooTwoSomethingTest</span><br/></li><li> Now, rename the <em>interface</em> <span class=""monospace"">FooSomething</span> to <span class=""monospace"">FooSomethingElse</span><br/></li><li> Result:<br/><ol class=""wiki-list1""><li> Interface name: <span class=""monospace"">FooSomethingElse</span><br/></li><li> Classes name: <span class=""monospace"">FooOneSomethingElse</span> and <span class=""monospace"">FooTwoSomethingElse</span><br/></li><li> Unit tests: <span class=""monospace"">FooOneSomethingTest</span> and <span class=""monospace"">FooTwoSomethingTest</span><br/></li></ol></li><li> Expected<br/><ol class=""wiki-list1""><li> Unit tests: <span class=""monospace"">FooOneSomethingElseTest</span> and <span class=""monospace"">FooTwoSomethingElseTest</span><br/></li></ol><br/></li></ol></div>
","2"
"IDEA-68726","IntelliJ IDEA","reproduced","When renaming class IDEA suggests to rename derived classes and variables of the class being renamed, but it doesn't suggest to rename variables of derived classes","Ivan Chirkov","25/04/2011 11:09","10/09/2020 08:57",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown",,"0"
"IDEA-150586","IntelliJ IDEA","","Rename Variables Preview // Show affected classes","Romeo Frenksen","19/01/2016 05:14","10/09/2020 08:56",,"Normal","Cosmetics",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Like shown on the images above, the table depicting the affected variables (from refactoring &quot;rename variables&quot;) does not show the class. It is only displayed when clicking on an entry. I&#39;d like to see an additional column within the table to enable users to quickly see which classes are to be affected.<br/><br/><div class=""wiki picture""><img src=""[](Status.png)""/></div> <div class=""wiki picture""><img src=""[](Details.png)""/></div></div>
","0"
"IDEA-205990","IntelliJ IDEA","","Let refactor-rename pursue parameter names across state lines","tr","24/01/2019 11:32","10/09/2020 08:43",,"Normal","Feature",,"anet","Java. Refactorings","2018.3.4 (183.5429.30)",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If this option is already present in the IDE, I could&#39;t find it. I tried my  new trick (ha!) of pressing twice for rename-refactor but I didn&#39;t see it as an option. <br/><br/><br/>Current State:<br/><br/>When I  rename-refactor a variable  IJ will change the name the local / class / global variable within the scope it is defined by the AST. <br/><br/><br/><br/><br/>What I Want:<br/><br/>In the limited context I present here, it would be rational and useful  to extend  the variable&#39;s rename-refactor scope beyond the scope in which it is technically defined (in an AST-y way).  <br/><br/>Inside methodOne(), it can happen that a entity methodOne() either received as a parameter or created as a local variable- call it variableOne-  is subsequently passed along to method(s) methodOne() invokes. Call such a method methodTwo(). <br/><br/>When I rename-refactor variableOne, it is changed within the scope in which it is strictly defined, which is  methodOne(). But it makes sense, and would be nice, if the rename-refactor would extend into methodTwo()&#39;s parameter list and subsequent usages.<br/><br/>( OK strictly speaking it contains variableOne&#39;s value or an independent copy of variableOne if variableOne is a reference variable. From this point  forward I am just going to call all such variable instances &quot;variableOne&quot;).<br/><br/>I want the rename-refactor  to &quot;pursue&quot; the variableOne as it is passed along through method invocations.  <br/><br/><br/><br/><br/><br/>How I imagine This Working<br/><br/>Maybe it presents all such parameter passings as a call-hierarchy type popup dialog with individual checkboxes for each method and a preview window that shows the actual method for each checkbox-choice. I think that would work.<br/><br/>Maybe there&#39;s a checkbox in a configuration dialog to turn it on and off globally. Maybe the option also appears when you invoke rename-refactor a second time. <br/><br/>Under the covers I imagine it would just be successive calls to regular rename-refactor. <br/><br/><br/><br/>Why I Want This<br/><br/>I (shamelessly) use very very long and descriptive names for variables to convey critical  information about their origin, contents and purpose. I otherwise have no non-comment way of communicating this information and it is essential to understanding what those variables represent and  how they should be used. <br/><br/>An example would be an int[] (array) with the name:<br/> &quot;allPossibleSizesForTreeFortsGivenTheNextTreeTrunksGirth&quot; <br/><br/>Every time I rename-refactor, I have to  manually pursue the variable through all the successive methods it gets passed to. <br/><br/><br/>Q: So why don&#39;t I just do it manually?  <br/>A: I can, but it&#39;s an extra step which is cumbersome compared to having it automated.   <br/><br/><br/><br/>General Principle<br/>Lowering the cost of changing your mind leads to experimentation which leads to discovery. <br/><br/>General Principle<br/>Appear to your coder as a wonderful magic genie and he will keep rubbing your lamp. (meaning- keep wowing your audience and they will keep buying your product!)</div>
","0"
"IDEA-143703","IntelliJ IDEA","","Allow ordering of variables in Rename Variables when renaming a class","Andrey Dernov","10/08/2015 06:46","10/09/2020 08:38",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I rename heavily used class, which has many variables that reference the name (e.g. class Node, with many node, nodes, nodeA, nodeSomething variables in existence), the refactoring offers to rename these variables too, which is good.<br/><br/>However, they seem to be sorted by name and type (paramerter, local var, ...), which is not very convenient, if the decision rename-or-not depends on context, because the context is changing randomly for every renamed var.<br/><br/>It would be good, if I could change the order to be by class+line instead. E.g. consider following snippet:<br/><br/><pre class=""wikicode prettyprint"">void someMethod(List&lt;Nodes&gt; nodes) { <br/>Node nodeA = nodes.get(0); <br/>Node nodeB = nodes.get(1);</pre><br/>here I have 3 decisions - nodes, nodeA and nodeB to make, and if I could make it in a row, it would be very easy to see what&#39;s going on. But current implementation will scatter these three in mix of other variables with same name.</div>
","1"
"IDEA-186608","IntelliJ IDEA","","""Not all usages were renamed"" dialog is pretty much useless","Dmitry Cherniachenko","13/02/2018 08:08","10/09/2020 07:33",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It is probably fine when the refactoring affects only a single file opened in the editor.<br/>But when it spans across multiple classes (e.g. when renaming variables as suggested after renaming a class) a dialog like this is essentially useless.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>It should probably be turned into an event log message with the FQ names and the links to individual usages that weren&#39;t renamed.</div>
","0"
"IDEA-186607","IntelliJ IDEA","","Automatically select variable to be renamed when editing the target name","Dmitry Cherniachenko","13/02/2018 08:03","10/09/2020 07:33",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When renaming a class IDEA suggests to rename related variables too.<br/>It would be useful if a particular variable was selected to be renamed automatically once the target name is changed.</div>
","1"
"IDEA-211686","IntelliJ IDEA","","Class rename: suggest to rename variables of subclasses","Roman Leventov","25/04/2019 13:02","10/09/2020 07:32",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```java
class Test {
  class Foo {}
  class SubFoo extends Foo {}

  void bar() {
    Foo foo;
    SubFoo subFoo;
  }
}
```
A rename of `Foo` to `Bar` doesn't lead to a suggestion to rename `subFoo` variable to `subBar`, although the class `SubFoo` itself is suggested to be renamed to `SubBar`.","1"
"IDEA-249956","IntelliJ IDEA","","Intellij extract non static inner class utilizing outer classes generic signature. Performs it wrong.","momomo","03/09/2020 03:00","03/09/2020 12:20",,"Normal","Bug",,"anet","Java. Refactorings","2020.2.1 (202.6948.69)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","See attached video.  

Comments in video: 

As you can see, and potentially argue, that it is such a small issue, that I can add it myself, however, the manual labor afterwards, 
if used in more than one place is extensive.                                                                                          
                                                                                                                                      
Add to that INTELLIJ's inability to notify of errors unless you open all other files / classes, and you might NOT know.               
The refactor, extract method should work. It is to be expected by an editor that is ""intelligent"" ...                                 
 I bet **netbeans and eclipse** do all these things in their sleep. They have Java as a focus language. A priority. Intellij used to have that. Now it is just an average editor for a bunch of different languages, doing things averagely, none excellently. We do not need PHP support. Seriously. Or GoLang. Or PyCharm. Or ReSharper. Or ..., Or ..., Or .... 

All of that has led to a bloated code base for you. Start working on your editor and ensuring quality is delivered. 
                    
I also think that Intellij used to be able to REFACTOR much better in the past. Pre Java 8 it got most things correctly.              
Now it is just a clear presentation of badly written software that handles everything based on cases rather than logic.            
   
You patch to cover for all scenarios instead of coding in a consistent error proof manner. Needless to say.                           
I have developed plugins and that code base is not well written. You guys need to seriously reprioritize.                             

I've filed over 10 issues regarding all kinds of issues with refactoring, and there are mooooore to come. There is plenty.            
I have one coming soon. takes time.","0"
"IDEA-249514","IntelliJ IDEA","","Intellij does not propose to change the signature in some cases, here is a video of such a case.","momomo","31/08/2020 07:26","02/09/2020 07:38",,"Normal","Bug",,"anet","Java. Refactorings","2020.2.1 (202.6948.69)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","ANNOYING AS HELL. TOOK THREE MINUTES TO FIGURE OUT AND TYPE CORRECT SIGNATURE MANUALLY. HAPPENS ALL THE TIME.

SEE VIDEO. 

I SHOULD START GETTING PAID FOR ALL THE REPORTS I AM MAKING RATHER THAN IT BEING JETBRAINS OWN EMPLOYEES DETECTING THEM WHILE CODING. I spend 1-2 hours daily on this stuff. Generating videos, compressing, reporting, commenting, following up.... 

Please put me on the payroll.","0"
"IDEA-249320","IntelliJ IDEA","","Replace with 'switch' expression produces incorrect code for fall thought default case","Zero Errors","28/08/2020 07:20","28/08/2020 11:07",,"Normal","Bug",,"Roman.Ivanov","Java. Refactorings","2020.3 (203.5981.155), 2020.2.1 (202.6948.69)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Incorrect refactoring when replacing a switch with a switch expression when the switch has a default case that falls thought to another case.

When using the `Replace with 'switch' expression` refactoring in both of the below examples the `default` case should be the same as the `case ""default""`.

**How to reproduce:**
1. Take one of the below 'before' code sections
1. Place cursor on the `switch` keyword
2. Press `Alt+Enter`/`Opt+Enter` or display the quick-fix menu
3. Select `Replace with 'switch' expression`

<br/>

# Case 1: Missing default case

Before:
```
public static void main(String[] args) {
    var stream = List.of(""one"", ""two"", ""three"").stream();

    for (var arg : args) {
        switch (arg) {
            default:
            case ""default"":
                stream = stream.sorted();
                break;
            case ""length"":
                stream = stream.sorted(Comparator.comparingInt(String::length));
                break;
            case ""reverse"":
                stream = stream.sorted(Collections.reverseOrder());
                break;
        }
    }

    stream.forEach(System.out::println);
}
```

After:
```
public static void main(String[] args) {
    var stream = List.of(""one"", ""two"", ""three"").stream();

    for (var arg : args) {
        stream = switch (arg) {
            case ""default"" -> stream.sorted();
            case ""length"" -> stream.sorted(Comparator.comparingInt(String::length));
            case ""reverse"" -> stream.sorted(Collections.reverseOrder());
            // Missing: default -> stream.sorted();
        };
    }

    stream.forEach(System.out::println);
}
```

<br/>
<br/>

# Case 2: Incorrect default case

Before:
```
public static void main(String[] args) {
    var stream = List.of(""one"", ""two"", ""three"").stream();

    stream = stream.filter(Objects::nonNull);

    for (var arg : args) {
        switch (arg) {
            default:
            case ""default"":
                stream = stream.sorted();
                break;
            case ""length"":
                stream = stream.sorted(Comparator.comparingInt(String::length));
                break;
            case ""reverse"":
                stream = stream.sorted(Collections.reverseOrder());
                break;
        }
    }

    stream.forEach(System.out::println);
}
```

After:
```
public static void main(String[] args) {
    var stream = List.of(""one"", ""two"", ""three"").stream();

    stream = stream.filter(Objects::nonNull);

    for (var arg : args) {
        stream = switch (arg) {
            case ""default"" -> stream.sorted();
            case ""length"" -> stream.sorted(Comparator.comparingInt(String::length));
            case ""reverse"" -> stream.sorted(Collections.reverseOrder());
            default -> stream; // Should be: `stream.sorted();`
        };
    }

    stream.forEach(System.out::println);
}
```","0"
"IDEA-248451","IntelliJ IDEA","","Can not switch to checkbox by tab","Владимир Шкицкий","18/08/2020 11:35","18/08/2020 12:34",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Checkbox for ""Replace all occurrences"" can not be chosen by ""tab"" button in Introduce Constant menu (this issue prevents you from recording the correct macro). 

IC-202.6397.94, JRE 11.0.7+10-b944.20x64 JetBrains s.r.o., OS Windows 10(amd64) v10.0 , screens 1920x1080, 1920x1080","1"
"IDEA-248289","IntelliJ IDEA","","Refactoring - introduce field does not recognise several occurrence of an assignemt","Karl Heinz Marbaise","15/08/2020 09:20","17/08/2020 09:55",,"Normal","Bug",,"anet","Java. Refactorings","2020.3 (203.5981.155)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Having a Test class containing three methods where each of them contains an identical assignments
2. Calling ""Refactor This"" -> ""Introduce field"" shows only two occurrence 

What is the expected result?
The ""Introduce field"" should recognise all three occurrence of the assignments and let me refactor them into the ""setUp"" method.
What happens instead?
The refactoring will only pickup a single occurrence.

I have attached a small screen cast to show real life behaviour. 
Also setup an example project https://github.com/khmarbaise/idea-bugs-IDEA-248289 to having the same code and project setup to reproduce.

Here is my enviornment:
IntelliJ IDEA 2020.2.1 Preview (Ultimate Edition)
Build #IU-202.6948.5, built on August 11, 2020
....
Runtime version: 11.0.8+10-b944.31 x86_64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
macOS 10.14.6
GC: ParNew, ConcurrentMarkSweep
Memory: 2988M
Cores: 12
Non-Bundled Plugins: AceJump, CMD Support, PlantUML integration, SnakeYAML plugin, com.alayouni.ansiHighlight, com.intellij.ideolog, com.chainstaysoftware.assertions2assertj, com.dubreuia, com.sunny.plugin.MockitoGenPlugin, com.jetbrains.plugins.ini4idea, net.sjrx.intellij.plugins.systemdunitfiles, org.antlr.intellij.plugin, org.jetbrains.plugins.vagrant, com.intellij.kubernetes, org.nik.presentation-assistant, org.sonarlint.idea, org.toml.lang, MavenRunHelper, com.intellij.selenium, org.jetbrains.plugins.ruby, net.ashald.envfile, ru.adelf.idea.dotenv, org.asciidoctor.intellij.asciidoc, org.rust.lang","0"
"IDEA-247333","IntelliJ IDEA","","Please add an ""Always Cancel"" for bulk refactorings","Chuck Adams","03/08/2020 13:55","04/08/2020 07:14",,"Normal","Feature",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When inheriting a legacy codebase with lots of unnecessary cruft, I occasionally run bulk inspections like ""unused parameter"" and batch-fix them.  Occasionally it balks at this because the parameter name is used in the body, and pops up a dialog to resolve it.  Unfortunately this _blocks_ the rest of the refactorings, and I have to resolve it every single time.  I would prefer an ""always cancel"" and/or ""always view"" checkbox so I don't have to keep coming back to it.

Also, IDEA continually steals focus when running the refactorings.  I'll search or submit a different bug for that.","0"
"IDEA-24086","IntelliJ IDEA","too hard for now","Ability to change the type of a local variable, parameter, method return value within its allowed bounds not changing the behaviour of the application","Thomas Singer","05/08/2009 03:49","20/07/2020 07:44",,"Normal","Feature",,"basleijdekkers","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Example:<br/><pre class=""wikicode prettyprint"">final List&lt;String&gt; lines = getLines();<br/>processLines(lines);</pre>Allow to change the <span class=""monospace"">lines</span> local variable within its allowed bounds, defined by the signature of <span class=""monospace"">getLines()</span> and <span class=""monospace"">processLines()</span>, e.g. to <span class=""monospace"">Collection&lt;String&gt;</span> or <span class=""monospace"">Iterable&lt;String&gt;</span>.</div>
","2"
"IDEA-193101","IntelliJ IDEA","","Moving package to another source root is complicated with many qualified-named modules","Peter Gromov","01/06/2018 03:50","20/07/2020 07:43",,"Normal","Usability Problem",,"nik","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Go to idea/community/platform/testFramework/testSrc/com/intellij/testFramework in Project View, invoke Move (move directory to another source root), Enter, you&#39;re presented with a dialog to choose source root.<br/>1. The selected suggestion is something from Android, makes little sense.<br/>2. Assume I know that the module is &quot;intellij.platform.testFramework&quot; before I run refactoring (not always so, and not always visible on the screen). I try to speed-search for &quot;testFramework&quot;, and some other one is selected. There&#39;s so many testFrameworks deep in the tree structure, and all of them are expanded and focused. Worse than that, the full path to the module isn&#39;t displayed, so I can&#39;t easily see if now I&#39;ve found the correct one or not. I can&#39;t even easily judge by source root paths, because the module name is not expanded, and when I expand it to see source root paths, the speed search is lost, I have to type it again.<br/><br/>Fixing 1 could improve the situation, but still, if I wanted to move to another module, speed-search would be unhelpful.</div>
","2"
"IDEA-245145","IntelliJ IDEA","","Safe delete not available for record members.","Timur Yuldashev","03/07/2020 13:03","16/07/2020 14:02",,"Normal","Feature",,"Tagir.Valeev","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","IU-202.6109.22

Currently *""Safe Delete""* refactoring is not available for record components.

![](image.png)","1"
"IDEA-208729","IntelliJ IDEA","would be good to fix","Extracting a method from a constructor or class initializer where final fields are initialized produces red code","Pavel Dolgov","11/03/2019 10:39","16/07/2020 13:59",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2019.1 (191.6183.87), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Here's the sample code.
If you extract a method from the whole constructor's body you'll get red code.
If you extract a method from a single line of the constructor's body you'll get some other red code.
```
class C {
    final int a;
    final int b;

    C(int a, int b) {
        this.a = a;
        this.b = b;
    }
}
```

Similar problem with qualified usage of the final field. Extract the whole constructor's body here.
Note that without `this` qualifier it works fine.
```
class C {
    final int a;

    C() {
        this.a = 1;
        System.out.println(this.a);
    }
}
```

And it's reproducible with class initializer (both static and non-static) as well.","0"
"IDEA-203747","IntelliJ IDEA","","'Change signature' with type annotations on nested class generates invalid Java code","Mike Gorünóv","06/12/2018 13:32","16/07/2020 13:52",,"Normal","Bug",,"anet","Java. Refactorings","2018.3.1 (183.4588.61)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Open Refactor -> Change Signature dialog, e. g. on a method `public abstract String doSomething();`
2. Add a parameter of type `@NonNull Whatever.Nested parameter`.
3. See a warning about unsupported type annotations for Java 6 — it's a parameter annotation, let's continue. (related: https://youtrack.jetbrains.com/issue/IDEA-59978)
4. After applying refactor you will see a broken signature: `public abstract String doSomething(Whatever.@NonNull Nested parameter);`

What is the expected result?
`public abstract String doSomething(@NonNull Whatever.Nested parameter);`

What happens instead?
`public abstract String doSomething(Whatever.@NonNull Nested parameter);`

I hope logs, screenshots, screencasts are not necessary to make this problem clear.
```
IntelliJ IDEA 2018.3.1 (Community Edition)
Build #IC-183.4588.61, built on December 4, 2018
JRE: 1.8.0_152-release-1343-b16 amd64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Linux 4.15.0-38-generic
```","0"
"IDEA-235401","IntelliJ IDEA","","""update implementation to reflect signature changes"" is not consistent with ""implement methods"" action in terms of annotation position","Dmitrii Naumenko","17/03/2020 09:19","16/07/2020 13:52",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","1. use the example:
```java
public interface MyBase {
    String foo();
}

class A implements MyBase {
    @Override
    public String foo() { return null; }
}

class B implements MyBase {
}
```

2. add `@Nls` annotation in before `foo` declaration in `MyBase`
3. perform ""update implementation to reflect signature changes"" action
4. perform ""implement methods"" action on `B`

**Expected result**
`@Nls` annotation position is the same for `foo` definition in `A` and `B`

**Actual result**
`@Nls` annotation in step 3. is added before the method return type type (BTW formatting breaks)
`@Nls` annotation in step 4. is added before the whole method

 ![](nls_annotation_position.gif)

IDEA Build   : IU-201.6251.22 March 12, 2020
JRE          : 11.0.6+8-b765.15amd64 (OpenJDK 64-Bit Server VM JetBrains s.r.o)
OS           : Windows 10 (10.0, amd64)","2"
"IDEA-168212","IntelliJ IDEA","","Extract Field from constructor parameter","Dmitry Cherniachenko","15/02/2017 06:15","09/07/2020 09:59",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"To be discussed","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Take the following code:<br/><pre class=""wikicode prettyprint"">public class SomeClass<br/>{<br/>    private int intField;<br/>    private boolean boolField;<br/><br/><br/>    public SomeClass(int intField, String stringField, boolean boolField)<br/>    {<br/>        this.intField = intField;<br/>        this.boolField = boolField;<br/>    }<br/>}</pre><br/>If I press Ctrl+Alt+F while the caret is on the <code class=""inline-code"">stringField</code> IDEA highlights the whole line and complains: &quot;Cannot perform refactoring. Caret should be positioned at ...&quot;. The same happens if I highlight the <code class=""inline-code"">stringField</code> first.<br/><br/>It would be much nicer however if IDEA refactored to code to this instead:<br/><pre class=""wikicode prettyprint"">public class SomeClass<br/>{<br/>    private int intField;<br/>    private String stringField;        // extra points for putting this line between intField and boolField<br/>    private boolean boolField;<br/><br/><br/>    public SomeClass(int intField, String stringField, boolean boolField)<br/>    {<br/>        this.intField = intField;<br/>        this.stringField = stringField;        // extra points for putting this line between intField and boolField<br/>        this.boolField = boolField;<br/>    }<br/>}</pre></div>
","1"
"IDEA-245294","IntelliJ IDEA","javadoc","""Class wil not be accessible"" warnings should distinguish JavaDoc references","Dmitry Jemerov","06/07/2020 12:15","06/07/2020 12:37",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","See attached screenshot. The message gives me zero indication that the reference is from JavaDoc (and is already inaccessible).

![](image.png)
","0"
"IDEA-111277","IntelliJ IDEA","","ISE at com.intellij.psi.impl.PsiToDocumentSynchronizer.a","Irina Petrovskaya","30/07/2013 10:04","03/07/2020 06:32",,"Normal","Exception",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">130.1459<br/><br/>on moving class:<br/>1) paste the following code to the defaulet package - the class is created, imports are auto-added;<br/>2) darg&#39;n&#39;drop this class to some non-default package - like &#39;a.b.c&#39; - exception is thrown, the package statement is not added.<br/> <br/><pre class=""wikicode prettyprint"">@FacesComponent(value=&quot;components.CustomComponent&quot;, createTag=true)<br/>public class CustomComponent extends UIComponentBase {<br/> <br/>    @Override<br/>    public String getFamily() {        <br/>        return &quot;my.custom.component&quot;;<br/>    }<br/> <br/>    @Override<br/>    public void encodeBegin(FacesContext context) throws IOException {<br/> <br/>        String value = (String) getAttributes().get(&quot;value&quot;);<br/> <br/>        if (value != null) {        <br/>            ResponseWriter writer = context.getResponseWriter();<br/>            writer.write(value.toUpperCase());<br/>        }<br/>    }<br/>}</pre><br/>Attempt to modify PSI for non-committed Document!: Attempt to modify PSI for non-committed Document!<br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.IllegalStateException: Attempt to modify PSI for non-committed Document!</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.a(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""84"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:84</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.childAdded(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""108"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:108</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiManagerImpl.a(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiManagerImpl.java"" lne=""445"" title=""Open in IDE"">PsiManagerImpl.java:445</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiManagerImpl.childAdded(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiManagerImpl.java"" lne=""330"" title=""Open in IDE"">PsiManagerImpl.java:330</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.wrappers.PsiEventWrapperAspect.a(<a class=""dsLink"" txt=""com/intellij/pom/wrappers/PsiEventWrapperAspect.java"" lne=""95"" title=""Open in IDE"">PsiEventWrapperAspect.java:95</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.wrappers.PsiEventWrapperAspect.update(<a class=""dsLink"" txt=""com/intellij/pom/wrappers/PsiEventWrapperAspect.java"" lne=""51"" title=""Open in IDE"">PsiEventWrapperAspect.java:51</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.core.impl.PomModelImpl.runTransaction(<a class=""dsLink"" txt=""com/intellij/pom/core/impl/PomModelImpl.java"" lne=""171"" title=""Open in IDE"">PomModelImpl.java:171</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.ChangeUtil.prepareAndRunChangeAction(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/ChangeUtil.java"" lne=""177"" title=""Open in IDE"">ChangeUtil.java:177</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addChild(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""644"" title=""Open in IDE"">CompositeElement.java:644</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addChildren(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""751"" title=""Open in IDE"">CompositeElement.java:751</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.codeStyle.CodeEditUtil.addChildren(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/codeStyle/CodeEditUtil.java"" lne=""82"" title=""Open in IDE"">CodeEditUtil.java:82</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addInternal(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""531"" title=""Open in IDE"">CompositeElement.java:531</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.PsiFileImpl.addBefore(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/PsiFileImpl.java"" lne=""837"" title=""Open in IDE"">PsiFileImpl.java:837</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.PsiJavaFileBaseImpl.setPackageName(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/PsiJavaFileBaseImpl.java"" lne=""134"" title=""Open in IDE"">PsiJavaFileBaseImpl.java:134</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.move.moveClassesOrPackages.MoveClassesOrPackagesUtil.doMoveClass(<a class=""dsLink"" txt=""com/intellij/refactoring/move/moveClassesOrPackages/MoveClassesOrPackagesUtil.java"" lne=""237"" title=""Open in IDE"">MoveClassesOrPackagesUtil.java:237</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.move.moveClassesOrPackages.MoveClassesOrPackagesProcessor.performRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/move/moveClassesOrPackages/MoveClassesOrPackagesProcessor.java"" lne=""494"" title=""Open in IDE"">MoveClassesOrPackagesProcessor.java:494</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$7.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""466"" title=""Open in IDE"">BaseRefactoringProcessor.java:466</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""1015"" title=""Open in IDE"">ApplicationImpl.java:1015</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""463"" title=""Open in IDE"">BaseRefactoringProcessor.java:463</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.access$100(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor/access.java"" lne=""70"" title=""Open in IDE"">BaseRefactoringProcessor.java:70</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$3.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""313"" title=""Open in IDE"">BaseRefactoringProcessor.java:313</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""117"" title=""Open in IDE"">CommandProcessorImpl.java:117</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""99"" title=""Open in IDE"">CommandProcessorImpl.java:99</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.execute(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""309"" title=""Open in IDE"">BaseRefactoringProcessor.java:309</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$5.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""407"" title=""Open in IDE"">BaseRefactoringProcessor.java:407</a>)<br/>&nbsp;<b>at</b> com.intellij.usages.impl.UsageViewImpl$MyPerformOperationRunnable$1.run(<a class=""dsLink"" txt=""com/intellij/usages/impl/UsageViewImpl.java"" lne=""1592"" title=""Open in IDE"">UsageViewImpl.java:1592</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""124"" title=""Open in IDE"">CommandProcessorImpl.java:124</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""99"" title=""Open in IDE"">CommandProcessorImpl.java:99</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""85"" title=""Open in IDE"">CommandProcessorImpl.java:85</a>)<br/>&nbsp;<b>at</b> com.intellij.usages.impl.UsageViewImpl$MyPerformOperationRunnable.run(<a class=""dsLink"" txt=""com/intellij/usages/impl/UsageViewImpl.java"" lne=""1588"" title=""Open in IDE"">UsageViewImpl.java:1588</a>)<br/>&nbsp;<b>at</b> com.intellij.usages.impl.UsageViewImpl$ButtonPanel$1.actionPerformed(<a class=""dsLink"" txt=""com/intellij/usages/impl/UsageViewImpl.java"" lne=""1500"" title=""Open in IDE"">UsageViewImpl.java:1500</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2018"" title=""Open in IDE"">AbstractButton.java:2018</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton$Handler.actionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2341"" title=""Open in IDE"">AbstractButton.java:2341</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""402"" title=""Open in IDE"">DefaultButtonModel.java:402</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.setPressed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""259"" title=""Open in IDE"">DefaultButtonModel.java:259</a>)<br/>&nbsp;<b>at</b> javax.swing.plaf.basic.BasicButtonListener.mouseReleased(<a class=""dsLink"" txt=""javax/swing/plaf/basic/BasicButtonListener.java"" lne=""252"" title=""Open in IDE"">BasicButtonListener.java:252</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processMouseEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6505"" title=""Open in IDE"">Component.java:6505</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processMouseEvent(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""3321"" title=""Open in IDE"">JComponent.java:3321</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6270"" title=""Open in IDE"">Component.java:6270</a>)<br/>&nbsp;<b>at</b> java.awt.Container.processEvent(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2229"" title=""Open in IDE"">Container.java:2229</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4861"" title=""Open in IDE"">Component.java:4861</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2287"" title=""Open in IDE"">Container.java:2287</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4687"" title=""Open in IDE"">Component.java:4687</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.retargetMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4832"" title=""Open in IDE"">Container.java:4832</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.processMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4492"" title=""Open in IDE"">Container.java:4492</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.dispatchEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4422"" title=""Open in IDE"">Container.java:4422</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2273"" title=""Open in IDE"">Container.java:2273</a>)<br/>&nbsp;<b>at</b> java.awt.Window.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Window.java"" lne=""2719"" title=""Open in IDE"">Window.java:2719</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4687"" title=""Open in IDE"">Component.java:4687</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""723"" title=""Open in IDE"">EventQueue.java:723</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$200(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""103"" title=""Open in IDE"">EventQueue.java:103</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""682"" title=""Open in IDE"">EventQueue.java:682</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""680"" title=""Open in IDE"">EventQueue.java:680</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""76"" title=""Open in IDE"">ProtectionDomain.java:76</a>)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""87"" title=""Open in IDE"">ProtectionDomain.java:87</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""696"" title=""Open in IDE"">EventQueue.java:696</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""694"" title=""Open in IDE"">EventQueue.java:694</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""76"" title=""Open in IDE"">ProtectionDomain.java:76</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""693"" title=""Open in IDE"">EventQueue.java:693</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.d(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""679"" title=""Open in IDE"">IdeEventQueue.java:679</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""503"" title=""Open in IDE"">IdeEventQueue.java:503</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""332"" title=""Open in IDE"">IdeEventQueue.java:332</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""242"" title=""Open in IDE"">EventDispatchThread.java:242</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""161"" title=""Open in IDE"">EventDispatchThread.java:161</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""150"" title=""Open in IDE"">EventDispatchThread.java:150</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""146"" title=""Open in IDE"">EventDispatchThread.java:146</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""138"" title=""Open in IDE"">EventDispatchThread.java:138</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""91"" title=""Open in IDE"">EventDispatchThread.java:91</a>)</pre></details></div></div>
","9"
"IDEA-244526","IntelliJ IDEA","","Problems with ""update implementation to reflect signature changes""","Régis Caspar","25/06/2020 09:37","29/06/2020 15:30",,"Normal","Bug",,"valentin","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**Part 1:** in some case the icon cannot be clicked

![](2020-06-25 14.30.17.gif)

**Part 2:** when there is an annotation (like `@Nonnull`) in the method changing signature, the action generates non compilable code:

![](2020-06-25 14.33.26.gif)

This is using #IU-201.7846.76 on macOS 10.15.5","0"
"IDEA-244691","IntelliJ IDEA","","""Update {0} to reflect signature change..."" should be an intention","Alexey Kudravtsev","27/06/2020 10:59","29/06/2020 15:10",,"Normal","Usability Problem",,"valentin","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","...to be able to turn it off","0"
"IDEA-243998","IntelliJ IDEA","","Automatically remove always true/false conditions on safe delete refactoring","Tagir Valeev","19/06/2020 03:29","19/06/2020 03:29",,"Normal","Feature",,"Tagir.Valeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","1. When enum constant is deleted (or possibly static final field initialized with new expression), conditions like `if (x == MyEnum.CONSTANT_TO_DELETE) {...} else {...}` could be replaced with `false` automatically with subsequent loop removal/unwrapping.
2. When type is removed, conditions like `if (x instanceof TypeToRemove) {...} else {...}` could be replaced with `false` automatically with subsequent loop removal/unwrapping.
3. If we know that some branches could be removed automatically due to previous items, do not report any usages inside these branches as conflicts. As success metrics, the following code should be simplified automatically when type is removed:

```java
if (x instanceof TypeToRemove) {
  ((TypeToRemove)x).process();
} else {
  doSomethingElse();
}
```

Upon removal of TypeToRemove, this code should be transformed to `doSomethingElse();` automatically.

Warnings in conflict view should be shown, as the conversions are non-trivial.","0"
"IDEA-243568","IntelliJ IDEA","","""Introduce try-with-resources"" intention","Dmitry Cherniachenko","15/06/2020 07:07","15/06/2020 17:30",,"Normal","Feature",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","An intention could be shown on `Closeable` items to extract them into a try-with-resources parameter.
From:
```
Map scheme = gson.fromJson(new FileReader(f), Map.class);
```

To:
```
try (Reader r = new FileReader(f)) {
    Map scheme = gson.fromJson(r, Map.class);
}
```

Alternatively this could be implemented as a ""Surround with try-with-resources"" template that would pick all the `Closeable` allocations in the selected code.","0"
"IDEA-242660","IntelliJ IDEA","","Introduce variable doesn't clean up imports if cancelled.","Alexandr Suhinin","05/06/2020 06:05","05/06/2020 07:20",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
class Test {
    void test() {
        System.out/*caret*/.println();
    }
}
```
1. Put caret after 'out' word
2. Run introduce variable refactoring (Ctrl+Alt+V)
3. Press Escape (3 times) until refactoring is reverted
4. Check `import java.io.PrintStream;` is not removed","0"
"IDEA-241976","IntelliJ IDEA","","open commit dialog,  check ""optimize import"" and check ""perform code analysis"" then code analysis show warnings of unused imports which is irrelevant because IDEA optimize imports before push, when i clicked to show warning from code analysis they are not there, becasue optimize import has already removed them.","Lukas Dilik","28/05/2020 07:11","29/05/2020 06:32",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","

IU-201.7223.91, JRE 11.0.6+8-b765.40x64 JetBrains s.r.o, OS Windows 10(amd64) v10.0 , screens 3072x1728","0"
"IDEA-241376","IntelliJ IDEA","","""Show definition"" in Extract Superclass dialog should show definition of the selected method","Nikolay Chashnikov","20/05/2020 06:07","21/05/2020 13:05",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When I invoke ""Extract Superclass"" I need to decide which members should be moved to superclass, and usually I want to look at their bodies, but currently I cannot do this: the dialog is modal so I cannot open the body in the editor, and ""Show Definition"" popup shows definition of a superinterface instead:
![](image.png)","0"
"IDEA-152839","IntelliJ IDEA","reproduced","Inlining method which is part of assignment in 'while' condition produced non-working code","Timur Yuldashev","10/03/2016 14:53","06/05/2020 10:22",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.433</strong><br/>Similar to <a href=""/issue/IDEA-152813"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-1147255"" title=""Inlining variable assignment of which is part of complex expression causes troubles"">IDEA-152813</a>, but for method inline and while cycle. <br/><br/>Consider next code sample:<br/><br/><pre class=""wikicode prettyprint"">    public void read() {<br/>        try {<br/>            BufferedReader reader = Files.newBufferedReader(Paths.get(&quot;c:\\temp.txt&quot;), Charset.defaultCharset());<br/>            String line = null;<br/>            while (isNull(line = reader.readLine())) { // inline isNull method<br/>                System.out.println(line);<br/>            }<br/>        } catch (IOException e) { }<br/>    }<br/><br/>    private boolean isNull(String s) {<br/>        return s == null ? true : false;<br/>    }</pre><br/>When inlining <span class=""monospace"">isNull</span> method in <span class=""monospace"">while</span> statement it creates next incorrect code:<br/><br/><pre class=""wikicode prettyprint"">            String s = line = reader.readLine();<br/>            while (s == null ? true : false) { // inline isNull method<br/>                System.out.println(line);<br/>            }</pre><br/>So there are two questions:<br/>1. Could we warn user when move some part of the code outside cycle?<br/>2. Do we have to create temprary <span class=""monospace"">s</span> variable?</div>
","1"
"IDEA-239988","IntelliJ IDEA","","Inline signature change: contract is not updated automatically","Tagir Valeev","04/05/2020 01:58","04/05/2020 02:02",,"Normal","Bug",,"valentin","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","E.g.:

```java
  @Contract(value = ""null, _ -> false"", pure = true)
  static boolean test(String s, int x) {
    if (s == null) return false;
    return s.length() > 10;
  }
```

If I remove `, int x` manually, then use 'Update usages to reflect signature change' the contract is not updated automatically to `""null -> false""`. Note that this works if I change the signature from normal Change signature dialog or use Safe delete on a parameter. The problem appears with inline signature change only.","0"
"IDEA-239060","IntelliJ IDEA","","Update Usages Popup: the button should be always reachable","Irina Petrovskaya","27/04/2020 17:18","28/04/2020 03:06",,"Normal","Bug",,"valentin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","202.3145

if the method signature is changed, the UpdateUsages gutter icon becomes available.
invoke popup:
If the method name is rather long and/or the application frame is decreased, the Next button is not shown and even is not reachable
![](image.png)","0"
"IDEA-239056","IntelliJ IDEA","","Throwable at com.intellij.openapi.command.impl.UndoManagerImpl.undoableActionPerformed","Irina Petrovskaya","27/04/2020 17:05","28/04/2020 03:04",,"Normal","Exception",,"valentin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","202.3145

occurred few times on pressing Enter while Rename Usages popup (invoked via gutter icon for the renamed methos) is opened 

```
java.lang.Throwable: Assertion failed: Undoable actions allowed inside commands only (see com.intellij.openapi.command.CommandProcessor.executeCommand())
	at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:179)
	at com.intellij.openapi.command.impl.UndoManagerImpl.undoableActionPerformed(UndoManagerImpl.java:281)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt.doRefactor(PerformSuggestedRefactoring.kt:171)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt.access$doRefactor(PerformSuggestedRefactoring.kt:1)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$performSuggestedRefactoring$1.invoke(PerformSuggestedRefactoring.kt:67)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$performSuggestedRefactoring$callbacks$2.invoke(PerformSuggestedRefactoring.kt:83)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$performSuggestedRefactoring$callbacks$2.invoke(PerformSuggestedRefactoring.kt)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$createAndShowBalloon$2.actionPerformed(PerformSuggestedRefactoring.kt:221)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(ActionUtil.java:295)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(IdeKeyEventDispatcher.java:598)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.lambda$processAction$3(IdeKeyEventDispatcher.java:659)
	at com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(TransactionGuardImpl.java:94)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:658)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:608)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processActionOrWaitSecondStroke(IdeKeyEventDispatcher.java:505)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.inInitState(IdeKeyEventDispatcher.java:459)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(IdeKeyEventDispatcher.java:217)
	at com.intellij.ide.IdeEventQueue.dispatchKeyEvent(IdeEventQueue.java:889)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:834)
	at com.intellij.ide.IdeEventQueue.lambda$null$8(IdeEventQueue.java:450)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:743)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$9(IdeEventQueue.java:449)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:816)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:503)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)
```","0"
"IDEA-87678","IntelliJ IDEA","","(RFE) Support Objects.requireNonNull in generated constructors (and setters)","Brian Goetz","21/06/2012 13:40","27/04/2020 16:40",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In Java SE 7, there is a new method Objects.requireNonNull(x), which returns x if x is non-null, and throws NPE otherwise.  This is intended for use in constructors and setters to allow early enforcement of contract violations.  <br/><br/>When generating constructors, IDEA generates constructors of the form:<br/><br/>    public Class(Type arg) {<br/>        this.arg = arg;<br/>    }<br/><br/>For reference-valued arguments that are supposed to be non-null, the encouraged new pattern (for source level 7 and greater) is:<br/><br/>    public Class(Type arg) {<br/>        this.arg = Objects.requireNonNull(arg);<br/>    }<br/><br/>In the equals/hashCode wizard, there are optional panes for &quot;which of these might be null&quot; so that null checks can be introduced.  The same concept can be applied here; the user checks which arguments are expected to be non-null, and the generated code can enforce it.  If you are using annotations to express non-nullity requirements, those can be generated too.  <br/><br/>The same can be done with setters.  </div>
","24"
"IDEA-238428","IntelliJ IDEA","","""Migrate..."" refactoring does not respect order of migration entries","Knut Wannheden","21/04/2020 11:47","22/04/2020 08:17",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I have added a migration map with the following entries (in the order given here):

1. Class `io.swagger.v3.oas.annotations.responses.ApiResponse` -> `org.eclipse.microprofile.openapi.annotations.responses.APIResponse`
1. Class `io.swagger.v3.oas.annotations.Parameter` -> `org.eclipse.microprofile.openapi.annotations.parameters.Parameter`
1. Package `io.swagger.v3.oas.annotations` -> `org.eclipse.microprofile.openapi.annotations`

When I perform this refactoring any reference to `io.swagger.v3.oas.annotations.Parameter` is migrated to reference `org.eclipse.microprofile.openapi.annotations.Parameter` rather than `org.eclipse.microprofile.openapi.annotations.parameters.Parameter`.

Since the order can be controlled in the migration map dialog I would have expected the entries further up to take precedence over those further down. Is it in fact the other way around or is it maybe not deterministic?","1"
"IDEA-237798","IntelliJ IDEA","","Refactoring gutter appears after Undoing class name change, causes exception","Timur Yuldashev","15/04/2020 13:40","20/04/2020 09:54",,"Normal","Exception",,"valentin","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","201.7223.1  & 202.2476

```
public class C<caret> {
}
```

* Set caret after `C` class name
* Backspace to remove name and type new name - gutter appears suggesting to rename
* Use intention to rename usages - all seems okay
* Undo three times (updating usages, erase, old name) - code returned to initial state but gutter to rename is still there.

If user clicks on the gutter at that moment then exception thrown and IDEA becomes unstable (Alt-Enter doesn't work right after editing, cannot quick on Mac).


2020-04-15 13:13:11,955 [1043333]  ERROR - llij.ide.plugins.PluginManager - Element class com.intellij.psi.impl.source.tree.java.ClassElement of type CLASS (class com.intellij.psi.impl.java.stubs.JavaStubElementTypes$1) 
com.intellij.psi.PsiInvalidElementAccessException: Element class com.intellij.psi.impl.source.tree.java.ClassElement of type CLASS (class com.intellij.psi.impl.java.stubs.JavaStubElementTypes$1)
	at com.intellij.psi.PsiInvalidElementAccessException.createByNode(PsiInvalidElementAccessException.java:79)
	at com.intellij.psi.impl.source.SubstrateRef$2.getContainingFile(SubstrateRef.java:101)
	at com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(StubBasedPsiElementBase.java:253)
	at com.intellij.extapi.psi.StubBasedPsiElementBase.getProject(StubBasedPsiElementBase.java:291)
	at com.intellij.refactoring.suggested.SuggestedRefactoringFeatureUsage.logEvent(SuggestedRefactoringFeatureUsage.kt:35)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$performSuggestedRefactoring$callbacks$5.invoke(PerformSuggestedRefactoring.kt:88)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$performSuggestedRefactoring$callbacks$5.invoke(PerformSuggestedRefactoring.kt)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$createAndShowBalloon$5.onClosed(PerformSuggestedRefactoring.kt:263)
	at com.intellij.ui.BalloonImpl.lambda$hideAndDispose$4(BalloonImpl.java:1054)
	at com.intellij.ui.BalloonImpl.hideAndDispose(BalloonImpl.java:1076)
	at com.intellij.ui.BalloonImpl.hide(BalloonImpl.java:1026)
	at com.intellij.refactoring.suggested.PerformSuggestedRefactoringKt$createAndShowBalloon$3.actionPerformed(PerformSuggestedRefactoring.kt:231)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(ActionUtil.java:280)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(IdeKeyEventDispatcher.java:609)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.lambda$processAction$3(IdeKeyEventDispatcher.java:670)
	at com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(TransactionGuardImpl.java:94)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:669)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:619)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processActionOrWaitSecondStroke(IdeKeyEventDispatcher.java:516)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.inInitState(IdeKeyEventDispatcher.java:470)
	at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(IdeKeyEventDispatcher.java:219)
	at com.intellij.ide.IdeEventQueue.dispatchKeyEvent(IdeEventQueue.java:896)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:841)
	at com.intellij.ide.IdeEventQueue.lambda$null$8(IdeEventQueue.java:449)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:741)
	at com.intellij.ide.IdeEventQueue.lambda$dispatchEvent$9(IdeEventQueue.java:448)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:831)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:502)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)","0"
"IDEA-238175","IntelliJ IDEA","","Extract method doesn't respect ""type use""","Vladimir Krivosheev","20/04/2020 03:29","20/04/2020 03:29",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Extract method.

Actual:
```
  @NotNull
  private static Supplier<InspectionToolWrapper<?, ?>> createSupplier
```

Expected:

```
  private static @NotNull Supplier<InspectionToolWrapper<?, ?>> createSupplier
```","0"
"IDEA-237664","IntelliJ IDEA","","""Change Signature"" does not affect nested functions","Erez Israeli Miller","14/04/2020 16:34","14/04/2020 16:53",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
Write function `int f(int a, int b)`
Somewhere else, write `f(f(1, 2), f(3, 4))`
Go to `f` and Refactor -> Change Signature, switch the order of `a`, `b`

What is the expected result?
`f(f(4, 3), f(2, 1))`

What happens instead?
`f(f(3, 4), f(2, 1))`

Please attach idea.log (go to Help | Show Log in ... to discover it easily). You can use 'Attach File Privately' item to make attachments visible to 'jetbrains-team' group only. If you don't want to share IDE logs even with JetBrains team please at least paste information about IDE build and your environment below (it can be copied from Help | About dialog).

Сonsider attaching a screenshot, screencast, or a code sample when it's hard to articulate the problem. Note that you can easily drag & drop files of any type into the issue.

If you are experiencing performance issues, please also [attach the snapshots](https://intellij-support.jetbrains.com/hc/en-us/articles/207241235).","0"
"IDEA-237567","IntelliJ IDEA","","Increase field visibility to avoid compilation errors when moving inner classes to top level","Nikolay Metchev","14/04/2020 04:46","14/04/2020 07:07",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","If an inner class is accessing private fields from an outer class and you refactor that inner class to be a top level class then Idea gives a warning that the field in the outer class will no longer be accessible. It seems to me a better course of action would be to increase the field visibility to package or public depending on where the inner class is to be refactored. This way you don't end up with compiler errors:

```
package j;

public class Outer {
    private static final int f = 2;

    public static class Inner { // Move class to top level results in compiler error. Field f should also be made package protected/public as part of the refactoring
        public static int getF() {
            return f;
        }
    }
}
```
IU-201.6668.121, JRE 11.0.6+8-b765.25x64 JetBrains s.r.o, OS Mac OS X(x86_64) v10.15.4, screens 3840x2160, 1792x1120","0"
"IDEA-236067","IntelliJ IDEA","","Introduce variable wraps unnecessarily when extracting a long expression from a long line","Peter Gromov","25/03/2020 16:53","08/04/2020 08:54",,"Normal","Bug",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Have this code that exceeds editor right margin by a bit:

```
    int longExpression1 = 0;
    int longExpression2 = 0;
    foo(true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, longExpression1 + longExpression2, true);
```

Select `longExpression1 + longExpression2`, introduce a variable `x`. Note that `foo` call is now wrapped, despite the fact it now fits the right margin.","0"
"IDEA-235749","IntelliJ IDEA","","Local variable extraction qualifying static field of the same name during new variable naming","Roded","21/03/2020 07:07","23/03/2020 05:15",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.2 (202.6397.94)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When extracting a method call into a local variable, if the current method has any references to a static variable named as the initial local variable extraction suggestion, the static field references are qualified with the field's class. This occurs before the extraction is confirmed causing unnecessary changes even when the final chosen variable name is not the same as the static field's.

```
import java.util.logging.Logger;

class Scratch {

    private static final Logger logger = Logger.getLogger(Scratch.class.getName());
    
    public static void main(String[] args) {

        // When attempting a local variable extraction of this method call,
        // the logger.info line below will change as the initial extraction's
        // variable name collides with the static field's.
        getLogger();
        
        logger.info(() -> ""This line will be changed unnecessarily."");    
    }
    
    public static Object getLogger() {
        return null;
    }
}
```

IU-193.6911.18, JRE 11.0.6+8-b520.43x64 JetBrains s.r.o, OS Linux(amd64) v5.5.9-arch1-2, screens 1920x1200","0"
"IDEA-235396","IntelliJ IDEA","","Move method doesn't work properly with recursive calls","Ruslan Romanov","17/03/2020 08:25","17/03/2020 11:06",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121), 2019.3.3 (193.6494.35)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?

1. Consider the following code:

```
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class A {

    Stream<B> subTree(B root) {
        return Stream.concat(
            Stream.of(root),
            root.children.stream().flatMap(this::subTree)
        );
    }

    static class B {
        List<B> children = new ArrayList<>();
    }

}
```


2. Try to move method `subTree` to class `B`

What is the expected result?

Something like this:
```
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class A {

    static class B {
        List<B> children = new ArrayList<>();

        Stream<B> subTree() {
            return Stream.concat(
                Stream.of(this),
                children.stream().flatMap(B::subTree)
            );
        }
    }

}
```

What happens instead?

```
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class A {

    static class B {
        List<B> children = new ArrayList<>();

        Stream<B> subTree(A a) {
            return Stream.concat(
                Stream.of(this),
                children.stream().flatMap(a::subTree)
            );
        }
    }

}
```

Which doesn't compile, since there's no `subTree` in `A` anymore.","0"
"IDEA-170529","IntelliJ IDEA","","Internal error on introduce parameter (java.lang.Throwable)","Yegor Yarko","28/03/2017 14:16","17/03/2020 07:14",,"Normal","Exception",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">After the error, highlighting in the file is slow or broken (e.g. variable under the caret is not highlighted anymore), got &quot;another introdeuce parameter is in progress&quot; and more.<br/><div class=""wiki quote"">2017-03-28 18:59:21,280 [5885142]  ERROR - t.template.TemplateBuilderImpl - file: PsiJavaFile:ThreadStatWithPerf.java container: RangeMarker(3203,3674) 85900 markers: [[startPerfStat]2654, 2667], [[startPerfStat1]3262, 3276], [[startPerfStat]3294, 3307], [[startPerfStat]3363, 3376] <br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.Throwable</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.openapi.diagnostic.Logger.error(<a class=""dsLink"" txt=""com/intellij/openapi/diagnostic/Logger.java"" lne=""132"" title=""Open in IDE"">Logger.java:132</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.template.TemplateBuilderImpl.buildTemplate(<a class=""dsLink"" txt=""com/intellij/codeInsight/template/TemplateBuilderImpl.java"" lne=""212"" title=""Open in IDE"">TemplateBuilderImpl.java:212</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.template.TemplateBuilderImpl.buildInlineTemplate(<a class=""dsLink"" txt=""com/intellij/codeInsight/template/TemplateBuilderImpl.java"" lne=""185"" title=""Open in IDE"">TemplateBuilderImpl.java:185</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.a(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""394"" title=""Open in IDE"">InplaceRefactoring.java:394</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.access$000(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring/access.java"" lne=""98"" title=""Open in IDE"">InplaceRefactoring.java:98</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring$2.run(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""349"" title=""Open in IDE"">InplaceRefactoring.java:349</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.RunResult.run(<a class=""dsLink"" txt=""com/intellij/openapi/application/RunResult.java"" lne=""35"" title=""Open in IDE"">RunResult.java:35</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.lambda$null$1(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction/lambda.java"" lne=""171"" title=""Open in IDE"">WriteCommandAction.java:171</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""1023"" title=""Open in IDE"">ApplicationImpl.java:1023</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.lambda$performWriteCommandAction$2(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction/lambda.java"" lne=""170"" title=""Open in IDE"">WriteCommandAction.java:170</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.lambda$doExecuteCommand$4(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction/lambda.java"" lne=""210"" title=""Open in IDE"">WriteCommandAction.java:210</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.a(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""141"" title=""Open in IDE"">CoreCommandProcessor.java:141</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""119"" title=""Open in IDE"">CoreCommandProcessor.java:119</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.doExecuteCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction.java"" lne=""212"" title=""Open in IDE"">WriteCommandAction.java:212</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.performWriteCommandAction(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction.java"" lne=""168"" title=""Open in IDE"">WriteCommandAction.java:168</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.execute(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction.java"" lne=""151"" title=""Open in IDE"">WriteCommandAction.java:151</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.buildTemplateAndStart(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""351"" title=""Open in IDE"">InplaceRefactoring.java:351</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.performInplaceRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""216"" title=""Open in IDE"">InplaceRefactoring.java:216</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.a(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/AbstractInplaceIntroducer.java"" lne=""204"" title=""Open in IDE"">AbstractInplaceIntroducer.java:204</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.a(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""149"" title=""Open in IDE"">CoreCommandProcessor.java:149</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""109"" title=""Open in IDE"">CoreCommandProcessor.java:109</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""99"" title=""Open in IDE"">CoreCommandProcessor.java:99</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""85"" title=""Open in IDE"">CoreCommandProcessor.java:85</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/AbstractInplaceIntroducer.java"" lne=""189"" title=""Open in IDE"">AbstractInplaceIntroducer.java:189</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.IntroduceParameterHandler$Introducer.introduceParameter(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/IntroduceParameterHandler.java"" lne=""457"" title=""Open in IDE"">IntroduceParameterHandler.java:457</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.IntroduceParameterHandler.a(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/IntroduceParameterHandler.java"" lne=""212"" title=""Open in IDE"">IntroduceParameterHandler.java:212</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.IntroduceParameterHandler$3.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/IntroduceParameterHandler.java"" lne=""265"" title=""Open in IDE"">IntroduceParameterHandler.java:265</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent$ActionStandin.actionPerformed(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""3425"" title=""Open in IDE"">JComponent.java:3425</a>)<br/>&nbsp;<b>at</b> javax.swing.SwingUtilities.notifyAction(<a class=""dsLink"" txt=""javax/swing/SwingUtilities.java"" lne=""1663"" title=""Open in IDE"">SwingUtilities.java:1663</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyBinding(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2882"" title=""Open in IDE"">JComponent.java:2882</a>)<br/>&nbsp;<b>at</b> javax.swing.KeyboardManager.fireBinding(<a class=""dsLink"" txt=""javax/swing/KeyboardManager.java"" lne=""307"" title=""Open in IDE"">KeyboardManager.java:307</a>)<br/>&nbsp;<b>at</b> javax.swing.KeyboardManager.fireKeyboardAction(<a class=""dsLink"" txt=""javax/swing/KeyboardManager.java"" lne=""250"" title=""Open in IDE"">KeyboardManager.java:250</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyBindingsForAllComponents(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2974"" title=""Open in IDE"">JComponent.java:2974</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyBindings(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2966"" title=""Open in IDE"">JComponent.java:2966</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyEvent(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2845"" title=""Open in IDE"">JComponent.java:2845</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6310"" title=""Open in IDE"">Component.java:6310</a>)<br/>&nbsp;<b>at</b> java.awt.Container.processEvent(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2236"" title=""Open in IDE"">Container.java:2236</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4889"" title=""Open in IDE"">Component.java:4889</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2294"" title=""Open in IDE"">Container.java:2294</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4711"" title=""Open in IDE"">Component.java:4711</a>)<br/>&nbsp;<b>at</b> java.awt.KeyboardFocusManager.redispatchEvent(<a class=""dsLink"" txt=""java/awt/KeyboardFocusManager.java"" lne=""1954"" title=""Open in IDE"">KeyboardFocusManager.java:1954</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.dispatchKeyEvent(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""806"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:806</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.preDispatchKeyEvent(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""1074"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:1074</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.typeAheadAssertions(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""945"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:945</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.dispatchEvent(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""771"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:771</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeKeyboardFocusManager.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeKeyboardFocusManager.java"" lne=""27"" title=""Open in IDE"">IdeKeyboardFocusManager.java:27</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4760"" title=""Open in IDE"">Component.java:4760</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2294"" title=""Open in IDE"">Container.java:2294</a>)<br/>&nbsp;<b>at</b> java.awt.Window.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Window.java"" lne=""2746"" title=""Open in IDE"">Window.java:2746</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4711"" title=""Open in IDE"">Component.java:4711</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""758"" title=""Open in IDE"">EventQueue.java:758</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$500(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""97"" title=""Open in IDE"">EventQueue.java:97</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""709"" title=""Open in IDE"">EventQueue.java:709</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""703"" title=""Open in IDE"">EventQueue.java:703</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""80"" title=""Open in IDE"">ProtectionDomain.java:80</a>)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""90"" title=""Open in IDE"">ProtectionDomain.java:90</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""731"" title=""Open in IDE"">EventQueue.java:731</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""729"" title=""Open in IDE"">EventQueue.java:729</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""80"" title=""Open in IDE"">ProtectionDomain.java:80</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""728"" title=""Open in IDE"">EventQueue.java:728</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.d(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""827"" title=""Open in IDE"">IdeEventQueue.java:827</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""634"" title=""Open in IDE"">IdeEventQueue.java:634</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""365"" title=""Open in IDE"">IdeEventQueue.java:365</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""105"" title=""Open in IDE"">EventDispatchThread.java:105</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""101"" title=""Open in IDE"">EventDispatchThread.java:101</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""93"" title=""Open in IDE"">EventDispatchThread.java:93</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""82"" title=""Open in IDE"">EventDispatchThread.java:82</a>)</pre></details></div>2017-03-28 18:59:21,281 [5885143]  ERROR - t.template.TemplateBuilderImpl - IntelliJ IDEA 2017.1  Build #IU-171.3780.107 <br/>2017-03-28 18:59:21,282 [5885144]  ERROR - t.template.TemplateBuilderImpl - JDK: 1.8.0_121 <br/>2017-03-28 18:59:21,282 [5885144]  ERROR - t.template.TemplateBuilderImpl - VM: Java HotSpot(TM) 64-Bit Server VM <br/>2017-03-28 18:59:21,282 [5885144]  ERROR - t.template.TemplateBuilderImpl - Vendor: Oracle Corporation <br/>2017-03-28 18:59:21,282 [5885144]  ERROR - t.template.TemplateBuilderImpl - OS: Windows 7 <br/>2017-03-28 18:59:21,282 [5885144]  ERROR - t.template.TemplateBuilderImpl - Last Action: IntroduceParameter <br/>2017-03-28 18:59:21,282 [5885144]  ERROR - t.template.TemplateBuilderImpl - Current Command: Extract Parameter  <br/>2017-03-28 18:59:21,285 [5885147]  ERROR - llij.ide.plugins.PluginManager - String index out of range: -549 <br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.StringIndexOutOfBoundsException: String index out of range: -549</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> java.lang.String.substring(<a class=""dsLink"" txt=""java/lang/String.java"" lne=""1967"" title=""Open in IDE"">String.java:1967</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.template.TemplateBuilderImpl.buildTemplate(<a class=""dsLink"" txt=""com/intellij/codeInsight/template/TemplateBuilderImpl.java"" lne=""220"" title=""Open in IDE"">TemplateBuilderImpl.java:220</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.template.TemplateBuilderImpl.buildInlineTemplate(<a class=""dsLink"" txt=""com/intellij/codeInsight/template/TemplateBuilderImpl.java"" lne=""185"" title=""Open in IDE"">TemplateBuilderImpl.java:185</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.a(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""394"" title=""Open in IDE"">InplaceRefactoring.java:394</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.access$000(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring/access.java"" lne=""98"" title=""Open in IDE"">InplaceRefactoring.java:98</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring$2.run(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""349"" title=""Open in IDE"">InplaceRefactoring.java:349</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.RunResult.run(<a class=""dsLink"" txt=""com/intellij/openapi/application/RunResult.java"" lne=""35"" title=""Open in IDE"">RunResult.java:35</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.lambda$null$1(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction/lambda.java"" lne=""171"" title=""Open in IDE"">WriteCommandAction.java:171</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""1023"" title=""Open in IDE"">ApplicationImpl.java:1023</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.lambda$performWriteCommandAction$2(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction/lambda.java"" lne=""170"" title=""Open in IDE"">WriteCommandAction.java:170</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.lambda$doExecuteCommand$4(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction/lambda.java"" lne=""210"" title=""Open in IDE"">WriteCommandAction.java:210</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.a(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""141"" title=""Open in IDE"">CoreCommandProcessor.java:141</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""119"" title=""Open in IDE"">CoreCommandProcessor.java:119</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.doExecuteCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction.java"" lne=""212"" title=""Open in IDE"">WriteCommandAction.java:212</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.performWriteCommandAction(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction.java"" lne=""168"" title=""Open in IDE"">WriteCommandAction.java:168</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.WriteCommandAction.execute(<a class=""dsLink"" txt=""com/intellij/openapi/command/WriteCommandAction.java"" lne=""151"" title=""Open in IDE"">WriteCommandAction.java:151</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.buildTemplateAndStart(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""351"" title=""Open in IDE"">InplaceRefactoring.java:351</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.inplace.InplaceRefactoring.performInplaceRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/inplace/InplaceRefactoring.java"" lne=""216"" title=""Open in IDE"">InplaceRefactoring.java:216</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.a(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/AbstractInplaceIntroducer.java"" lne=""204"" title=""Open in IDE"">AbstractInplaceIntroducer.java:204</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.a(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""149"" title=""Open in IDE"">CoreCommandProcessor.java:149</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""109"" title=""Open in IDE"">CoreCommandProcessor.java:109</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""99"" title=""Open in IDE"">CoreCommandProcessor.java:99</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""85"" title=""Open in IDE"">CoreCommandProcessor.java:85</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/AbstractInplaceIntroducer.java"" lne=""189"" title=""Open in IDE"">AbstractInplaceIntroducer.java:189</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.IntroduceParameterHandler$Introducer.introduceParameter(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/IntroduceParameterHandler.java"" lne=""457"" title=""Open in IDE"">IntroduceParameterHandler.java:457</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.IntroduceParameterHandler.a(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/IntroduceParameterHandler.java"" lne=""212"" title=""Open in IDE"">IntroduceParameterHandler.java:212</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.IntroduceParameterHandler$3.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/IntroduceParameterHandler.java"" lne=""265"" title=""Open in IDE"">IntroduceParameterHandler.java:265</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent$ActionStandin.actionPerformed(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""3425"" title=""Open in IDE"">JComponent.java:3425</a>)<br/>&nbsp;<b>at</b> javax.swing.SwingUtilities.notifyAction(<a class=""dsLink"" txt=""javax/swing/SwingUtilities.java"" lne=""1663"" title=""Open in IDE"">SwingUtilities.java:1663</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyBinding(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2882"" title=""Open in IDE"">JComponent.java:2882</a>)<br/>&nbsp;<b>at</b> javax.swing.KeyboardManager.fireBinding(<a class=""dsLink"" txt=""javax/swing/KeyboardManager.java"" lne=""307"" title=""Open in IDE"">KeyboardManager.java:307</a>)<br/>&nbsp;<b>at</b> javax.swing.KeyboardManager.fireKeyboardAction(<a class=""dsLink"" txt=""javax/swing/KeyboardManager.java"" lne=""250"" title=""Open in IDE"">KeyboardManager.java:250</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyBindingsForAllComponents(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2974"" title=""Open in IDE"">JComponent.java:2974</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyBindings(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2966"" title=""Open in IDE"">JComponent.java:2966</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processKeyEvent(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""2845"" title=""Open in IDE"">JComponent.java:2845</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6310"" title=""Open in IDE"">Component.java:6310</a>)<br/>&nbsp;<b>at</b> java.awt.Container.processEvent(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2236"" title=""Open in IDE"">Container.java:2236</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4889"" title=""Open in IDE"">Component.java:4889</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2294"" title=""Open in IDE"">Container.java:2294</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4711"" title=""Open in IDE"">Component.java:4711</a>)<br/>&nbsp;<b>at</b> java.awt.KeyboardFocusManager.redispatchEvent(<a class=""dsLink"" txt=""java/awt/KeyboardFocusManager.java"" lne=""1954"" title=""Open in IDE"">KeyboardFocusManager.java:1954</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.dispatchKeyEvent(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""806"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:806</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.preDispatchKeyEvent(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""1074"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:1074</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.typeAheadAssertions(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""945"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:945</a>)<br/>&nbsp;<b>at</b> java.awt.DefaultKeyboardFocusManager.dispatchEvent(<a class=""dsLink"" txt=""java/awt/DefaultKeyboardFocusManager.java"" lne=""771"" title=""Open in IDE"">DefaultKeyboardFocusManager.java:771</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeKeyboardFocusManager.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeKeyboardFocusManager.java"" lne=""27"" title=""Open in IDE"">IdeKeyboardFocusManager.java:27</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4760"" title=""Open in IDE"">Component.java:4760</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2294"" title=""Open in IDE"">Container.java:2294</a>)<br/>&nbsp;<b>at</b> java.awt.Window.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Window.java"" lne=""2746"" title=""Open in IDE"">Window.java:2746</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4711"" title=""Open in IDE"">Component.java:4711</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""758"" title=""Open in IDE"">EventQueue.java:758</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$500(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""97"" title=""Open in IDE"">EventQueue.java:97</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""709"" title=""Open in IDE"">EventQueue.java:709</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""703"" title=""Open in IDE"">EventQueue.java:703</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""80"" title=""Open in IDE"">ProtectionDomain.java:80</a>)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""90"" title=""Open in IDE"">ProtectionDomain.java:90</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""731"" title=""Open in IDE"">EventQueue.java:731</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""729"" title=""Open in IDE"">EventQueue.java:729</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""80"" title=""Open in IDE"">ProtectionDomain.java:80</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""728"" title=""Open in IDE"">EventQueue.java:728</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.d(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""827"" title=""Open in IDE"">IdeEventQueue.java:827</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""634"" title=""Open in IDE"">IdeEventQueue.java:634</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""365"" title=""Open in IDE"">IdeEventQueue.java:365</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""105"" title=""Open in IDE"">EventDispatchThread.java:105</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""101"" title=""Open in IDE"">EventDispatchThread.java:101</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""93"" title=""Open in IDE"">EventDispatchThread.java:93</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""82"" title=""Open in IDE"">EventDispatchThread.java:82</a>)</pre></details></div>2017-03-28 18:59:21,286 [5885148]  ERROR - llij.ide.plugins.PluginManager - IntelliJ IDEA 2017.1  Build #IU-171.3780.107 <br/>2017-03-28 18:59:21,286 [5885148]  ERROR - llij.ide.plugins.PluginManager - JDK: 1.8.0_121 <br/>2017-03-28 18:59:21,286 [5885148]  ERROR - llij.ide.plugins.PluginManager - VM: Java HotSpot(TM) 64-Bit Server VM <br/>2017-03-28 18:59:21,286 [5885148]  ERROR - llij.ide.plugins.PluginManager - Vendor: Oracle Corporation <br/>2017-03-28 18:59:21,286 [5885148]  ERROR - llij.ide.plugins.PluginManager - OS: Windows 7 <br/>2017-03-28 18:59:21,286 [5885148]  ERROR - llij.ide.plugins.PluginManager - Last Action: IntroduceParameter  </div></div>
","0"
"IDEA-188299","IntelliJ IDEA","reproduced","Broken Java rename","Krzysztof Szafranski","15/03/2018 07:10","11/03/2020 05:40",,"Normal","Bug",,"anet","Java. Refactorings","2017.3.5 (173.4674.33)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I rename an inner class of a generic class, methods that return an instance of the inner class, but with a different type parameter of the outer class are broken. The &quot;prefix&quot; containing the outer class with the type parameter disappears. Please see the attachment for a minimal example.</div>
","0"
"IDEA-176400","IntelliJ IDEA","reproduced","Replace with extracted interface produces broken code when target class is used as a generic parameter","Matt Wallace","21/07/2017 12:19","10/03/2020 15:05",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When performing the &quot;Extract Interface&quot; refactoring, IDEA asks if you want to replace instances of the original class with references to the extracted interface.  This produces broken code if the original class was used as a generic parameter to some other class (such as Map) AND if some users of the original class can be replaced but some cannot.  I have attached two tar files that demonstrate the problem.  The first is before refactoring and the second is after refactoring.  The refactoring performed was &quot;Extract Interface&quot;, select getX and getZ to extract and then say yes when asking to replace found usages.</div>
","0"
"IDEA-234253","IntelliJ IDEA","","Refactor menu shows Rename and Rename File items, so what's the difference?","Nicolas Kick","02/03/2020 07:12","03/03/2020 11:30",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","The menu is opened from the Project Navigator.

IU-193.6494.35, JRE 11.0.5+10-b520.38x64 JetBrains s.r.o, OS Mac OS X(x86_64) v10.15.3, screens 2560x1440, 1680x1050; Retina","0"
"IDEA-230171","IntelliJ IDEA","","Directories order in the completion list is wrong","Sergey Ignatov","05/01/2020 15:22","02/03/2020 07:01",,"Normal","Bug",,"Vassiliy.Kudryashov","Java. Refactorings","2019.3 (193.5233.102), 2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I think we should show messages first according to `me` prefix.
![](image.png)","0"
"IDEA-231896","IntelliJ IDEA","","Introduce Functional Parameter should check for duplicates","Sergey Sindeev","31/01/2020 05:39","31/01/2020 07:51",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Hello,

I've found that 'Introduce Functional Parameter' refactoring  does not check that the value has duplicates.
Let's consider a simple example

class Scratch {

    public static void main(String[] args) {
        printHello();
    }

    private static void printHello() {
        System.out.println(""Hello world"");
        System.out.println(""Hello world"");
    }
}


If I want to extract ""Hello world"" string as a parameter, then IDEA checks for duplicates and asks me whether I want to replace all duplicates or not.
I.e. the result is:

class Scratch {

    public static void main(String[] args) {
        printHello(""Hello world"");
    }

    private static void printHello(String text) {
        System.out.println(text);
        System.out.println(text);
    }
}

However, for ""Introduce Functional Parameter"" IDEA does not check for duplicates and the result of refactoring is:
class Scratch {

    public static void main(String[] args) {
        printHello(() -> ""Hello world"");
    }

    private static void printHello(Supplier<String> supplier) {
        System.out.println(supplier.get());
        System.out.println(""Hello world"");
    }
}


It would be nice if IDEA could check for duplicate and produce the following result:

class Scratch {

    public static void main(String[] args) {
        printHello(() -> ""Hello world"");
    }

    private static void printHello(Supplier<String> supplier) {
        String text = supplier.get();
        System.out.println(text);
        System.out.println(text);
    }
}

IC-193.6015.39, JRE 11.0.5+10-b520.30x64 JetBrains s.r.o, OS Linux(amd64) v4.15.0-72-generic, screens 2560x1440, 1920x1080","0"
"IDEA-231572","IntelliJ IDEA","","Pull Members Up refactoring malfunction","Maxim Degtyarev","27/01/2020 20:44","28/01/2020 08:07",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Steps to reproduce:

1. Create new Java project with two classes, `Base` and `Descendant` (attached) with the following content:

```java
public class Base {

}
```

```java
import java.util.List;

public class Descendant extends Base {

    private static final String DESCRIPTOR_INT = ""I"";

    private final String enumClassName;
    private final String binaryEnumClassName;
    private final String binaryEnumArrayClassName;

    private final String descriptorNoargEnum;
    private final String descriptorNoargEnumArray;
    private final String descriptorEnumArrayIntEnumArray;
    private final String descriptorStringEnum;

    private final List<String> elementNames;

    public Descendant(String enumClassName, List<String> elementNames) {
        this.enumClassName = enumClassName;

        this.binaryEnumClassName = ""L"" + enumClassName + "";"";
        this.binaryEnumArrayClassName = ""[""+ binaryEnumClassName;

        this.descriptorNoargEnum = ""()"" + binaryEnumClassName;
        this.descriptorNoargEnumArray = ""()"" + binaryEnumArrayClassName;
        this.descriptorEnumArrayIntEnumArray = ""("" + binaryEnumArrayClassName + DESCRIPTOR_INT + "")"" + binaryEnumArrayClassName;
        this.descriptorStringEnum = ""(Ljava/lang/String;)"" + binaryEnumClassName;

        this.elementNames = elementNames;
    }

    public static Descendant newInstance(String enumClassName, List<String> elementNames) {
        return new Descendant(enumClassName, elementNames);
    }

    @Override
    public String toString() {
        return ""Descendant{"" +
            ""enumClassName='"" + enumClassName + '\'' +
            "", binaryEnumClassName='"" + binaryEnumClassName + '\'' +
            "", binaryEnumArrayClassName='"" + binaryEnumArrayClassName + '\'' +
            "", descriptorNoargEnum='"" + descriptorNoargEnum + '\'' +
            "", descriptorNoargEnumArray='"" + descriptorNoargEnumArray + '\'' +
            "", descriptorEnumArrayIntEnumArray='"" + descriptorEnumArrayIntEnumArray + '\'' +
            "", descriptorStringEnum='"" + descriptorStringEnum + '\'' +
            "", elementNames="" + elementNames +
            '}';
    }

}
```

2. In the `Descendant` class invoke refactoring `Pull Members Up`
3. Select all fields defined in the class to be pulled up to the `Base`. Ensure field `descriptorEnumArrayIntEnumArray` selected too
4. Perform refactoring by pressing `Refactor` button

Expected behaviour:

- All members correctly pulled up

Actual behaviour:

- Parameter list of the `Base` class constructor contains two parameters named `enumClassName`
- Declaration of the field `descriptorEnumArrayIntEnumArray` moved to the `Base` class, but assignment remains in the `Descendant` class constructor

---

IntelliJ IDEA 2020.1 EAP (Community Edition)
Build #IC-201.3803.71, built on January 24, 2020
Runtime version: 11.0.5+9-b674.2 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 7 6.1
GC: ParNew, ConcurrentMarkSweep
Memory: 972M
Cores: 4
Registry: 
Non-Bundled Plugins:","0"
"IDEA-230741","IntelliJ IDEA","","Change Signature and change of method visibility","Valentin Kipiatkov","15/01/2020 16:47","16/01/2020 08:42",,"Normal","Usability Problem",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","1. If I change visibility via Change Signature refactoring to a greater one (e.g. from protected to public), it shows conflicts about all overriding methods that they have inconsistent visibility. I don't understand where the conflict is. I would expect the refactoring to change the visibility of overrides accordingly and I don't see any other solution in this case. It's the same as any other signature changes, like changing return type.

2. If I change visibility via Change Signature refactoring to a lesser one (e.g. from public to protected), it silently doesn't do anything with visibility of overrides. Although it's not against Java language-specification, I find this behaviour both unexpected and inconvenient. In most of the cases, I would like to change the visibility of overrides to the same one. And I don't know any other IDEA feature that would allow me to do this. And in case I would like to change the visibility of the base method only, I wouldn't use the refactoring at all.","0"
"IDEA-230742","IntelliJ IDEA","","Change Signature: adding an exception to the throws list overwrites exceptions in overrides","Valentin Kipiatkov","15/01/2020 17:01","16/01/2020 06:47",,"Normal","Bug",,"anet","Java. Refactorings","2020.1 (201.6668.121)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
interface I {
    void foo() throws Exception1;
}

class C implements I {
    public void foo() { }
}
```

Note that the implementation in class C does not throw Exception1.
Add Exception2 to the throws list of the method in the interface via Change Signature refactoring. The refactoring not only adds Exception2 to the throws list of C.foo(), but also puts there Exception1. It's not desired behaviour.","0"
"IDEA-124862","IntelliJ IDEA","","refactoring moving packages","Pascal Knueppel","07/05/2014 09:26","26/12/2019 08:50",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">when trying to move some packages with a single subpackage from one package to another only the leaf-package is moved which is really annoying.<br/><br/>e.g. if the package structure looks like this:<br/><br/>src.main.java<br/>   - de.test<br/>             - Test.java<br/>             - ...<br/>   - com.org.something<br/>             - Something.java<br/>             - ...<br/><br/>if I now try to move &quot;com.org.something&quot; to &quot;de.test&quot; only the package &quot;something&quot; is moved and there is no way to configure IDEA to do it as I wanted it to. If you try this the new package structure looks like this:<br/><br/>src.main.java<br/>   - de.test<br/>             .something<br/>                     - Something.java<br/>                     - ...<br/>             - Test.java<br/>             - ...<br/>   - com.org<br/><br/>don&#39;t misunderstand me, it is great that IntelliJ can do that but that is just not enough. Because this does not work as I wanted it to I had to correct all the package-names and imports manually. This really was&#39;nt funny.</div>
","1"
"IDEA-229188","IntelliJ IDEA","","After inlining a constant, place the caret on the next constant","Roland Illig","14/12/2019 20:46","16/12/2019 10:47",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Open https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition.
2. Open the `TestConstants` class.
3. Inline all the constants from that class.

What is the expected result?

After inlining each of the constants using Ctrl+Alt+N, the caret is placed on the _name_ of the next constant.

What happens instead?

After inlining each of the constants using Ctrl+Alt+N, the caret is placed on the beginning of the next declaration. Pressing Ctrl+Alt+N there does not inline anything.","0"
"IDEA-229006","IntelliJ IDEA","","When replacing toString method, prefer current toString method's position","Chris","12/12/2019 06:54","12/12/2019 09:52",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When IntelliJ *replaces* a toString method, it should prefer (or give me an option) the place where the current toString method is.

![](image1.png)

I sometimes put region comments around the IDE generated methods, when IntelliJ replaces the method and puts it at the end of the class, it will place it *after* my region comment.

In general, I think replacing the method should always honor the original position, that's the most intuitive behavior.

![](image.png)","0"
"IDEA-228831","IntelliJ IDEA","","In-place introduce parameter: I can't choose name before tweaking other settings","Peter Gromov","10/12/2019 08:47","10/12/2019 12:35",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I want to both choose the second name suggestion (BTW I'd appreciate it being the default one) and delegate via overloading method. Now I have to remember to do the former first, otherwise when I choose the name from lookup the refactoring is performed immediately.
![](image.png)","0"
"IDEA-226090","IntelliJ IDEA","","Extract Delegate refactoring leaves dead code","johan martinsson","02/11/2019 08:10","05/11/2019 06:39",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","As shown in this screen capture extract delegate leaves dead code in the current class


-- version information --
IntelliJ IDEA 2019.2.3 (Ultimate Edition)
Build #IU-192.6817.14, built on September 24, 2019
Licensed to johan martinsson
You have a perpetual fallback license for this version
Subscription is active until October 29, 2020
Runtime version: 11.0.4+10-b304.69 x86_64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
macOS 10.14.6
GC: ParNew, ConcurrentMarkSweep
Memory: 4916M
Cores: 12
Registry: ide.mac.allowDarkWindowDecorations=true
Non-Bundled Plugins: org.nik.presentation-assistant","0"
"IDEA-225990","IntelliJ IDEA","","Changing signature of method by adding or removing parameter of lambda doesn't update lambda at creation site","Nicolas Kick","31/10/2019 10:00","01/11/2019 04:51",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","For instance, changing a BiConsumer to a Consumer doesn't automatically remove one parameter from all the sites which create this lambda.","0"
"IDEA-106357","IntelliJ IDEA","reproduced","Incorrect ""extract variable"" behavior in some cases","VAeolus","28/04/2013 16:13","28/10/2019 11:16",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Let&#39;s type:<br/>    len = &quot;test&quot;.length()<br/>and activate &quot;Extract variable&quot; hotkey.<br/><br/>Expected result (it&#39;s Eclipse behavior):<br/>    int len = &quot;test&quot;.length();<br/>Actual result:<br/>    int length = &quot;test&quot;.length();<br/>    len = length<br/><br/>I liked this approach very much when I used Eclipse:<br/>    type variable name &ndash;&gt; type expression &ndash;&gt; press hotkey to insert variable type.<br/>While in IDEA:<br/>    expression &ndash;&gt; hotkey &ndash;&gt; insert variable name. <br/><br/>Eclipse way is more convenient, more direct. This is the same way I&#39;m thinking. When I&#39;m coding I think:<br/>&quot;I need variable &#39;len&#39; and it should be assigned with the expression &lt;expression&gt;&quot;.<br/>Moreover if I&#39;ve already declared variable somewhere above I&#39;m typing:  &quot;varName = expression&quot;. It&#39;s very convenient to type this identically regardless whether variable declared or not.<br/><br/>Any way current &quot;Extract variable&quot; behavior in this case is meaningless.</div>
","0"
"IDEA-223954","IntelliJ IDEA","","Smarter refactoring of expressions","Nicolas Kick","01/10/2019 09:43","01/10/2019 14:00",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Here is some sample code:
```
private void main() {
    final var suffix = ""suffix"";

    final var a = ""a"";
    final var b = ""b"";
    final var c = ""c"";
    final var d = ""d"";
    final var e = a + b + c + d;

    final var a2 = ""a"" + suffix;
    final var b2 = ""b"" + suffix;
    final var c2 = ""c"" + suffix;
    final var d2 = ""d"" + suffix;
    final var e2 = a2 + b2 + c2 + d2;
}
```

When selecting the lines where variables a-e are defined and pressing Cmd-Opt-M to refactor out a method, I get this:
```
private void main() {
    final var suffix = ""suffix"";

    asd(""a"", ""b"", ""c"", ""d"");

    asd(""a"" + suffix, ""b"" + suffix, ""c"" + suffix, ""d"" + suffix);
}

private void asd(String a3, String b3, String c3, String d3) {
    final var a = a3;
    final var b = b3;
    final var c = c3;
    final var d = d3;
    final var e = a + b + c + d;
}
```
But I would have expected to end up with this:
```
private void main() {
    final var suffix = ""suffix"";

    asd("""");

    asd(suffix);
}

private void asd() {
    final var a = ""a"" + suffix;
    final var b = ""b"" + suffix;
    final var c = ""c"" + suffix;
    final var d = ""d"" + suffix;
    final var e = a + b + c + d;
}
```","0"
"IDEA-223533","IntelliJ IDEA","","Incorrect ""visibility conflict"" detection when moving static method","Chris","25/09/2019 07:52","25/09/2019 10:39",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","1. Package A: Contains public static method
1. Package B: Uses said method (no other packages use said method)
1. Use ""Move refactoring"" on said method to move it to package B, set visibility to ""package-private""

Hit ""Refactor""

## Expected behavior

Move method without warning, since a package-private method that will only be in the same package as it's declared works fine.

## Current behavior

A conflict dialog shows up and says ""package-private method will not be accessible from target package""

IntelliJ IDEA 2019.2.3 (Ultimate Edition)
Build #IU-192.6817.9, built on September 17, 2019
Subscription is active until March 14, 2020
Runtime version: 11.0.4+10-b304.69 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0
GC: ParNew, ConcurrentMarkSweep
Memory: 2966M
Cores: 4
Registry: analyze.exceptions.on.the.fly=true, ide.balloon.shadow.size=0","0"
"IDEA-223398","IntelliJ IDEA","","""use any var"" sometimes does not work when changing signature","luo yanfu","24/09/2019 00:01","24/09/2019 06:46",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When I add an **int** to the **method** , the call statement in **invokeMethod** is able to find the variable **i**, but when I add a **double** to **method**, it is unable to find the variable **d**.



```
// before
public class UseAnyVar {
    // change the signature of this method
    public void method(){
        System.out.println(""hello"");
    }
    public void invokeMethod() {
        int i = 1;
        double d = 1.1;
        method();
    }
}

// after adding a parameter of type int
public class UseAnyVar {
    public void method(int aa){
        System.out.println(""hello"");
    }

    public void invokeMethod() {
        int i = 1;
        double d = 1.1;
        // Success in adding ""i""
        method(i);
    }
}

public class UseAnyVar {
    public void method(double dd){
        System.out.println(""hello"");
    }

    public void invokeMethod() {
        int i = 1;
        double d = 1.1;
        // failed to add the variable ""d""
        method();
    }
}
```
See attachments for more details.

![intOk](intOk.gif)
![doubleFail](doubleFail.gif)


IU-192.6603.28, JRE 11.0.3 12-b304.56x64 JetBrains s.r.o, OS Windows 10(amd64) v10.0 , screens 2560x1080, 1920x1080","1"
"IDEA-223047","IntelliJ IDEA","","When renaming a getter / setter suggest a name based on the involved field name","Dmitry Cherniachenko","18/09/2019 11:41","20/09/2019 12:03",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Here is an example:
![](image.png)

I think it would have been quite useful if IDEA suggested `getChangeTimeSec` as one of the options.
(And get rid of that 'getTimestamp' which matches the current name exactly and makes no sense.)

P.S. There should also be a similar QuickFix for the ""Suspicious getter/setter"" inspection - ""Rename to 'getChangeTimeSec'"".","0"
"IDEA-222776","IntelliJ IDEA","","Propose ""foo"" as a variable name when extracting a variable from ""fooBuilder.build()""","Артем Шевченко","16/09/2019 09:18","16/09/2019 09:53",,"Normal","Feature",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I also think it should be the first option in the list.","0"
"IDEA-75225","IntelliJ IDEA","reproduced","Allow to add/remove/modify type parameters in the Change signature dialog","Andrey Breslav","05/10/2011 13:08","14/09/2019 01:56",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If I try to change signature of the following method:<br/><pre class=""wikicode prettyprint"">    &lt;D extends CallableDescriptor&gt; void recordAmbiguity(BindingTrace trace, Collection&lt;ResolvedCall&lt;D&gt;&gt; candidates);</pre>I don&#39;t see the type parameter in the dialog.<br/>Neither can I add a type parameter to a method that doesn&#39;t have any yet.</div>
","10"
"IDEA-203962","IntelliJ IDEA","","IDEA adds unncecessary cast to List on method inline","Andrey Turbanov","10/12/2018 10:40","05/09/2019 14:34",,"Normal","Bug",,"anet","Java. Refactorings","2019.1 (191.6183.87), 2018.3.2 (183.4886.37)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    public static List&lt;Integer&gt; prepare(ArrayList&lt;Integer&gt; list) {<br/>        return doSome(list);<br/>    }<br/><br/>    public static List&lt;Integer&gt; doSome(List&lt;Integer&gt; events) {<br/>        Integer last = events.get(events.size() - 1);<br/>        return events;<br/>    }</pre><br/>Inline method <code class=""inline-code"">doSome</code><br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">    public static List&lt;Integer&gt; prepare(ArrayList&lt;Integer&gt; list) {<br/>        Integer last = list.get(list.size() - 1);<br/>        return list;<br/>    }</pre><br/><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">    public static List&lt;Integer&gt; prepare(ArrayList&lt;Integer&gt; list) {<br/>        Integer last = ((List&lt;Integer&gt;) list).get(((List&lt;Integer&gt;) list).size() - 1);<br/>        return list;<br/>    }</pre><br/><br/>IntelliJ IDEA 2018.3.2 EAP (Ultimate Edition)<br/>Build #IU-183.4886.3, built on December 6, 2018<br/>Licensed to Expert-Systema LLC<br/><br/>JRE: 1.8.0_152-release-1136-b38 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 8.1 6.3</div>
","1"
"IDEA-221878","IntelliJ IDEA","","Reference counter of usages not updated after user re-runs search during refactoring","Timur Yuldashev","03/09/2019 10:28","03/09/2019 11:18",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">193.2956.1<br/><br/><pre class=""wikicode prettyprint"">class A {<br/>    void foo() {<br/>        B&lt;caret&gt; b = new B();<br/>    }<br/>}<br/><br/>class B {}<br/><br/>class C {<br/>    void foo() {<br/>        // B b = new B();<br/>    }<br/>}</pre>1. Create a class <span class=""monospace"">A</span> with reference to another class <span class=""monospace"">B</span>.<br/>2. Start renaming class &quot;Shift-F6&quot; twice, change class name and open Preview<br/>3. When preview is opened, add reference to <span class=""monospace"">B</span> from yet another class <span class=""monospace"">C</span><br/>4. Press &quot;Do Refactor&quot; button - IDEA suggest to Rerun search.<br/>5. After search completed counter shows 2 references instead of 4<br/><br/><strong>After using Re-run search</strong><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/><strong>When start Rename with updated code</strong><br/><div class=""wiki picture""><img src=""[](image1.png)""/></div></div>
","0"
"IDEA-221474","IntelliJ IDEA","","Incorrect ""Problems detected"" view","Dmitry Krasilschikov","27/08/2019 11:55","02/09/2019 09:29",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Try to inline <code class=""inline-code"">showPopup(e)</code> method into <code class=""inline-code"">actionPerformed()</code> - the problem detected dailog appears but if continue there will be zero errors.<br/><br/>IntelliJ IDEA 2019.3 Snapshot (Ultimate Edition)<br/>Build #IU-193.2569, built on August 22, 2019<br/>IntelliJ IDEA EAP User<br/>Expiration date: September 21, 2019<br/>Runtime version: 11.0.4+12-b419.1 x86_64<br/>VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>macOS 10.14.4<br/>GC: ParNew, ConcurrentMarkSweep<br/>Memory: 4012M<br/>Cores: 12<br/>Registry: analyze.exceptions.on.the.fly=true, java.completion.argument.hints.internal=false, ide.mac.allowDarkWindowDecorations=true, java.find.usages.always.use.top.hierarchy.methods=false, copy.tbx.reference.enabled=true, vcs.annotations.preload=true<br/>Non-Bundled Plugins: Jetbrains TeamCity Plugin, com.intellij.sisyphus, com.jetbrains.CyanTheme, com.jetbrains.darkPurpleTheme, com.jetbrains.grayTheme, org.jetbrains.kotlin, com.jetbrains.intellij.api.watcher, training</div>
","0"
"IDEA-221686","IntelliJ IDEA","","""Make Static"" refactoring doesn't generify constructor calls","Roman Leventov","30/08/2019 07:35","30/08/2019 15:45",,"Normal","Cosmetics",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```java
    class Foo<T> {
        void foo() {
            Bar bar = new Bar();
        }
        class Bar {
            void bar() {
                foo();
            }
        }
    }
```
After applying ""Make Static"" refactoring to `Bar`:
```java
    class Foo<T> {
        void foo() {
            Bar bar = new Bar(this); // <- a raw constructor call
        }
        static class Bar<T> {
            private Foo<T> foo;

            public Bar(Foo<T> foo) {
                this.foo = foo;
            }

            void bar() {
                foo.foo();
            }
        }
    }
```

IntelliJ IDEA 2019.2.1 (Community Edition)
Build #IC-192.6262.58, built on August 20, 2019","0"
"IDEA-221687","IntelliJ IDEA","","""Make Static"" refactoring should create a final field","Roman Leventov","30/08/2019 07:38","30/08/2019 09:07",,"Normal","Cosmetics",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```java
    class Foo<T> {
        void foo() {
            Bar bar = new Bar();
        }
        class Bar {
            void bar() {
                foo();
            }
        }
    }
```
After applying ""Make Static"" refactoring to `Bar`:
```java
    class Foo<T> {
        void foo() {
            Bar bar = new Bar(this);
        }
        static class Bar<T> {
            private Foo<T> foo; // <- should be a final field

            public Bar(Foo<T> foo) {
                this.foo = foo;
            }

            void bar() {
                foo.foo();
            }
        }
    }
```

IntelliJ IDEA 2019.2.1 (Community Edition)
Build #IC-192.6262.58, built on August 20, 2019","0"
"IDEA-221647","IntelliJ IDEA","","Extract variable produces red code: Array initializer is not allowed here","Bas Leijdekkers","29/08/2019 12:27","30/08/2019 05:50",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Before:
```
class X {
  void x() {
    <caret>new String[] {""one"", ""two""};
  }
}
```

Invoke Extract Variable and select ""declare var type"" produces:
```
class X {
  void x() {
    final var strings = {""one"", ""two""};
  }
}
```
Which does not compile because an array initializer and a var type do not combine.

Note also that once ""declare var type"" is selected, it is not possible anymore to declare a variable with an explicit type. Unselecting ""declare var type"" does not work in in-place mode.","0"
"IDEA-162706","IntelliJ IDEA","","New Refactoring: replace setter with builder pattern","Benny Bottema","17/10/2016 08:57","29/08/2019 05:10",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;m in the process of refactoring a mutable object in an immutable one. To accomplish this I&#39;m getting rid of setters and turn them into building methods.<br/><br/>As an intermediary automated refactoring step, observe the following example:<br/><br/><pre class=""wikicode prettyprint"">class Foo {<br/>   private boolean bar;<br/><br/>   public void setBar(boolean bar) {<br/>      this.bar = bar;<br/>   }<br/>}<br/><br/>Foo foo = new Foo();<br/>foo.setBar(true);</pre><br/>I would like to refactor this <em>assignment</em> so that it works as a builder instead:<br/><br/><pre class=""wikicode prettyprint"">class Foo {<br/>   private boolean bar;<br/><br/>   public Foo setBar(boolean bar) {<br/>      this.bar = bar;<br/>      return this;<br/>   }<br/>}<br/><br/>Foo foo = new Foo();<br/>foo = foo.setBar(true);</pre></div>
","0"
"IDEA-221340","IntelliJ IDEA","","Renaming inner class can cause qualifier to be removed, breaking code","Stefan","26/08/2019 04:21","26/08/2019 09:16",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?

Rename `B.Inner` to `Inner2` in this code:

```java
class A extends B<A.Inner> {
    public static class Inner extends B.Inner {}
}

class B<E> {
    public static class Inner {}
}
```

What is the expected result?

The `extends B.Inner` becomes `extends B.Inner2`.


What happens instead?

The `extends B.Inner` becomes `extends Inner2`, giving an ""Inner2 is not accessible in the current context"" error on the generic argument `A.Inner`.","0"
"IDEA-221265","IntelliJ IDEA","","Extracting variable results in uncompilable code (not a statement)","Paweł Baczyński","23/08/2019 11:27","26/08/2019 06:48",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Given the code

```
import java.util.Arrays;
import java.util.List;

public class Temp {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 3, 4);
        System.out.println(""Third element is "" + list.get(2));

        list.get(2);
    }
}
```

2. Extract `list.get(2)` (doesn't matter which one)  to a variable and select replace all occurrences.

What is the expected result?
```
import java.util.Arrays;
import java.util.List;

public class Temp {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 3, 4);
        Integer integer = list.get(2);
        System.out.println(""Third element is "" + integer);
    }
}
```
What happens instead?

Results in an uncompilable code as `integer;` is not a statement.
```
import java.util.Arrays;
import java.util.List;

public class Temp {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 3, 4);
        Integer integer = list.get(2);
        System.out.println(""Third element is "" + integer);

        integer;
    }
}
```


Help -> About
```
IntelliJ IDEA 2019.2.1 (Ultimate Edition)
Build #IU-192.6262.58, built on August 20, 2019
Runtime version: 11.0.3+12-b304.39 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Linux 5.0.0-25-generic
GC: ParNew, ConcurrentMarkSweep
Memory: 1930M
Cores: 4
Registry: 
Non-Bundled Plugins: Lombook Plugin, br.com.br.com.breakpoint.breakpoint.toogleAll, com.jetbrains.lightThemePreview, net.ashald.envfile, net.seesharpsoft.intellij.plugins.csv, Karma, Pythonid, org.mapstruct.intellij, ru.adelf.idea.dotenv, ua.in.dej.myEmmet
```","0"
"IDEA-219407","IntelliJ IDEA","","Duplicated Extraction","Enrico Messall","29/07/2019 16:23","23/08/2019 06:06",,"Normal","Feature",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Dear Jetbrains,

your feature to extract duplicated lines of codes is very nice. One thing is missing for me. The option to set an Class where something like ""Utils"" Methods can be placed at, if method is public static. One option is the Project Explorer. Some ""great"" Graphic in the attachments.

Kind regards,
Enrico","0"
"IDEA-221063","IntelliJ IDEA","","'Extract parameter' with delegation references locals in context of the delegating method","Anton Lobov","21/08/2019 06:17","21/08/2019 06:56",,"Normal","Bug",,"anet","Java. Refactorings","2019.3 (193.5233.102)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
class QImpl {
    void m() {
        String q = ""q"";
        String foo = ""b"" + q; // <--
    }
}
```

Invoke 'Extract parameter' for `""b"" + q`, tick 'delegate via overloading method', get:
```
class QImpl {
    void m() {
        m(""b"" + q);   // <-- but 'q' doesn't exist here
    }

    void m(String foo1) {
        String q = ""q"";
        String foo = foo1;

    }
}
```","0"
"IDEA-152103","IntelliJ IDEA","","No generify option for incompatible assignment","Danila Galimov","24/02/2016 10:53","20/08/2019 12:14",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have a sample invalid code:<br/><pre class=""wikicode prettyprint"">public class Test {<br/>    private static final Map&lt;String, String&gt; ersTypeMap = ImmutableMap.builder().<br/>            put(&quot;1&quot;, &quot;2&quot;)<br/>           .build();<br/>}</pre><br/>However, pressing Alt+enter offers me to:<br/>1) Change the results of build() - but this is not possible since this is a library code. Library code should be considered as read only and no refactorings should be provided to it.<br/>2) No generify option. I would expect it here, and, when selected, it should fix the code to:<br/><pre class=""wikicode prettyprint"">    private static final Map&lt;String, String&gt; ersTypeMap = ImmutableMap.&lt;String, String&gt;builder().<br/>            put(&quot;1&quot;, &quot;2&quot;)<br/>            .build();</pre></div>
","1"
"IDEA-148039","IntelliJ IDEA","","Hot key to highlight variables that should be captured to lambda or anonymous class scope.","Bogdan Storozhuk","16/11/2015 15:33","14/08/2019 04:25",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It would be very useful in certain cases just press some hot key combination and see all variables that will be captured for your lambda or anonymous class.</div>
","7"
"IDEA-140101","IntelliJ IDEA","","Refactor Rename: automatically trim trailing spaces","Andrey Dernov","08/05/2015 11:17","13/08/2019 05:05",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Expected: blank space should be trimmed ?<br/><br/>I expected that it will not give me this kind of message but will allow to change name of the class. I expected same behavior as if I try to paste new name without blank space. <br/>Think if you will do trim for the string to be pasted it would be nice</div>
","1"
"IDEA-220272","IntelliJ IDEA","","Progress bar of Looking for Usages dialog triggered by safe delete starts over and over again","Nicolas Kick","08/08/2019 12:24","09/08/2019 09:10",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown",,"0"
"IDEA-32913","IntelliJ IDEA","","IDEA is very slow and unresponsive when renameing/moving heavily used classes","Igor Sereda","25/07/2006 20:49","07/08/2019 15:41",,"Major","Performance Problem",,"cdr","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am moving to another package a class that is used in about 1000 classes within the project. It takes about 20 minutes with 100% CPU burn to complete and IDEA is an unresponsive grey-box during the process.<br/><br/>I have taken the profiler snapshot of what&#39;s going on. (Attached) <br/>It seems that most of the time is spent optimizing imports. This is not needed (in my case, at least) because when the code is committed to the vcs, imports are optimized.<br/><br/><br/><br/>Environment: Windows XP</div>
","13"
"IDEA-219101","IntelliJ IDEA","","""Extract Constant"" refactoring replaces not all substring occurrences in the file","Maxim Degtyarev","25/07/2019 20:13","26/07/2019 09:12",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Given:<br/><br/><pre class=""wikicode prettyprint"">class TestExtractSubstring {<br/><br/>    public String replaceFoo(String line) {<br/>        return line<br/>            .replaceFirst(&quot;(^\\s*//\\s*[A-Za-z]+\\s*-\\s*)(?!see:)((?:Array|FixedArray)\\s*\\([^)]+\\)|[A-Za-z]+(?:\\.[A-Za-z]+)?)([,]|\\.\\s|$)&quot;, &quot;$1$2 - $2$3&quot;)<br/>            .replaceFirst(&quot;(^\\s*//\\s*[A-Za-z]+\\s*-\\s*)(Managed form)&quot;, &quot;$1ClientApplicationForm - $2&quot;)<br/>            .replaceAll(&quot;Object of type ([A-Za-z]+)&quot;, &quot;$1 - $0&quot;);<br/>    }<br/><br/>    public String replaceBar(String line) {<br/>        return line<br/>            .replaceAll(&quot;Object of type ([A-Za-z]+)&quot;, &quot;$1 - $0&quot;)<br/>            .replaceFirst(&quot;(^\\s*//\\s*)(Result\\s*-\\s*([A-Za-z]+\\s*-\\s*))&quot;, &quot;$1$3$2&quot;)<br/>            .replaceFirst(&quot;(^\\s*//\\s*)(Result(\\s*-\\s*)([A-Za-z]+\\s*))$&quot;, &quot;$1$4$3$2&quot;);<br/>    }<br/><br/>}</pre><br/>Steps to reproduce:<br/><br/>1. Select first occurrence of <code class=""inline-code"">[A-Za-z]+</code><br/>2. Invoke &quot;Extract Constant&quot; refactoring<br/>3. Ensure &quot;Replace all occurrences&quot; checkbox in refactoring dialog is checked<br/><br/>Expected result:<br/><br/><ul class=""wiki-list0""><li> All 8 occurrences should be replaced with constant.</li></ul><br/>Actual result:<br/><br/><ul class=""wiki-list0""><li> Only 6 out of 8 entries replaced.</li></ul><br/>Current refactoring result:<br/><br/><pre class=""wikicode prettyprint"">class TestExtractSubstring {<br/><br/>    private static final String A_ZA_Z = &quot;[A-Za-z]+&quot;;<br/><br/>    public String replaceFoo(String line) {<br/>        return line<br/>            .replaceFirst(&quot;(^\\s*//\\s*&quot; + A_ZA_Z + &quot;\\s*-\\s*)(?!see:)((?:Array|FixedArray)\\s*\\([^)]+\\)|[A-Za-z]+(?:\\.[A-Za-z]+)?)([,]|\\.\\s|$)&quot;, &quot;$1$2 - $2$3&quot;)<br/>            .replaceFirst(&quot;(^\\s*//\\s*&quot; + A_ZA_Z + &quot;\\s*-\\s*)(Managed form)&quot;, &quot;$1ClientApplicationForm - $2&quot;)<br/>            .replaceAll(&quot;Object of type (&quot; + A_ZA_Z + &quot;)&quot;, &quot;$1 - $0&quot;);<br/>    }<br/><br/>    public String replaceBar(String line) {<br/>        return line<br/>            .replaceAll(&quot;Object of type (&quot; + A_ZA_Z + &quot;)&quot;, &quot;$1 - $0&quot;)<br/>            .replaceFirst(&quot;(^\\s*//\\s*)(Result\\s*-\\s*(&quot; + A_ZA_Z + &quot;\\s*-\\s*))&quot;, &quot;$1$3$2&quot;)<br/>            .replaceFirst(&quot;(^\\s*//\\s*)(Result(\\s*-\\s*)(&quot; + A_ZA_Z + &quot;\\s*))$&quot;, &quot;$1$4$3$2&quot;);<br/>    }<br/><br/>}</pre><br/><hr/><br/>IntelliJ IDEA 2019.2 (Ultimate Edition)<br/>Build #IU-192.5728.98, built on July 23, 2019<br/>Licensed to Maxim Degtyarev<br/>Subscription is active until January 3, 2020<br/>Runtime version: 11.0.3+12-b304.2 amd64<br/>VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 7 6.1<br/>GC: ParNew, ConcurrentMarkSweep<br/>Memory: 972M<br/>Cores: 4<br/>Registry: java.completion.argument.hints.internal=false<br/>Non-Bundled Plugins:</div>
","0"
"IDEA-217986","IntelliJ IDEA","","Extract delegate improvements","vinz243","10/07/2019 07:14","10/07/2019 09:20",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When dealing with technical debt, it is quite common to refactor white elephants classes where every logic is in the same (very long) file that contains many depencies between each method.

## 1. Allow browsing source when selecting methods

Right now the dialog where I select the methods I want to delegate does not allow me to see the content of the methods I want to delegate, which makes the operation really tedious, even more so because you can't extract delegate on an existing interface

## 2. Show a graph of the method depencies

This one would help a lot. If IntelliJ could show a dependency graph between every method showing who calls who., it would help figure out a refactoring starting point and how to shape it.

## 3. Use delegates

Very simple example :

```java
class Test {

    String doA () {
        return doB();
    }
    
    void doC () {
        doB();
    }

    private String doB () {
        // ...
    }
}
```

When Extracting delegate on a method, it will create a new class which constructor takes as a parameter an instance of the class I extracted from which perpetuates circular dependency. Let's take the example from above and extract delegate on doB :

```
class Test {
    private final B b = new B();

    String doA () {
        return b.doB();
    }

    void doC () {
        b.doB();
    }

    private String doB () {
        return b.doB();
    }
}

class B {
    public B () {
    }

    String doB () {
        return ""foo"";
    }
}
```

And now if I extract delegate on `doA` :

```java
class A {
    private final Test test;

    public A (Test test) {
        this.test = test;
    }

    String doA () {
        return test.getB().doB();
    }
}
```

Whereas `A` only need `B` not `Test. I would except something like 

```java
class A {
    private final B b;

    public A (B b) {
        this.b = b;
    }

    String doA () {
        return b.doB();
    }
}
```","0"
"IDEA-217733","IntelliJ IDEA","","In-place inline refactoring dialog","Dmitry Krasilschikov","07/07/2019 10:32","09/07/2019 09:50",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">There is a useful &quot;Inline method/class/constant&quot; modal dialog.<br/><br/>Let&#39;s try to make it in-place popup (like &quot;choose expression&quot; for extract variable and others) and highlight usages to inplace in the current editor.</div>
","0"
"IDEA-217326","IntelliJ IDEA","","Inappropriate rename suggestion list","Dmitry Krasilschikov","01/07/2019 13:43","07/07/2019 13:36",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","I'm about to rename e.g. `com.intellij.openapi.fileEditor.impl.IdeDocumentHistoryImpl.RecentlyChangedFilesState` and get the following suggestion list:
 - `recentlyChangedFilesState`
 - `recentlyChangedFilesState`
 - `RecentlyChangedFilesState`

All three variants look inappropriate. 

IntelliJ IDEA 2019.3 Snapshot (Ultimate Edition)
Build #IU-193.752, built on June 30, 2019
IntelliJ IDEA EAP User
Expiration date: July 30, 2019
Runtime version: 11.0.3+12-b326.2 x86_64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
macOS 10.14.4
GC: G1 Young Generation, G1 Old Generation
Memory: 4096M
Cores: 12
Registry: analyze.exceptions.on.the.fly=true, java.completion.argument.hints.internal=false, ide.mac.allowDarkWindowDecorations=true, copy.tbx.reference.enabled=true, git.explicit.commit.renames.prohibit.multiple.calls=false, vcs.annotations.preload=true
Non-Bundled Plugins: Jetbrains TeamCity Plugin, com.intellij.sisyphus, com.jetbrains.CyanTheme, com.jetbrains.darkPurpleTheme, com.jetbrains.grayTheme, com.jetbrains.intellij.api.watcher, org.jetbrains.plugins.ruby, training

![](image.png)","0"
"IDEA-216427","IntelliJ IDEA","","""Rename method"" refactoring affects other methods in the class with same name but different signatures.","J Goldberg","17/06/2019 14:21","21/06/2019 06:06",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","When you rename a method (Shift-f6) IDEA renames all methods with the same name in a class, rather than just the specific method (by signature) that is selected to rename.

As an aside, it may be useful in some cases to rename all methods with the same name, but I don't think this should be default.  If it's going to be possible, I think that should be ""opt-in"" and not a surprise.  i.e., a blank checkbox saying something like ""4 other methods called ""beep"" were found with alternate signatures.  Rename them as well?""  Honestly, though, the efficiency boost doesn't seem important enough, since the user can do it themselves by doing several renames in succession (and can check intermediate results.)

It's critical, though, to be able to rename exactly one method signature and all its callers and overrides — and I cannot find any way to do that currently.  (I'm doing a ""manual"" rename in order to make my two methods easier to distinguish right now, and I am nervous I may introduce errors.)

What steps will reproduce the issue?
1. Create a class with two different methods of the same name (e.g., void beep() and void beep(String x))
2. Rename one of the methods

What is the expected result?
Only that method (and any corresponding implementations, interface signatures and callers) should be changed.

What happens instead?
All methods with the same name are renamed.","0"
"IDEA-210401","IntelliJ IDEA","","Canceling renaming (refactoring) has no effect","Nicolas Kick","04/04/2019 06:25","20/06/2019 13:48",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.1 (191.6183.87), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Sometimes when renaming a symbol I get a dialog asking if I want to rename other related symbols (such as Rename Inheritors, Rename Variables). Even if I click Cancel on the first dialog, the others are still shown, and in the end I am shown the Refactoring Preview panel where again I can select Cancel or Do Refactor. Clicking on Cancel should abort the whole process and stop showing any further dialogs.

IntelliJ IDEA 2019.1.","1"
"IDEA-205303","IntelliJ IDEA","","I feel like I ought to be asked if I want to have the method signature changed to   return the  variable type of the return statement","tr","13/01/2019 10:31","14/06/2019 13:20",,"Normal","Usability Problem",,"anet","Java. Refactorings","2018.3.4 (183.5429.30)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The issue is explained fully by the attached png. I had just typed the return statement. I feel like at this point I ought to see a refactoring offer to have the variable in the return statement returned from the method, but I don&#39;t. <br/><br/>Yes there is a lot of of forward programming going on (none of the methods exist yet) but I don&#39;t see that that should make any difference here. I am explicitly saying &quot;return this variable from this method&quot;. The method has no defined return value yet . It ought to be asking me to the prom, but it&#39;s not. <br/><br/>I can&#39;t put my finger on it (ha ha ) but I feel like the autosuggest lightbulb feature was smarter last version  2018.2. I am not sure how to describe it but I feel like its  IQ dropped a little. I doesn&#39;t offer obvious things. It does offer irrelevancies. I  know that is a vague description that no one can take action on, so I am including the image and the above description as an example of this overall perception.</div>
","0"
"IDEA-215756","IntelliJ IDEA","","Java inner class import behavior not respected by refactoring actions","Brendan Douglas","06/06/2019 14:47","07/06/2019 11:35",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">What steps will reproduce the issue?<br/>1. Enable &#39;Insert imports for inner classes&#39;, and add some common exceptions to &#39;Editor &gt; Code Style &gt; Java &gt; Imports &gt; Exclude inner classes by short name&#39;, for example Builder<br/>2. add any &#39;Foo.Builder&#39; inner class to a method&#39;s parameter list (<br/>3. run the &#39;change signature&#39; refactoring, and add any other parameter to the method<br/>4. the &#39;Foo.Builder&#39; parameter has been changed to &#39;Builder&#39;, and Foo.Builder is now imported<br/><br/>What is the expected result?<br/><br/>The &#39;Exclude inner classes by short name&#39; behavior is respected, and the &#39;Foo.Builder&#39; parameter remains unchanged<br/><br/>What happens instead?<br/><br/>Step 4.</div>
","1"
"IDEA-126543","IntelliJ IDEA","reproduced","Preserve outer class of parameter types when refactoring","Michael Wallstedt","24/06/2014 15:38","07/06/2019 11:35",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Our code base is inconsistent with the imports of inner classes. In some cases only the outer class is imported, in other cases the inner class is imported directly. This means we cannot rely on the option given under Settings &gt; Code Style &gt; Java &gt; Imports &gt; Insert imports for inner classes. The problem is that unrelated changes will force current code to adapt to that setting. For example, let&#39;s say &#39;Insert imports for inner classes&#39; is selected, and we have the following code:<br/><br/><span class=""monospace"">import com.acme.Foo;<br/><br/>public void (Foo.Bar bar, String s) { }</span><br/><br/>A simple refactoring like switching the parameter order gives us<br/><br/><span class=""monospace"">import com.acme.Foo.Bar;<br/><br/>public void (String s, Bar bar) { }</span><br/><br/>We expect that the original import strategy should be preserved in this case.</div>
","0"
"IDEA-215470","IntelliJ IDEA","","Change signature refactoring: Auto-Completion of @throws in code documentation is missing after adding an exception to the method signature","Markus Eberl","03/06/2019 09:47","04/06/2019 06:14",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98), 2019.1.3 (191.7479.19)",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the problem?
1. Create e.g. a Java interface with a simple ""void test()"" method and create the code documentation (using /** + ENTER) for this method
2. Add Exception using the ""change signature"" refactoring

What is the expected result?
The @throws line should be added to the code documentation automatically (like it is the case for e.g. @param after adding a parameter with ""change signature"").

What happens instead?
No documentation line is added. The code documentation stays the same but the code itself is changed as excepted.","0"
"IDEA-167202","IntelliJ IDEA","","Extract method object: allow to choose existing wrapper ","Anna Kozlova","26/01/2017 14:22","29/05/2019 13:30",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Given code below <br/><pre class=""wikicode prettyprint""><br/>class Struct {<br/>    private int i;<br/>    private int j;<br/><br/>    public Struct(int i, int j) {<br/>        this.i = i;<br/>        this.j = j;<br/>    }<br/><br/>    public int getI() {<br/>        return i;<br/>    }<br/><br/>    public int getJ() {<br/>        return j;<br/>    }<br/>}<br/>public class EEEE {<br/>    String foo(boolean bool) {<br/>        int i = 0;<br/>        int j = 0;<br/>        if (bool) {<br/>            i++;<br/>        }<br/>        else {<br/>            j++;<br/>        }<br/>        System.out.println(&quot;i:&quot; + i + &quot;; j:&quot; + j);<br/>        return &quot;&quot;;<br/>    }<br/>}<br/></pre><br/>I&#39;d like to get new method signature Struct newMethod(), returning new Struct(i, j)<br/><br/>See Introduce Parameter Object to find appropriate candidates based on parameters selection. I believe additional radio button in extract method object dialog could be a good start and could be used when refactoring is called explicitly as well.</div>
","0"
"IDEA-215111","IntelliJ IDEA","","Join lines for assignments with identical RHS value","Dmitry Cherniachenko","28/05/2019 12:38","29/05/2019 09:42",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When there are two consecutive assignment statements with identical RHS values IDEA could merge them into one multi-assignment when joining the lines.<br/><br/>Here are some examples.<br/>Before:<br/><pre class=""wikicode prettyprint"">stardDate = null;<br/>endDate = null;</pre>After Join Lines (Ctrl+Shift+J):<br/><pre class=""wikicode prettyprint"">stardDate = endDate = null;</pre><br/>Before:<br/><pre class=""wikicode prettyprint"">stardDate = date;<br/>endDate = date;</pre>After Join Lines (Ctrl+Shift+J):<br/><pre class=""wikicode prettyprint"">stardDate = endDate = date;</pre><br/>Assignments should not be merged if the RHS expression is not idempotent.</div>
","0"
"IDEA-215179","IntelliJ IDEA","","Add ""change method signature"" refactoring onto method parameter/arguments","Dmitry Krasilschikov","29/05/2019 06:47","29/05/2019 09:31",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">There is a powerful &quot;change method signature&quot; refactoring that we can become more discoverable. <br/><br/>Let&#39;s add it into the &quot;Alt+Enter&quot; popup if a caret is on the method parameters/arguments block.<br/><br/>There is only &quot;flip&quot; intention here that actually doesn&#39;t change the method declaration but only flips two symbols.</div>
","0"
"IDEA-214881","IntelliJ IDEA","","Undo Move of a main class does not update its run configuration","Alexander Chernikov","23/05/2019 16:39","24/05/2019 05:32",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><a href=""/issue/IDEA-36423"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-64169"" title=""Undo move or rename package or class does not update run configuration"">IDEA-36423</a> reborn.<br/><br/>In a package <code class=""inline-code"">pack1</code> create a Java class with <code class=""inline-code"">main()</code> method. Run from context, run configuration is created.<br/>Refactor / Move the class to package <code class=""inline-code"">pack2</code>. The run configuration is updated with new package name of the main class, great.<br/>Undo Move. The run configuration is not updated, and now invalid.<br/><br/>IDEA 192.4297.</div>
","0"
"IDEA-214704","IntelliJ IDEA","","Rename non-code occurrences of a variable outside of syntactic scope","Roman Leventov","21/05/2019 13:28","22/05/2019 14:29",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```java
void foo() {
    // note: bar is initialized inside the loop.
    for (int i = 0; i < 10; i++) {
      int bar = 0;
    }
  }
```
(Renaming ""bar"" doesn't suggest to rename the non-code occurrence in the comment)

I think IntelliJ is too smart here, not searching for mentions of a variable in comments which go above in syntactic scope.","0"
"IDEA-85050","IntelliJ IDEA","","Suggest to replace object construction and getter with constructor parameter","akram ajouli","23/04/2012 03:56","05/05/2019 02:27",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have the following program:<br/><br/><pre class=""wikicode prettyprint"">// Class A<br/><br/>class A {<br/><br/>    public void m(int i) {<br/>        new B(i).n(this);<br/>    }<br/>}<br/><br/>// Class B<br/> <br/>class B{<br/>    private final int i;<br/><br/>    public B(int i) {<br/>        this.i = i;<br/>    }<br/><br/>    public int getI() {<br/>        return i;<br/>    }<br/><br/>    public void n(A a){<br/>        System.out.println(&quot;Coloration of A&quot;+ a+&quot; with the color&quot;+ getI());<br/>    }<br/><br/>}</pre><br/><br/>I will inline the method n and remove its declaration, so I get the following result:<br/><br/><pre class=""wikicode prettyprint"">// Class A <br/><br/> class A {<br/><br/>    public void m(int i) {<br/>         System.out.println(&quot;Coloration of A&quot;+ this +&quot; with the color&quot;+ new B(i).getI());<br/>    }<br/>}<br/><br/>// Class B<br/> <br/>class B{<br/>    private final int i;<br/><br/>    public B(int i) {<br/>        this.i = i;<br/>    }<br/><br/>    public int getI() {<br/>        return i;<br/>    }<br/> <br/>}</pre><br/>The problem here is that the expression new B(i).getI() should be reduced to i since the instance of B is built under the parameter i<br/>of the method m, so the access of this instance to the method getI() of the class B should give us this i. I like to know if you could take this reduction into account of the operation inline of the refactoring tool.<br/><br/>What I like to get is:<br/><br/><pre class=""wikicode prettyprint"">class A {<br/><br/>    public void m(int i) {<br/>         System.out.println(&quot;Coloration of A&quot;+ this +&quot; with the color&quot;+i);<br/>    }<br/>}<br/><br/>// Class B<br/> <br/>class B{<br/>    private final int i;<br/><br/>    public B(int i) {<br/>        this.i = i;<br/>    }<br/><br/>    public int getI() {<br/>        return i;<br/>    }<br/> <br/>}</pre><br/>Best regards,</div>
","0"
"IDEA-193265","IntelliJ IDEA","would be good to fix","Failed to extract a method from a subexpression within a lambda body","Pavel Dolgov","04/06/2018 12:08","26/04/2019 14:03",,"Normal","Exception",,"anet","Java. Refactorings","2018.2 (182.3684.101)",,"Submitted","Not specified","No tester","No","Ongoing","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Here&#39;s the code sample:<br/><pre class=""wikicode prettyprint"">void foo(List&lt;String&gt; a, String b) {<br/>        a.forEach(s -&gt; {<br/>            String[] p = s.split(&quot; &quot;);<br/>            System.out.println(&quot;a&quot; +<br/>                    b + &quot;b&quot; + p[1] // extract a method from this line<br/>            );<br/>        });<br/>    }</pre><br/>And here&#39;s the exception:<br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.Throwable: Assertion failed: PsiReferenceExpression:s</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.openapi.diagnostic.Logger.assertTrue(<a class=""dsLink"" txt=""com/intellij/openapi/diagnostic/Logger.java"" lne=""163"" title=""Open in IDE"">Logger.java:163</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.IntroduceVariableBase.replace(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/IntroduceVariableBase.java"" lne=""1102"" title=""Open in IDE"">IntroduceVariableBase.java:1102</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodProcessor.doExtract(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodProcessor.java"" lne=""1035"" title=""Open in IDE"">ExtractMethodProcessor.java:1035</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodProcessor.lambda$doRefactoring$9(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodProcessor/lambda.java"" lne=""869"" title=""Open in IDE"">ExtractMethodProcessor.java:869</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""1028"" title=""Open in IDE"">ApplicationImpl.java:1028</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodProcessor.doRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodProcessor.java"" lne=""877"" title=""Open in IDE"">ExtractMethodProcessor.java:877</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.doRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""193"" title=""Open in IDE"">ExtractMethodHandler.java:193</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.lambda$null$0(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler/lambda.java"" lne=""183"" title=""Open in IDE"">ExtractMethodHandler.java:183</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.PostprocessReformattingAspect.lambda$postponeFormattingInside$2(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/PostprocessReformattingAspect/lambda.java"" lne=""127"" title=""Open in IDE"">PostprocessReformattingAspect.java:127</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.PostprocessReformattingAspect.postponeFormattingInside(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/PostprocessReformattingAspect.java"" lne=""137"" title=""Open in IDE"">PostprocessReformattingAspect.java:137</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.PostprocessReformattingAspect.postponeFormattingInside(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/PostprocessReformattingAspect.java"" lne=""126"" title=""Open in IDE"">PostprocessReformattingAspect.java:126</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.lambda$extractMethod$1(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler/lambda.java"" lne=""182"" title=""Open in IDE"">ExtractMethodHandler.java:182</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""139"" title=""Open in IDE"">CoreCommandProcessor.java:139</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""97"" title=""Open in IDE"">CoreCommandProcessor.java:97</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""87"" title=""Open in IDE"">CoreCommandProcessor.java:87</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""73"" title=""Open in IDE"">CoreCommandProcessor.java:73</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.extractMethod(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""181"" title=""Open in IDE"">ExtractMethodHandler.java:181</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.invokeOnElements(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""168"" title=""Open in IDE"">ExtractMethodHandler.java:168</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.access$000(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler/access.java"" lne=""61"" title=""Open in IDE"">ExtractMethodHandler.java:61</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler$3.pass(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""154"" title=""Open in IDE"">ExtractMethodHandler.java:154</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler$3.pass(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""151"" title=""Open in IDE"">ExtractMethodHandler.java:151</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodProcessor.applyChosenClassAndExtract(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodProcessor.java"" lne=""2011"" title=""Open in IDE"">ExtractMethodProcessor.java:2011</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodProcessor.chooseTargetClass(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodProcessor.java"" lne=""1904"" title=""Open in IDE"">ExtractMethodProcessor.java:1904</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodProcessor.prepare(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodProcessor.java"" lne=""266"" title=""Open in IDE"">ExtractMethodProcessor.java:266</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.getProcessor(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""237"" title=""Open in IDE"">ExtractMethodHandler.java:237</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.invokeOnElements(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""151"" title=""Open in IDE"">ExtractMethodHandler.java:151</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler$1.pass(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""79"" title=""Open in IDE"">ExtractMethodHandler.java:79</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler$1.pass(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""77"" title=""Open in IDE"">ExtractMethodHandler.java:77</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.selectAndPass(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""110"" title=""Open in IDE"">ExtractMethodHandler.java:110</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.extractMethod.ExtractMethodHandler.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/extractMethod/ExtractMethodHandler.java"" lne=""82"" title=""Open in IDE"">ExtractMethodHandler.java:82</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/actions/BaseRefactoringAction.java"" lne=""131"" title=""Open in IDE"">BaseRefactoringAction.java:131</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil$1.run(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""220"" title=""Open in IDE"">ActionUtil.java:220</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""88"" title=""Open in IDE"">TransactionGuardImpl.java:88</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.submitTransactionAndWait(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""153"" title=""Open in IDE"">TransactionGuardImpl.java:153</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""235"" title=""Open in IDE"">ActionUtil.java:235</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""620"" title=""Open in IDE"">IdeKeyEventDispatcher.java:620</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.lambda$processAction$2(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher/lambda.java"" lne=""669"" title=""Open in IDE"">IdeKeyEventDispatcher.java:669</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""195"" title=""Open in IDE"">TransactionGuardImpl.java:195</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""668"" title=""Open in IDE"">IdeKeyEventDispatcher.java:668</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processActionOrWaitSecondStroke(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""520"" title=""Open in IDE"">IdeKeyEventDispatcher.java:520</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.inInitState(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""475"" title=""Open in IDE"">IdeKeyEventDispatcher.java:475</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""212"" title=""Open in IDE"">IdeKeyEventDispatcher.java:212</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""697"" title=""Open in IDE"">IdeEventQueue.java:697</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""382"" title=""Open in IDE"">IdeEventQueue.java:382</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""105"" title=""Open in IDE"">EventDispatchThread.java:105</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""101"" title=""Open in IDE"">EventDispatchThread.java:101</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""93"" title=""Open in IDE"">EventDispatchThread.java:93</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""82"" title=""Open in IDE"">EventDispatchThread.java:82</a>)</pre></details></div><br/>See also EA-121612</div>
","0"
"IDEA-190496","IntelliJ IDEA","","Method extract refactoring works incorrectly with non denotable types","Roman Ivanov","18/04/2018 06:36","26/04/2019 12:53",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
class Test {
    void f() {
        var x = new Object() {
            int a = 12;
        };
        x.a;
    }
}
```
after extraction of `x.a`:
```
class Test {
    void f() {
        var x = new Object() {
            int a = 12;
        };
        getA(x);
    }

    private int getA(Object x) {
        return x.a;
    }
}
```
Where `a` is unresolved in `getA`

Probably here we should create real class from anonymous ones.","0"
"IDEA-208959","IntelliJ IDEA","would be good to fix","Red code after extracting a method that has conditional output","Pavel Dolgov","14/03/2019 08:23","26/04/2019 12:36",,"Normal","Bug",,"anet","Java. Refactorings","2019.1 (191.6183.87), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","It is important that `array` is a field here. If it's a method's parameter the failure doesn't occur.
```
class C {
  String[] array;

  boolean test(String a, String b) {
    for (String s : array) {
      if (a.equals(s)) {
        // selection start
        if (b == null) {
          return true;
        }
        if (b.equals(s)) {
          return true;
        }
        // selection end
      }
    }
    return false;
  }
}
```
The result of the refactoring doesn't compile:
```
  private void newMethod(String b, String s) {
    if (b == null) {
      return true;
    }
    if (b.equals(s)) {
      return true;
    }
  }
```

And one more similar case:
```
  String test() {
    while (true) {
      try {
        return get();
      }
      catch (Exception e) {}
      // selection start
      if (foo()) {
        return null;
      }
      if (bar()) {
        return null;
      }
      // selection end
    }
  }

  String get() { return null; }
  boolean foo() { return false; }
  boolean bar() { return false; }
```","0"
"IDEA-205226","IntelliJ IDEA","","Extracting a method from the contents of a labeled block containing break-with-label produces red code","Pavel Dolgov","11/01/2019 08:42","26/04/2019 11:59",,"Normal","Bug",,"anet","Java. Refactorings","2019.1 (191.6183.87), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```java  void foo(int y) {
    boolean done;
    labeledBlock:
    {
      if (y == 0) {
        System.out.println(""if"");
        done = true;
        break labeledBlock;
      }
      else {
        System.out.println(""else"");
        done = true;
        break labeledBlock;
      }
    }
    System.out.println(""done = "" + done);
  }
```

The result is like this:
```java
  void foo(int y) {
    boolean done;
    labeledBlock:
    {
      done = isDone(y);
    }
    System.out.println(""done = "" + done);
  }

  private boolean isDone(int y) {
    boolean done;
    if (y == 0) {
      System.out.println(""if"");
      done = true;
      break labeledBlock;
    }
    else {
      System.out.println(""else"");
      done = true;
      break labeledBlock;
    }
    return done;
  }
```","0"
"IDEA-209968","IntelliJ IDEA","","Extract parameter refactoring should work on class specified as input argument","Edoardo Luppi","29/03/2019 05:52","26/04/2019 04:25",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Shelved","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">From this StackOverflow <a href=""https://stackoverflow.com/questions/55353440/intellij-refactor-signature-to-use-parameters-properties/55366933"" target=""_blank"" rel=""noopener noreferrer"">question</a>, a great feature to have would be expanding the refactoring action <strong>Extract parameter</strong> to swap a class argument with multiple arguments representing its exposed fields (via getters, or public properties).<br/><br/>Given<br/><pre class=""wikicode prettyprint"">class Model {<br/>   private String one;<br/>   private String two;<br/><br/>   // Getters / Setters<br/>}</pre>Starting point<br/><pre class=""wikicode prettyprint"">public long sum(final Model model) {<br/>   final String useOne = model.getOne();<br/>   final String useTwo = model.getTwo();<br/>   ...<br/>}</pre>Ending point<br/><pre class=""wikicode prettyprint"">public long sum(final String one, final String two) {<br/>   final String useOne = one;<br/>   final String useTwo = two;<br/>   ...<br/>}</pre>An additional enhancement would be offering a popup to allow inlining usages by default.</div>
","0"
"IDEA-192768","IntelliJ IDEA","","Extract variable refactoring does not find multiple occurrences if functions are prefixed differently with this","Andrei Diaconu","28/05/2018 02:30","25/04/2019 17:14",,"Normal","Bug",,"anet","Java. Refactorings","2018.1.5 (181.5284.24), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">What steps will reproduce the issue?<br/>1. Given the code:<br/><pre class=""wikicode prettyprint""><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>String getValue() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return &quot;&quot;;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void test() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(this.getValue());<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(getValue());<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre>2. Move cursor to one call of getValue()<br/>3. Extract Variable (CTRL + ALT + V)<br/><br/>What is the expected result?<br/>I would expect the small &quot;Multiple occurrences&quot; dialog, giving me the option to replace all calls or just the current one.<br/><br/>What happens instead?<br/>Variable is create and only the current call is replaced. IDEA does not consider both calls identical for replacement.<br/><br/>Please note that problem is symmetrical: you can pick any of the calls.</div>
","0"
"IDEA-20787","IntelliJ IDEA","reproduced","'introduce variable' could be smarter","andrey belomutskiy","21/11/2008 05:30","25/04/2019 16:49",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Open","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int h = 3;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int a = h + 3;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int b = h + 3;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int c = +(h) + 3;<br/><br/>try introducing variable for &quot;h + 3&quot; expression from the &#39;a=...&#39; statement<br/><br/>&#39;(h) +3&#39; is not detected as a copy of &#39;h + 3&#39; and is not replaced with the newly introduces variable</div>
","1"
"IDEA-211688","IntelliJ IDEA","","Class rename: find occurrences in any identifiers and lowercase comment occurrences","Roman Leventov","25/04/2019 13:11","25/04/2019 14:14",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```java
class Test {
  class Zxzx {}

  boolean zxzxIsInitialized;

  /**
   * zxzx
   */
  void bar() {
    Zxzx zxzx;
  }
}
```

Here, rename of `Zxzx` to anything else leads to suggestions to rename neither `zxzxIsInitialized` field nor `zxzx` appearance in a comment.","0"
"IDEA-208916","IntelliJ IDEA","","Extracting a method produces red code when the original fragment contains 'break'","Pavel Dolgov","13/03/2019 13:22","25/04/2019 13:21",,"Normal","Bug",,"anet","Java. Refactorings","2019.1 (191.6183.87), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
  int test(String[] a, String s) {
    int n = -1;
    for (int i = 0; i < a.length; i++) {
      if (s.equals(a[i])) {
        n = i;
        break;
      }
    }
    return n;
  }
```
The fragment to extract from is the two lines `n = i;` and `break;` (the contents of the `if` code block)
The result is like this:
```
  private int getN(int i) {
    int n;
    n = i;
    return n;
    return n;
  }
```
The second `return` is not reachable.","0"
"IDEA-168902","IntelliJ IDEA","","Usual class to reflection","Tarik Weiss","01/03/2017 06:36","25/04/2019 11:58",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">What would be really nice, if you can use (Ctrl) + (Enter) to create a reflected version of a usual code. That means create reflected method calls, and create reflected classes and so on. Also enable reflected call and mark if this method of a call is not exisiting. In summary it means, also view code assistance for reflected class and enable conversion between them :) </div>
","1"
"IDEA-124560","IntelliJ IDEA","","IntelliJ locate code duplicates - elimate duplicates icon inactive in result","Andrey Dernov","28/04/2014 11:07","25/04/2019 11:40",,"Normal","Bug",,"Alexandr.Suhinin","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Intellij 13.1.2 <br/>Windows 7 64 Bit <br/>Oracle Java 8 1.8.0_05<br/><br/>Problem: Unable to refactor using button &quot;Eliminate Duplicate Code&quot; in Duplicate Code Inspection result window - icon greyed out<br/><br/>Steps to repeat: <br/><ul class=""wiki-list0""><li> select menu analyze/locate code duplicates <br/></li><li> Get a list of dupe code sorted <br/></li><li> select top one, docs say should be able to refactor/eliminate dupe with extract method enhanced dialogue <br/><ul class=""wiki-list1""><li> But the icon is greyed out - can&#39;t refector. <br/><ul class=""wiki-list2""><li> The refactor icon (magnifying glass and letter A icon on left of the dupe/diff screen at bottom) greyed out? <br/></li></ul></li></ul></li><li> Select arrows on one of the dupe code items, blue and green left and right on same code <br/><ul class=""wiki-list1""><li> still icon is greyed out<br/></li></ul><br/></li></ul></div>
","1"
"IDEA-85726","IntelliJ IDEA","we'd better shelve it","intention to refactor overly-broad argument type","Dave Yost","06/05/2012 21:25","25/04/2019 08:39",,"Normal","Feature",,"basleijdekkers","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider:<br/><pre class=""wikicode prettyprint"">    ...<br/>    updateMaxNumber(foo);<br/>    ...<br/><br/>  void updateMaxNumber(final Foo foo) {<br/>    if (maxNumber &lt; foo.number) {<br/>      maxNumber = foo.number;<br/>    }<br/>  }</pre>As you see, no other fields of Foo are used in this method. I think there should be an intention to narrow the argument thus:<br/><pre class=""wikicode prettyprint"">    ...<br/>    updateMaxNumber(foo.number);<br/>    ...<br/><br/>  void updateMaxNumber(final int number) {<br/>    if (maxNumber &lt; number) {<br/>      maxNumber = number;<br/>    }<br/>  }</pre></div>
","0"
"IDEA-211098","IntelliJ IDEA","","Bug: Inconsistency in extract variable refactoring with ternary operator in IntelliJ IDEA 2019.1","Mala Gupta","16/04/2019 02:34","25/04/2019 00:59",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2019.1 (191.6183.87), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Description: Extract variable refactoring with ternary operator behaves differently, when:<br/>a) It is used to return a value that could added to a HashMap.<br/>b) it is used to assign a value to a variable.<br/><br/><br/>1) Sample code:<br/><br/><pre class=""wikicode prettyprint"">    public Integer incrementIfOver20(Number n) {<br/><br/>        Integer newValue = n != null &amp;&amp; n.intValue() &gt; 20 ? (Integer) n + 1 : (Integer)n;     // ternary op 1<br/><br/>        var values = new HashMap&lt;String, Integer&gt;();<br/>        values.put(&quot;one&quot;, n != null &amp;&amp; n.intValue() &gt; 20 ? (Integer) n + 1 : (Integer)n);       // ternary op 2<br/><br/>        return newValue;<br/><br/>    }</pre><br/>2) Extracting &#39;(Integer) n + 1&#39; to a variable on line 1 results in following code (ternary operator converted to if-else statement):<br/><br/><pre class=""wikicode prettyprint"">    public Integer incrementIfOver20(Number n) {<br/><br/>        Integer newValue;<br/>        if (n != null &amp;&amp; n.intValue() &gt; 20) {<br/>            int seconds = (Integer) n + 1;<br/>            newValue = seconds;<br/>        } else {<br/>            newValue = (Integer)n;<br/>        }<br/><br/>        var values = new HashMap&lt;String, Integer&gt;();<br/>        values.put(&quot;one&quot;, n != null &amp;&amp; n.intValue() &gt; 20 ? (Integer) n + 1 : (Integer)n);<br/><br/>        return newValue;<br/>    }</pre><br/>3) However, extracting &#39;(Integer) n + 1&#39; to a variable on line 2 DOESN&#39;T convert ternary op to if-else statement and results in following code:<br/><br/><pre class=""wikicode prettyprint"">    public Integer incrementIfOver20(Number n) {<br/><br/>        Integer newValue = n != null &amp;&amp; n.intValue() &gt; 20 ? (Integer) n + 1 : (Integer)n;<br/><br/>        var values = new HashMap&lt;String, Integer&gt;();<br/>        int seconds = (Integer) n + 1;<br/>        values.put(&quot;one&quot;, n != null &amp;&amp; n.intValue() &gt; 20 ? seconds : (Integer)n);<br/><br/>        return newValue;<br/>      <br/>    }</pre></div>
","0"
"IDEA-211471","IntelliJ IDEA","","Inline method: warn about `super.xyz` call","Tagir Valeev","23/04/2019 03:20","23/04/2019 03:20",,"Normal","Bug",,"Tagir.Valeev","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","If inlined method contains `super.xyz` call, and the callsite receiver is not `this`, then such call will become broken (may even silently bind to another method). We should warn about this in conflicts.","0"
"IDEA-210726","IntelliJ IDEA","","Suggest adding a new parameter to a method from a lambda","Brice Dutheil","09/04/2019 10:21","09/04/2019 11:49",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**
1. Suppose there's the following code

   a method declared like this
   `static RetrofitInvocation fromRetrofit() {`

   the callsite looks like this
   `forCall(fromRetrofit())` 

2. Now we want to add a lambda as a parameter to the `fromRetrofit` method

   `forCall(fromRetrofit(request -> serviceName))`

3. The usual when we add a parameter, one would press <kbd>Alt</kbd> + <kbd>Enter</kbd>, IJ then pops a menu with suggestion about creating the parameter to the method declaration, or to remove the parameter. However IJ don't propose anything when the code is a lambda or a method reference but to remove the lambda. 

**What is the expected result?**
While I understand that IntelliJ cannot really infer with precision the type of the lambda, it can still suggest to add the lambda / or method reference as parameter to the method declaration.

In the above example `request` is a `okhttp3.Request` and `serviceName` is a `String`, IJ could suggest the following

```
static RetrofitInvocation fromRetrofit( <Request, String> fallback) {
                                       ^
                                       cursor position
```

And propose functional compatible types in the _classpath_ that matches the lambda arguments ; like `Function` or `BiConsumer`, etc.","0"
"IDEA-210535","IntelliJ IDEA","","Can we make it possible to continue 'Safe delete parameter' after side effects were found?","Maxim Kropotov","05/04/2019 10:45","05/04/2019 12:50",,"Normal","Bug",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
public class Main {
    public static void main(String[] args) {
        unusedParam(1, sideEffect());
        unusedParam(2, sideEffect());
        unusedParam(3, sideEffect());
        unusedParam(4, sideEffect());
        unusedParam(5, sideEffect());
        unusedParam(6, sideEffect());
        unusedParam(7, pure());
    }

    private static void unusedParam(int used, int unused /*invoke 'Safe delete' here */) {
        System.out.println(used);
    }

    private static int sideEffect() {
        System.out.println(""hello, I'm a side effect"");
        return 1;
    }

    private static int pure() {
        return 1;
    }
}
```

I've found a parameter that is no longer used in the method ('unused' above), so I want to delete it.
I invoke 'Safe Selete', so see a conflicts dialog warning me that usages may not safe to delete because `sideEffect()` is not pure.
This is expected.

However, after I've reviewed the usages to make sure I don't care about the side effect any more, I'm not able to force the refactoring to remove them anyway. Invoke 'View Usages' -> Do Refactor, or just 'Delete Anyway' from the conflicts dialog, only the pure usage is updated, leaving uncompilable code.

IMO we should allow to continue deleting after the conflicts dialog.

* It seems that most refactorings allow to continue with unsafe changes after the warning (Try to delete the same parameter via 'Change Signature')
* If the user has decided they don't care about side effects any more, we should help with updating the code (which may be in multiple files)

...or am I missing something here and the current behavior is by design?","1"
"IDEA-209902","IntelliJ IDEA","","Extract method object produces red code on expression list statement","Bas Leijdekkers","28/03/2019 13:57","29/03/2019 04:59",,"Normal","Bug",,"anet","Java. Refactorings","2018.2.7 (182.5107.41), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Before extract method object
```
class X {
  
  void x() {
    int i,j;
    for (<selection>i=0, j=0;</selection> i < 10 && j < 10; i++, j++) {
      System.out.println();
    }
  }
}
```

After extract method object:
```
class X {
  
  void x() {
    int i,j;
    for (Z z = new Z().invoke(); i = z.getI();
      j = z.getJ();i < 10 && j < 10; i++, j++) { // red/chaos
      System.out.println();
    }
  }

  private class Z {
    private int myI;
    private int myJ;

    int getI() {
      return myI;
    }

    int getJ() {
      return myJ;
    }

    public Z invoke() {
      myI =0, myJ =0; // red
      return this;
    }
  }
}
```
It probably should just be disabled on such a statement.","0"
"IDEA-209723","IntelliJ IDEA","","IEAE on extracting large number of things.","Alexandr Evstigneev","27/03/2019 03:58","27/03/2019 05:53",,"Normal","Exception",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Try to extract a <code class=""inline-code"">&quot;test_string&quot;</code> from the following samples:<br/><br/>Sample #1:<br/><pre class=""wikicode prettyprint"">    String var = &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; +<br/>                 &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot; + &quot;test_string&quot;<br/>      ;</pre>Sample #2:<br/><pre class=""wikicode prettyprint"">  String var;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;<br/>    var = &quot;test_string&quot;;</pre>Exception (one of it, don&#39;t remember in which case):<br/><pre class=""wikicode prettyprint"">com.intellij.psi.PsiInvalidElementAccessException: Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION (class com.intellij.psi.impl.java.stubs.JavaLiteralExpressionElementType)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.PsiInvalidElementAccessException.createByNode(PsiInvalidElementAccessException.java:96)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.SubstrateRef$2.getContainingFile(SubstrateRef.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(StubBasedPsiElementBase.java:253)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.extapi.psi.StubBasedPsiElementBase.isPhysical(StubBasedPsiElementBase.java:296)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.util.PsiTreeUtil.processElements(PsiTreeUtil.java:862)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.util.PsiTreeUtil.collectElements(PsiTreeUtil.java:848)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.findLiteralText(JavaCodeStyleManagerImpl.java:571)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableNameFromLiterals(JavaCodeStyleManagerImpl.java:564)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableNameByExpression(JavaCodeStyleManagerImpl.java:543)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableName(JavaCodeStyleManagerImpl.java:237)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.codeStyle.JavaCodeStyleManager.suggestVariableName(JavaCodeStyleManager.java:123)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceVariable.IntroduceVariableBase.getSuggestedName(IntroduceVariableBase.java:140)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceVariable.IntroduceVariableBase.getSettings(IntroduceVariableBase.java:1051)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceVariable.IntroduceVariableHandler.getSettings(IntroduceVariableHandler.java:58)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceVariable.IntroduceVariableBase$3.lambda$pass$2(IntroduceVariableBase.java:729)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:220)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:178)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:168)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:154)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceVariable.IntroduceVariableBase$3.pass(IntroduceVariableBase.java:713)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceVariable.IntroduceVariableBase$3.pass(IntroduceVariableBase.java:669)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.popup.PopupListAdapter.lambda$setItemChosenCallback$0(PopupListAdapter.java:60)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(TransactionGuardImpl.java:195)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.popup.AbstractPopup.lambda$dispose$13(AbstractPopup.java:1428)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.util.ui.UIUtil.invokeLaterIfNeeded(UIUtil.java:3087)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.ifFocusEventsInTheQueue(IdeEventQueue.java:165)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.executeWhenAllFocusEventsLeftTheQueue(IdeEventQueue.java:117)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:164)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.wm.impl.IdeFocusManagerImpl.doWhenFocusSettlesDown(IdeFocusManagerImpl.java:58)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.popup.AbstractPopup.dispose(AbstractPopup.java:1424)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.Disposer$1.execute(Disposer.java:48)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.Disposer$1.execute(Disposer.java:44)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.objectTree.ObjectNode$1.execute(ObjectNode.java:135)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.objectTree.ObjectNode$1.execute(ObjectNode.java:104)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.objectTree.ObjectTree.executeActionWithRecursiveGuard(ObjectTree.java:214)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.objectTree.ObjectNode.execute(ObjectNode.java:104)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.objectTree.ObjectTree.executeAll(ObjectTree.java:162)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.util.Disposer.dispose(Disposer.java:137)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.popup.AbstractPopup.cancel(AbstractPopup.java:727)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.popup.AbstractPopup.closeOk(AbstractPopup.java:668)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.popup.PopupChooserBuilder.closePopup(PopupChooserBuilder.java:457)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.popup.PopupChooserBuilder.access$100(PopupChooserBuilder.java:32)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.popup.PopupChooserBuilder$3.actionPerformed(PopupChooserBuilder.java:446)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.JComponent$ActionStandin.actionPerformed(JComponent.java:3426)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.SwingUtilities.notifyAction(SwingUtilities.java:1668)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.JComponent.processKeyBinding(JComponent.java:2883)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.JComponent.processKeyBindings(JComponent.java:2944)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.JComponent.processKeyEvent(JComponent.java:2846)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.processEvent(Component.java:6327)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.processEvent(Container.java:2239)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEventImpl(Component.java:4899)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2297)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4721)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.KeyboardFocusManager.redispatchEvent(KeyboardFocusManager.java:1954)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.DefaultKeyboardFocusManager.dispatchKeyEvent(DefaultKeyboardFocusManager.java:843)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.DefaultKeyboardFocusManager.preDispatchKeyEvent(DefaultKeyboardFocusManager.java:1112)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.DefaultKeyboardFocusManager.typeAheadAssertions(DefaultKeyboardFocusManager.java:982)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.DefaultKeyboardFocusManager.dispatchEvent(DefaultKeyboardFocusManager.java:808)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeKeyboardFocusManager.dispatchEvent(IdeKeyboardFocusManager.java:40)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEventImpl(Component.java:4770)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2297)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Window.dispatchEventImpl(Window.java:2746)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4721)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:766)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.access$500(EventQueue.java:98)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:715)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:709)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:74)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:84)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:739)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:737)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:74)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEvent(EventQueue.java:736)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:767)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:694)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:404)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:205)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)</pre></div>
","0"
"IDEA-166773","IntelliJ IDEA","","Cannot extract constant","Svetlin Zarev","18/01/2017 09:19","27/03/2019 05:52",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">final class MyClass implements MyInterface {<br/> private void initializeDataSource() {<br/>        dataSource = new BasicDataSource();<br/>        dataSource.setDriverClassName(&quot;org.h2.Driver&quot;);<br/>        dataSource.setUrl(&quot;jdbc:h2:~/test&quot;);<br/>        dataSource.setAccessToUnderlyingConnectionAllowed(false);<br/>        dataSource.setMaxTotal(MAX_CONNECTIONS);<br/>        dataSource.setMaxIdle(MAX_IDLE_CONNECTIONS);<br/>        dataSource.setMinIdle(MIN_IDLE_CONNECTIONS);<br/>        dataSource.setMinEvictableIdleTimeMillis(1 * 60 * 1000);<br/>    }<br/>}</pre><br/>When I try to extract constant from the driver class name, or the idle-time-millis, it fails with the log below. As you can see I&#39;ve managed successfully to extract some constants like MAX_CONNECTIONS, etc, so I have absolutely no idea why it started to fail all of a sudden. I closed and then reopened the editor for that file and managed to extract the constant for setMinEvictableIdleTimeMillis, but then it failed again for the driver class string. There are no compilation errors in the project if that matters. <br/><br/><pre class=""wikicode prettyprint"">2017-01-18 14:07:41,700 [172512226]  ERROR - llij.ide.plugins.PluginManager - IntelliJ IDEA 2016.3.2  Build #IC-163.10154.41 <br/>2017-01-18 14:07:41,700 [172512226]  ERROR - llij.ide.plugins.PluginManager - JDK: 1.8.0_112-release <br/>2017-01-18 14:07:41,700 [172512226]  ERROR - llij.ide.plugins.PluginManager - VM: OpenJDK 64-Bit Server VM <br/>2017-01-18 14:07:41,700 [172512226]  ERROR - llij.ide.plugins.PluginManager - Vendor: JetBrains s.r.o <br/>2017-01-18 14:07:41,700 [172512226]  ERROR - llij.ide.plugins.PluginManager - OS: Windows 10 <br/>2017-01-18 14:07:41,700 [172512226]  ERROR - llij.ide.plugins.PluginManager - Last Action: IntroduceConstant <br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION <br/>com.intellij.psi.PsiInvalidElementAccessException: Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.PsiInvalidElementAccessException.createByNode(PsiInvalidElementAccessException.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.SubstrateRef$2.getContainingFile(SubstrateRef.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(StubBasedPsiElementBase.java:258)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.resolve.JavaResolveUtil.isAccessible(JavaResolveUtil.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantDialog.updateVisibilityPanel(IntroduceConstantDialog.java:403)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantDialog.&lt;init&gt;(IntroduceConstantDialog.java:139)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantHandler.showRefactoringDialog(IntroduceConstantHandler.java:183)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.convertExpressionToField(BaseExpressionToFieldHandler.java:190)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.invokeImpl(BaseExpressionToFieldHandler.java:133)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:476)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:450)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.ElementToWorkOn.processElementToWorkOn(ElementToWorkOn.java:140)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantHandler.invoke(IntroduceConstantHandler.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(BaseRefactoringAction.java:128)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.ex.ActionUtil$1.run(ActionUtil.java:199)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(TransactionGuardImpl.java:91)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.submitTransactionAndWait(TransactionGuardImpl.java:159)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(ActionUtil.java:213)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(IdeKeyEventDispatcher.java:587)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.lambda$processAction$2(IdeKeyEventDispatcher.java:634)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(TransactionGuardImpl.java:204)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:633)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.inInitState(IdeKeyEventDispatcher.java:477)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(IdeKeyEventDispatcher.java:211)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:657)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:391)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)<br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - IntelliJ IDEA 2016.3.2  Build #IC-163.10154.41 <br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - JDK: 1.8.0_112-release <br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - VM: OpenJDK 64-Bit Server VM <br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - Vendor: JetBrains s.r.o <br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - OS: Windows 10 <br/>2017-01-18 14:07:49,669 [172520195]  ERROR - llij.ide.plugins.PluginManager - Last Action: IntroduceConstant <br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION <br/>com.intellij.psi.PsiInvalidElementAccessException: Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.PsiInvalidElementAccessException.createByNode(PsiInvalidElementAccessException.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.SubstrateRef$2.getContainingFile(SubstrateRef.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(StubBasedPsiElementBase.java:258)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.resolve.JavaResolveUtil.isAccessible(JavaResolveUtil.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantDialog.updateVisibilityPanel(IntroduceConstantDialog.java:403)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantDialog.&lt;init&gt;(IntroduceConstantDialog.java:139)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantHandler.showRefactoringDialog(IntroduceConstantHandler.java:183)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.convertExpressionToField(BaseExpressionToFieldHandler.java:190)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.invokeImpl(BaseExpressionToFieldHandler.java:133)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:476)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:450)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.ElementToWorkOn.processElementToWorkOn(ElementToWorkOn.java:140)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantHandler.invoke(IntroduceConstantHandler.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(BaseRefactoringAction.java:128)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.ex.ActionUtil$1.run(ActionUtil.java:199)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(TransactionGuardImpl.java:91)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.submitTransactionAndWait(TransactionGuardImpl.java:159)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(ActionUtil.java:213)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.impl.ActionMenuItem$ActionTransmitter.lambda$actionPerformed$2(ActionMenuItem.java:315)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.wm.impl.FocusManagerImpl.runOnOwnContext(FocusManagerImpl.java:920)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.wm.impl.IdeFocusManagerImpl.runOnOwnContext(IdeFocusManagerImpl.java:130)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.impl.ActionMenuItem$ActionTransmitter.actionPerformed(ActionMenuItem.java:295)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:2022)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.impl.ActionMenuItem.lambda$fireActionPerformed$0(ActionMenuItem.java:112)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(TransactionGuardImpl.java:91)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.access$300(TransactionGuardImpl.java:41)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl$2.run(TransactionGuardImpl.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.submitTransaction(TransactionGuardImpl.java:126)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuard.submitTransaction(TransactionGuard.java:122)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.actionSystem.impl.ActionMenuItem.fireActionPerformed(ActionMenuItem.java:112)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.plaf.beg.BegMenuItemUI.doClick(BegMenuItemUI.java:513)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.plaf.beg.BegMenuItemUI.access$300(BegMenuItemUI.java:45)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.plaf.beg.BegMenuItemUI$MyMouseInputHandler.mouseReleased(BegMenuItemUI.java:533)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.processMouseEvent(Component.java:6533)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.JComponent.processMouseEvent(JComponent.java:3324)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.processEvent(Component.java:6298)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.processEvent(Container.java:2236)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEventImpl(Component.java:4889)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2294)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4711)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4888)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4525)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4466)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2280)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Window.dispatchEventImpl(Window.java:2746)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4711)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:758)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.access$500(EventQueue.java:97)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:709)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:703)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:90)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:731)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:729)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEvent(EventQueue.java:728)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:843)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:675)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:391)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)<br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - IntelliJ IDEA 2016.3.2  Build #IC-163.10154.41 <br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - JDK: 1.8.0_112-release <br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - VM: OpenJDK 64-Bit Server VM <br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - Vendor: JetBrains s.r.o <br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - OS: Windows 10 <br/>2017-01-18 14:08:05,480 [172536006]  ERROR - llij.ide.plugins.PluginManager - Last Action: IntroduceConstant <br/>2017-01-18 14:10:14,492 [172665018]  ERROR - llij.ide.plugins.PluginManager - Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION <br/>com.intellij.psi.PsiInvalidElementAccessException: Element class com.intellij.psi.impl.source.tree.CompositeElement of type LITERAL_EXPRESSION<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.PsiInvalidElementAccessException.createByNode(PsiInvalidElementAccessException.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.SubstrateRef$2.getContainingFile(SubstrateRef.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(StubBasedPsiElementBase.java:258)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.psi.impl.source.resolve.JavaResolveUtil.isAccessible(JavaResolveUtil.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantDialog.updateVisibilityPanel(IntroduceConstantDialog.java:403)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantDialog.&lt;init&gt;(IntroduceConstantDialog.java:139)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.IntroduceConstantHandler.showRefactoringDialog(IntroduceConstantHandler.java:183)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.convertExpressionToField(BaseExpressionToFieldHandler.java:190)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.invokeImpl(BaseExpressionToFieldHandler.java:133)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:476)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:450)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.ElementToWorkOn$1.pass(ElementToWorkOn.java:130)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.introduceField.ElementToWorkOn$1.pass(ElementToWorkOn.java:123)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.IntroduceTargetChooser$1.pass(IntroduceTargetChooser.java:82)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.IntroduceTargetChooser$1.pass(IntroduceTargetChooser.java:79)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.IntroduceTargetChooser.lambda$showIntroduceTargetChooser$2(IntroduceTargetChooser.java:149)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(TransactionGuardImpl.java:204)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ui.popup.AbstractPopup.lambda$null$7(AbstractPopup.java:1394)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:311)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:756)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.access$500(EventQueue.java:97)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:709)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:703)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEvent(EventQueue.java:726)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:843)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:679)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:391)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)<br/>2017-01-18 14:10:14,493 [172665019]  ERROR - llij.ide.plugins.PluginManager - IntelliJ IDEA 2016.3.2  Build #IC-163.10154.41 <br/>2017-01-18 14:10:14,493 [172665019]  ERROR - llij.ide.plugins.PluginManager - JDK: 1.8.0_112-release <br/>2017-01-18 14:10:14,493 [172665019]  ERROR - llij.ide.plugins.PluginManager - VM: OpenJDK 64-Bit Server VM <br/>2017-01-18 14:10:14,493 [172665019]  ERROR - llij.ide.plugins.PluginManager - Vendor: JetBrains s.r.o <br/>2017-01-18 14:10:14,493 [172665019]  ERROR - llij.ide.plugins.PluginManager - OS: Windows 10 </pre></div>
","0"
"IDEA-209715","IntelliJ IDEA","","Extracting a delegate method incorrectly replaces this with null","Megan Ketelaar","26/03/2019 20:31","27/03/2019 05:32",,"Normal","Bug",,"anet","Java. Refactorings","2018.2.7 (182.5107.41), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","If you make a class with two methods, one of which is referenced as a method reference from the other, and then extract both methods to a delegate with `Right click -> Extract -> Delegate`, IntelliJ will replace `this` in the reference with `null`, breaking the code.

Minimal example:

```
public class Test {
  public Set<String> foo(Collection<String> collection) {
    return collection.stream()
        .map(this::mutate)
        .collect(Collectors.toSet());
  }

  private String mutate(String s) {
    return s + s;
  }
}
```

Extracting `foo` and `mutate` to a delegate leads to this:
![](image.png)

The expected extraction is:

```
public class TestDelegate {
  public TestDelegate() {
  }

  public Set<String> foo(Collection<String> collection) {
    return collection.stream()
        .map(this::mutate)
        .collect(Collectors.toSet());
  }

  private String mutate(String s) {
    return s + s;
  }
}
```

IC-183.6156.11, JRE 1.8.0_152-release-1343-b28x64 JetBrains s.r.o, OS Linux(amd64) v4.15.0-36-generic, screens 2560x1440, 2560x1440","0"
"IDEA-209639","IntelliJ IDEA","","""Use interface where possible"" should replace calls to Class.cast() and Class.isInstance()","Balz Guenat","26/03/2019 06:21","26/03/2019 08:47",,"Normal","Feature",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Write classes like so:
```
class Super {}

class Inter extends Super
{
   void foobar() {}
}

class Foo extends Inter {}

class Main {
   static void baz(List<Super> foos) {
      foos.stream()
          .filter(Foo.class::isInstance)
          .map(Foo.class::cast)
          .forEach(Main::bar);
   }
   static void baz2(List<Super> foos) {
      foos.stream()
          .filter(f -> Foo.class.isInstance(f))
          .map(f -> Foo.class.cast(f))
          .forEach(f -> bar(f));
   }
   static void baz3(List<Super> foos) {
      foos.stream()
          .filter(f -> f instanceof Foo)
          .map(f -> (Foo) f)
          .forEach(f -> bar(f));
   }

   static void bar(Foo foo) {
      foo.foobar();
   }
}
```
2. On `Foo`, select ""Use interface where possible`.
3. Select `Inter`, select the ""Use interface/superclass in instanceof"" option and click ""Refactor"".

What currently happens:
Method `baz3` is changed so it uses `Inter` instead of `Foo`.
```
   static void baz3(List<Super> foos) {
      foos.stream()
          .filter(f -> f instanceof Inter)
          .map(f -> (Inter) f)
          .forEach(f -> bar(f));
   }
```

However, methods `baz` and `baz2` are unchanged, even if they are (to some degree) equivalent to `baz3`.
They should be changed to the following:
```
   static void baz(List<Super> foos) {
      foos.stream()
          .filter(Inter.class::isInstance)
          .map(Inter.class::cast)
          .forEach(Main::bar);
   }
   static void baz2(List<Super> foos) {
      foos.stream()
          .filter(f -> Inter.class.isInstance(f))
          .map(f -> Inter.class.cast(f))
          .forEach(f -> bar(f));
   }
```","0"
"IDEA-209637","IntelliJ IDEA","","Replace Usages after Extract Superclass should offer option ""Use interface/superclass in instanceof"", just like ""Use Interface Where Possible"" already does","Balz Guenat","26/03/2019 06:06","26/03/2019 08:47",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Write classes like so:
```
class Super {}

class Foo extends Super
{
   void foobar() {}
}

class Main {
   static void baz(List<Super> foos) {
      foos.stream()
          .filter(f -> f instanceof Foo)
          .map(f -> (Foo) f)
          .forEach(f -> bar(f));
   }

   static void bar(Foo foo) {
      foo.foobar();
   }
}
```
2. Extract a superclass `Inter` from `Foo`, pulling up member `foobar()`.
3. A prompt appears that asks whether usages of `Foo` should be replaced with `Inter` where possible. Choose Yes and confirm the refactor.

Compare this to the workflow of the ""Use Interface Where Possible"" refactoring.
There, the appearing dialog window offers the option to replace the class in `instanceof` expressions (see attached image).
Such an option should be offered in the above-mentioned work flow as well. 
The current behavior is *not* to replace `Foo` in `instanceof`.","0"
"IDEA-209425","IntelliJ IDEA","","Redundant protocol added during safe delete","Nikolaj Schumacher","22/03/2019 04:55","22/03/2019 10:58",,"Normal","Usability Problem",,"anet","Java. Refactorings","2018.2.7 (182.5107.41), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
interface P {}

interface A extends P {}
interface B extends P {}

class C implements A, B {}
```

Safe delete of `B` leads to:
```
interface P {}

interface A extends P {}

class C implements A, P {}
```

The `P` is redundant, so expected result would be:
```
interface P {}

interface A extends P {}

class C implements A {}
```","1"
"IDEA-209295","IntelliJ IDEA","javadoc","""Pull Members Up"" refactoring should not remove JavaDoc.","Balz Guenat","20/03/2019 09:25","20/03/2019 09:42",,"Normal","Usability Problem",,"anet","Java. Refactorings","2018.3.5 (183.5912.21), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Create two classes as follows:
```
public abstract class Super
{
   /**
    * This is some javadoc for foo.
    */
   abstract void foo();
}
```
```
public class Sub extends Super
{
   @Override
   void foo () {}
}
```
2. Right-click on Sub::foo(), select Refactor -> Pull Members Up and click confirm the pull-up in the appearing dialog.

What is the expected result?
`Super.foo()` should keep its JavaDoc string if the pulled-up method does not have a JavaDoc string.
```
public abstract class Super
{
   /**
    * This is some javadoc for foo.
    */
   void foo () {}
}
```
```
public class Sub extends Super
{
}
```

What happens instead?
The JavaDoc string of `Super.foo()` is replaced with the empty JavaDoc string of `Sub.foo()`, effectively removing that bit of documentation.
```
public abstract class Super
{
   void foo () {}
}
```
```
public class Sub extends Super
{
}
```","0"
"IDEA-209264","IntelliJ IDEA","","Refactor -> extract -> delegate breaks on delegating line ending in line comment","First Name Last Name","20/03/2019 04:00","20/03/2019 09:19",,"Normal","Bug",,"anet","Java. Refactorings","2018.2.7 (182.5107.41), 2019.2 (192.5728.98)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Tested on:
IntelliJ IDEA 2018.3.5 (Community Edition)
Build #IC-183.5912.21, built on February 26, 2019
JRE: 1.8.0_152-release-1343-b28 amd64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0

Steps to reproduce:
1. Have a class with several fields, declared on seperate lines.
2. put ""// this line will break everything"" behind the first variable decleration. (On the same line)
3. Refactor -> extract -> delegate
4. Select several of the variables, including the first one (the one ending on a commented line)
5. go ahead with the refactor

Expected result:
The selected variables each have their own line in the new delegation class.

Actual result:
Some or all of the code is placed directly after the comment, with no line break, causing the code to be broken.

Work around:
Replace with a /*...*/ type comment","0"
"IDEA-197750","IntelliJ IDEA","","Inline interface produces bad code","Régis Caspar","22/08/2018 11:36","19/03/2019 08:53",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","**What steps will reproduce the issue?**
1. I had two interface (same ones in two different packages)
`package foo.bar;
  interface Foo {
      String bar();
  }` and
`package com.bar;
  interface Foo {
      String bar();
  }`
2. I wanted to use refactoring to remove one of the interface so I did change one like this:
` package com.bar;
   interface Foo extends foo.bar.Foo {
   }`
3. I then choose the refactor > Inline action on `com.bar.Foo` 

**What is the expected result?**

every usage of com.bar.Foo is replaced with foo.bar.Foo

**What happens instead?**

every usage was replaced by some other random class of the base code.. But not everywhere. Usage like `class A implements Foo` were correctly replaced, usage like `Foo.class.equals(xxx)` or `xxx instanceOf Foo` were incorrectly replaced
NB: the random class implements ""Foo""

**Attachments**
idea.log and a git diff showing the issue.

**Version**
IntelliJ IDEA 2018.2.1 (Ultimate Edition)
Build #IU-182.3911.36, built on August 6, 2018
Licensed to xxxxxxxxxx
Subscription is active until xxxxxxxx
JRE: 1.8.0_152-release-1248-b8 x86_64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
macOS 10.13.6","0"
"IDEA-208158","IntelliJ IDEA","","""Convert To Instance Method"" refactoring should allow arbitrary (or at least static) instance expressions.","Balz Guenat","28/02/2019 12:21","28/02/2019 12:53",,"Normal","Feature",,"anet","Java. Refactorings","2018.3.4 (183.5429.30)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. Write a class as follows
```
public class Foo
{

   private Foo () {}

   public static Foo build() {
      return new Foo();
   }

   public static void foo() {

   }
}
```
2. Right-click on `foo()`, choose Refactor -> Convert To Instance Method...


I should be able to select or enter `Foo.build()` for an instance expression as an alternative to `new Foo()`, which wouldn't work anyway, as it's private.","0"
"IDEA-207897","IntelliJ IDEA","","Getter and setter rename when field is renamed: recognize with- prefix","Roman Leventov","25/02/2019 12:08","25/02/2019 12:25",,"Normal","Feature",,"anet","Java. Refactorings","2019.1 (191.6183.87)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When a field is renamed IntelliJ recognizes getters and setters and suggests to rename them as well. It would be nice if IntelliJ recognized methods starting with with-, e. g.<br/><pre class=""wikicode prettyprint"">class FooBuilder {<br/>  int bar;<br/>  <br/>  FooBuilder withBar(int bar) {<br/>    this.bar = bar;<br/>    return this;<br/>  }<br/>}</pre><br/>And suggested to rename them as well (and their parameters) when the <code class=""inline-code"">bar</code> field is renamed to <code class=""inline-code"">baz</code>.<br/><br/>Probably instead of simple Yes - No dialog, a dialog window should appear that allows to check/uncheck a rename of some of methods that are recognized as getters, setters, and &quot;with&quot; methods, similar to the window that appears later to check/uncheck renames of method and constructor parameters.</div>
","1"
"IDEA-169022","IntelliJ IDEA","","NPE at com.intellij.openapi.vfs.impl.VirtualFilePointerManagerImpl.after","Irina Petrovskaya","02/03/2017 12:47","21/02/2019 13:13",,"Normal","Exception",,"cdr","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">172,242<br/><br/>once on rename package in multimodule project (package exists in 3 modules)<br/><br/>null<br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.NullPointerException</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.openapi.vfs.impl.VirtualFilePointerManagerImpl.after(<a class=""dsLink"" txt=""com/intellij/openapi/vfs/impl/VirtualFilePointerManagerImpl.java"" lne=""490"" title=""Open in IDE"">VirtualFilePointerManagerImpl.java:490</a>)<br/>&nbsp;<b>at</b> sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)<br/>&nbsp;<b>at</b> sun.reflect.DelegatingMethodAccessorImpl.invoke(<a class=""dsLink"" txt=""sun/reflect/DelegatingMethodAccessorImpl.java"" lne=""43"" title=""Open in IDE"">DelegatingMethodAccessorImpl.java:43</a>)<br/>&nbsp;<b>at</b> java.lang.reflect.Method.invoke(<a class=""dsLink"" txt=""java/lang/reflect/Method.java"" lne=""498"" title=""Open in IDE"">Method.java:498</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusConnectionImpl.deliverMessage(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusConnectionImpl.java"" lne=""117"" title=""Open in IDE"">MessageBusConnectionImpl.java:117</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusImpl.doPumpMessages(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusImpl.java"" lne=""437"" title=""Open in IDE"">MessageBusImpl.java:437</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusImpl.pumpWaitingBuses(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusImpl.java"" lne=""398"" title=""Open in IDE"">MessageBusImpl.java:398</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusImpl.pumpMessages(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusImpl.java"" lne=""387"" title=""Open in IDE"">MessageBusImpl.java:387</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusImpl.sendMessage(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusImpl.java"" lne=""373"" title=""Open in IDE"">MessageBusImpl.java:373</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusImpl.access$200(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusImpl/access.java"" lne=""44"" title=""Open in IDE"">MessageBusImpl.java:44</a>)<br/>&nbsp;<b>at</b> com.intellij.util.messages.impl.MessageBusImpl$2.invoke(<a class=""dsLink"" txt=""com/intellij/util/messages/impl/MessageBusImpl.java"" lne=""230"" title=""Open in IDE"">MessageBusImpl.java:230</a>)<br/>&nbsp;<b>at</b> com.sun.proxy.$Proxy23.after(Unknown Source)<br/>&nbsp;<b>at</b> com.intellij.openapi.vfs.newvfs.persistent.PersistentFSImpl.processEvents(<a class=""dsLink"" txt=""com/intellij/openapi/vfs/newvfs/persistent/PersistentFSImpl.java"" lne=""779"" title=""Open in IDE"">PersistentFSImpl.java:779</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.vfs.newvfs.persistent.PersistentFSImpl.b(<a class=""dsLink"" txt=""com/intellij/openapi/vfs/newvfs/persistent/PersistentFSImpl.java"" lne=""676"" title=""Open in IDE"">PersistentFSImpl.java:676</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.vfs.newvfs.persistent.PersistentFSImpl.renameFile(<a class=""dsLink"" txt=""com/intellij/openapi/vfs/newvfs/persistent/PersistentFSImpl.java"" lne=""465"" title=""Open in IDE"">PersistentFSImpl.java:465</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.vfs.newvfs.impl.VirtualFileSystemEntry.rename(<a class=""dsLink"" txt=""com/intellij/openapi/vfs/newvfs/impl/VirtualFileSystemEntry.java"" lne=""211"" title=""Open in IDE"">VirtualFileSystemEntry.java:211</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.file.PsiDirectoryImpl.setName(<a class=""dsLink"" txt=""com/intellij/psi/impl/file/PsiDirectoryImpl.java"" lne=""107"" title=""Open in IDE"">PsiDirectoryImpl.java:107</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.file.PsiPackageBase.setName(<a class=""dsLink"" txt=""com/intellij/psi/impl/file/PsiPackageBase.java"" lne=""125"" title=""Open in IDE"">PsiPackageBase.java:125</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenameUtil.doRenameGenericNamedElement(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenameUtil.java"" lne=""233"" title=""Open in IDE"">RenameUtil.java:233</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenamePsiPackageProcessor.renameElement(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenamePsiPackageProcessor.java"" lne=""130"" title=""Open in IDE"">RenamePsiPackageProcessor.java:130</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenameUtil.doRename(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenameUtil.java"" lne=""187"" title=""Open in IDE"">RenameUtil.java:187</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenameProcessor.performRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenameProcessor.java"" lne=""384"" title=""Open in IDE"">RenameProcessor.java:384</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""487"" title=""Open in IDE"">BaseRefactoringProcessor.java:487</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""498"" title=""Open in IDE"">BaseRefactoringProcessor.java:498</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.a(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""957"" title=""Open in IDE"">ApplicationImpl.java:957</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.impl.CoreProgressManager.a(<a class=""dsLink"" txt=""com/intellij/openapi/progress/impl/CoreProgressManager.java"" lne=""176"" title=""Open in IDE"">CoreProgressManager.java:176</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.impl.CoreProgressManager.a(<a class=""dsLink"" txt=""com/intellij/openapi/progress/impl/CoreProgressManager.java"" lne=""556"" title=""Open in IDE"">CoreProgressManager.java:556</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(<a class=""dsLink"" txt=""com/intellij/openapi/progress/impl/CoreProgressManager.java"" lne=""501"" title=""Open in IDE"">CoreProgressManager.java:501</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(<a class=""dsLink"" txt=""com/intellij/openapi/progress/impl/ProgressManagerImpl.java"" lne=""66"" title=""Open in IDE"">ProgressManagerImpl.java:66</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(<a class=""dsLink"" txt=""com/intellij/openapi/progress/impl/CoreProgressManager.java"" lne=""163"" title=""Open in IDE"">CoreProgressManager.java:163</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.util.PotemkinProgress.runInSwingThread(<a class=""dsLink"" txt=""com/intellij/openapi/progress/util/PotemkinProgress.java"" lne=""157"" title=""Open in IDE"">PotemkinProgress.java:157</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteActionWithProgressInDispatchThread(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""957"" title=""Open in IDE"">ApplicationImpl.java:957</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""498"" title=""Open in IDE"">BaseRefactoringProcessor.java:498</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.access$100(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor/access.java"" lne=""80"" title=""Open in IDE"">BaseRefactoringProcessor.java:80</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$3.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""312"" title=""Open in IDE"">BaseRefactoringProcessor.java:312</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.a(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""149"" title=""Open in IDE"">CoreCommandProcessor.java:149</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""109"" title=""Open in IDE"">CoreCommandProcessor.java:109</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""99"" title=""Open in IDE"">CoreCommandProcessor.java:99</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.execute(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""308"" title=""Open in IDE"">BaseRefactoringProcessor.java:308</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.doRun(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""232"" title=""Open in IDE"">BaseRefactoringProcessor.java:232</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenameProcessor.doRun(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenameProcessor.java"" lne=""122"" title=""Open in IDE"">RenameProcessor.java:122</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.fileEditor.impl.NonProjectFileWritingAccessProvider.disableChecksDuring(<a class=""dsLink"" txt=""com/intellij/openapi/fileEditor/impl/NonProjectFileWritingAccessProvider.java"" lne=""181"" title=""Open in IDE"">NonProjectFileWritingAccessProvider.java:181</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""565"" title=""Open in IDE"">BaseRefactoringProcessor.java:565</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog.invokeRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""183"" title=""Open in IDE"">RefactoringDialog.java:183</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenameDialog.performRename(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenameDialog.java"" lne=""325"" title=""Open in IDE"">RenameDialog.java:325</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenameDialog.doAction(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenameDialog.java"" lne=""303"" title=""Open in IDE"">RenameDialog.java:303</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.RenamePsiPackageProcessor$1.doAction(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/RenamePsiPackageProcessor.java"" lne=""87"" title=""Open in IDE"">RenamePsiPackageProcessor.java:87</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog.doRefactorAction(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""88"" title=""Open in IDE"">RefactoringDialog.java:88</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog$RefactorAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""160"" title=""Open in IDE"">RefactoringDialog.java:160</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2022"" title=""Open in IDE"">AbstractButton.java:2022</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton$Handler.actionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2348"" title=""Open in IDE"">AbstractButton.java:2348</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""402"" title=""Open in IDE"">DefaultButtonModel.java:402</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.setPressed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""259"" title=""Open in IDE"">DefaultButtonModel.java:259</a>)<br/>&nbsp;<b>at</b> javax.swing.plaf.basic.BasicButtonListener.mouseReleased(<a class=""dsLink"" txt=""javax/swing/plaf/basic/BasicButtonListener.java"" lne=""252"" title=""Open in IDE"">BasicButtonListener.java:252</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processMouseEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6541"" title=""Open in IDE"">Component.java:6541</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processMouseEvent(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""3324"" title=""Open in IDE"">JComponent.java:3324</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6306"" title=""Open in IDE"">Component.java:6306</a>)<br/>&nbsp;<b>at</b> java.awt.Container.processEvent(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2236"" title=""Open in IDE"">Container.java:2236</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4897"" title=""Open in IDE"">Component.java:4897</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2294"" title=""Open in IDE"">Container.java:2294</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4719"" title=""Open in IDE"">Component.java:4719</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.retargetMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4888"" title=""Open in IDE"">Container.java:4888</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.processMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4525"" title=""Open in IDE"">Container.java:4525</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.dispatchEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4466"" title=""Open in IDE"">Container.java:4466</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2280"" title=""Open in IDE"">Container.java:2280</a>)<br/>&nbsp;<b>at</b> java.awt.Window.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Window.java"" lne=""2746"" title=""Open in IDE"">Window.java:2746</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4719"" title=""Open in IDE"">Component.java:4719</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""764"" title=""Open in IDE"">EventQueue.java:764</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$500(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""98"" title=""Open in IDE"">EventQueue.java:98</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""715"" title=""Open in IDE"">EventQueue.java:715</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$3.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""709"" title=""Open in IDE"">EventQueue.java:709</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""80"" title=""Open in IDE"">ProtectionDomain.java:80</a>)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""90"" title=""Open in IDE"">ProtectionDomain.java:90</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""737"" title=""Open in IDE"">EventQueue.java:737</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$4.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""735"" title=""Open in IDE"">EventQueue.java:735</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/ProtectionDomain.java"" lne=""80"" title=""Open in IDE"">ProtectionDomain.java:80</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""734"" title=""Open in IDE"">EventQueue.java:734</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.f(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""827"" title=""Open in IDE"">IdeEventQueue.java:827</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""651"" title=""Open in IDE"">IdeEventQueue.java:651</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""365"" title=""Open in IDE"">IdeEventQueue.java:365</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""109"" title=""Open in IDE"">EventDispatchThread.java:109</a>)<br/>&nbsp;<b>at</b> java.awt.WaitDispatchSupport$2.run(<a class=""dsLink"" txt=""java/awt/WaitDispatchSupport.java"" lne=""184"" title=""Open in IDE"">WaitDispatchSupport.java:184</a>)<br/>&nbsp;<b>at</b> java.awt.WaitDispatchSupport$4.run(<a class=""dsLink"" txt=""java/awt/WaitDispatchSupport.java"" lne=""229"" title=""Open in IDE"">WaitDispatchSupport.java:229</a>)<br/>&nbsp;<b>at</b> java.awt.WaitDispatchSupport$4.run(<a class=""dsLink"" txt=""java/awt/WaitDispatchSupport.java"" lne=""227"" title=""Open in IDE"">WaitDispatchSupport.java:227</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.awt.WaitDispatchSupport.enter(<a class=""dsLink"" txt=""java/awt/WaitDispatchSupport.java"" lne=""227"" title=""Open in IDE"">WaitDispatchSupport.java:227</a>)<br/>&nbsp;<b>at</b> java.awt.Dialog.show(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1084"" title=""Open in IDE"">Dialog.java:1084</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""735"" title=""Open in IDE"">DialogWrapperPeerImpl.java:735</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""457"" title=""Open in IDE"">DialogWrapperPeerImpl.java:457</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.DialogWrapper.invokeShow(<a class=""dsLink"" txt=""com/intellij/openapi/ui/DialogWrapper.java"" lne=""1696"" title=""Open in IDE"">DialogWrapper.java:1696</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.DialogWrapper.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/DialogWrapper.java"" lne=""1645"" title=""Open in IDE"">DialogWrapper.java:1645</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.PsiElementRenameHandler.rename(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/PsiElementRenameHandler.java"" lne=""198"" title=""Open in IDE"">PsiElementRenameHandler.java:198</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.PsiElementRenameHandler.rename(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/PsiElementRenameHandler.java"" lne=""169"" title=""Open in IDE"">PsiElementRenameHandler.java:169</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.DirectoryAsPackageRenameHandlerBase.a(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/DirectoryAsPackageRenameHandlerBase.java"" lne=""191"" title=""Open in IDE"">DirectoryAsPackageRenameHandlerBase.java:191</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.rename.DirectoryAsPackageRenameHandlerBase.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/rename/DirectoryAsPackageRenameHandlerBase.java"" lne=""124"" title=""Open in IDE"">DirectoryAsPackageRenameHandlerBase.java:124</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/actions/BaseRefactoringAction.java"" lne=""132"" title=""Open in IDE"">BaseRefactoringAction.java:132</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil$1.run(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""208"" title=""Open in IDE"">ActionUtil.java:208</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.a(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""86"" title=""Open in IDE"">TransactionGuardImpl.java:86</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.submitTransactionAndWait(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""151"" title=""Open in IDE"">TransactionGuardImpl.java:151</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""222"" title=""Open in IDE"">ActionUtil.java:222</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""570"" title=""Open in IDE"">IdeKeyEventDispatcher.java:570</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.a(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""619"" title=""Open in IDE"">IdeKeyEventDispatcher.java:619</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""193"" title=""Open in IDE"">TransactionGuardImpl.java:193</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""618"" title=""Open in IDE"">IdeKeyEventDispatcher.java:618</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.b(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""477"" title=""Open in IDE"">IdeKeyEventDispatcher.java:477</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""211"" title=""Open in IDE"">IdeKeyEventDispatcher.java:211</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""633"" title=""Open in IDE"">IdeEventQueue.java:633</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""365"" title=""Open in IDE"">IdeEventQueue.java:365</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""105"" title=""Open in IDE"">EventDispatchThread.java:105</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""101"" title=""Open in IDE"">EventDispatchThread.java:101</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""93"" title=""Open in IDE"">EventDispatchThread.java:93</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""82"" title=""Open in IDE"">EventDispatchThread.java:82</a>)</pre></details></div></div>
","0"
"IDEA-207053","IntelliJ IDEA","","""Move function"" refactoring adds reference to original source class of the function to the moved method.","Alexandr Fedorov","08/02/2019 19:58","11/02/2019 09:49",,"Normal","Bug",,"anet","Java. Refactorings","2019.1 (191.6183.87)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","""Move function"" refactoring adds reference to original source class of the function to the moved method.

Here I am trying to move function A.bar to B class.
```
public class Main {
    public static void main(String[] args) {
        A a = new A();
    }
    static class A {
        B b;
        public void bar() {
            this.b.foo();
        }
    }
    static class B {
        public void foo() {
        }
    }
}
```
The result is 
```
static class B {
        public void foo() {
        }

        public void bar(A a) {
            foo();
        }
    }
```
and variable `a` is not used.","0"
"IDEA-124944","IntelliJ IDEA","reproduced","Improve extracting variables from subexpressions","Roman Leventov","08/05/2014 19:25","08/02/2019 06:19",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">For example here<br/><pre class=""wikicode prettyprint"">public class Foo {<br/>    public static void main(String[] args) {<br/>        int a = 0, b = 0, c = 0, d = 0;<br/>        if (a + b &lt; c + d) {<br/>            int x = a + b + c;<br/>            int y = a + b + d;<br/>        }<br/>    }<br/>}</pre><br/>I can&#39;t extract <code class=""inline-code"">a+b</code> from x and y declarations and condition.<br/><br/>Same as <a href=""http://youtrack.jetbrains.com/issue/RSRP-11293"">http://youtrack.jetbrains.com/issue/RSRP-11293</a></div>
","3"
"IDEA-206809","IntelliJ IDEA","","[...refactoring...] is not supported in current context -> should add an QuickFix or explanation ""why""","Muescha","06/02/2019 18:25","07/02/2019 10:16",,"Normal","Usability Problem",,"anet","Java. Refactorings","2019.1 (191.6183.87)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","What steps will reproduce the issue?
1. i have this code 

```
int numberOfEdges = square.getNumberOfEdges();
```
i am at Talk ""Be More Productive With IntelliJ IDEA by Trisha Gee"" @34:34

2. i use Extract Fubnctional Parameter

What is the expected result?
refatoring

What happens instead?
""Extract Functional Parameter"" is not supported in current context
there should be an explanation why there is this error and how to fix it.

```
IntelliJ IDEA 2018.3.4 (Ultimate Edition)
Build #IU-183.5429.30, built on January 29, 2019
Licensed to Mixxxx Nxxxxx
Subscription is active until August 1, 2019
JRE: 1.8.0_152-release-1343-b26 x86_64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
macOS 10.13.6
```

used openJDK 11.0.1

Project Settings
- Project SDK 11.0.1
- Project Language Level 11

Modules:
-  Module SDK 11.0.1


![Screenshot](Bildschirmfoto 2019-02-06 um 22.15.17.png)","0"
"IDEA-175838","IntelliJ IDEA","","Cannot create a new class while moving members","Dmitry Cherniachenko","13/07/2017 12:50","23/01/2019 13:38",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Start with a class like this:<br/><pre class=""wikicode prettyprint"">package org;<br/><br/>public class Demo<br/>{<br/>    public static String generateId() {<br/>        return &quot;42&quot;;<br/>    }<br/>}</pre><br/>Invoke Refactor | Move (F6) for the <code class=""inline-code"">generateId()</code> method.<br/>Here is the first problem: IDEA asks for the fully qualified name of the target class. So if I want to create a new class (<code class=""inline-code"">IdUtil</code>) in the same package I have to copy and paste the package name from the source class field.<br/><br/>Enter <code class=""inline-code"">org.IdUtil</code> as the target class. The class name is highlighted in red and a QuickFix &quot;bulb&quot; appears.<br/>Press Alt+Enter and select &quot;Create class <code class=""inline-code"">IdUtil</code>&quot;. Now cancel the &quot;Create Class&quot; dialog with Esc and return to &quot;Move Members&quot;.<br/>Here is another bug - there is no &quot;Create class&quot; QuickFix option anymore. Only &quot;Create enum&quot; and &quot;Create interface&quot;.<br/>&quot;Create class&quot; appears again after editing the target class name. Proceed to &quot;Create Class&quot; once more.<br/><br/>And here is the final bug. Pressing OK in &quot;Create Class&quot; dialog shows error message &quot;Destination not found for package &#39;org&#39;&quot;.<br/><br/>If I ignore the QuickFix and just press OK in the Move Members the questions appear in the wrong order.<br/>First IDEA asks about the destination directory. And then asks if I want to create the <code class=""inline-code"">IdUtil</code> class. Why would I have to select the directory if I didn&#39;t intend to create a new class in the first place?<br/>By the way, if I proceed to create the new class this way it is created successfully, no &quot;destination not found&quot; error.<br/><br/>How I would prefer it working:<br/><ul class=""wiki-list0""><li> if I only enter class name for target, without any packages - assume it&#39;s in the same package as the source class (who creates classes in default package anyway?)<br/></li><li> selecting &quot;Create class&quot; QuickFix should do just that - create the class - don&#39;t bother me with questions about the package (again!) and the source root, I&#39;ll move the class to another source root later if needed<br/></li><li> same for pressing OK in the &quot;Move Members&quot; - just ask if I want the new class created, and don&#39;t ask about target directory<br/></li></ul></div>
","0"
"IDEA-204940","IntelliJ IDEA","","Feature request for change signature dialog / interaction","tr","03/01/2019 08:45","04/01/2019 14:08",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I press CTRL+F6 to trigger the change-sig. dialog, I very often have my active cursor on the part of the signature I want to change.. <br/><br/>So if it&#39;s the return value, I am probably thinking about that  return value before I press CTRL+F6 and, as every knows, having  your cursor in  the syntactic part of code  in question helps you think more clearly. :). <br/><br/>When I pull the trigger on CTRL+F6, it would be great if instead of having to navigate with my mouse and click to activate the part of the signature to change, the part where my cursor was before I pressed CTRL+F6 we already given focus and editable, i.e. the cursor was already there and blinking ready for me to start typing. <br/><br/>It would be like being very rich, and having your driver jump out and open your car door for you.</div>
","1"
"IDEA-133791","IntelliJ IDEA","","Way IntelliJ treats files containing multiple classes or objects is very annoying","mike","02/12/2014 19:49","28/12/2018 11:46",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">These issues here have a common source:<br/><br/><ul class=""wiki-list0""><li> <a href=""http://stackoverflow.com/questions/19417206/intellij-project-view-not-show-multiple-classes-in-same-file"" target=""_blank"" rel=""noopener noreferrer"">http://stackoverflow.com/questions/19417206/intellij-project-view-not-show-multiple-classes-in-same-file</a><br/></li><li> <a href=""http://stackoverflow.com/questions/27256650/how-to-duplicate-a-scala-class-in-the-same-directory"" target=""_blank"" rel=""noopener noreferrer"">http://stackoverflow.com/questions/27256650/how-to-duplicate-a-scala-class-in-the-same-directory</a></li></ul><br/>It&#39;s rather disappointing that Windows Explorer, by being dumb about code, is better at handling simple operations like opening and copying files.<br/><br/>This &quot;feature&quot; is so disruptive to my work flow (ok, it&#39;s just a few extra clicks, but common and completely unnecessary ones at that) that I would classify the current behavior as a bug.</div>
","1"
"IDEA-100282","IntelliJ IDEA","reproduced","File refs are not updated on move/rename containing package","Irina Petrovskaya","01/02/2013 06:30","25/12/2018 07:07",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">126.108<br/><br/><pre class=""wikicode prettyprint"">&lt;fx:include source=&quot;/resources/included.fxml&quot;/&gt;</pre>move &#39;included.fxml&#39; file to different package, or rename the &#39;resources&#39; package - the fx:include@source attribute value is not updated</div>
","0"
"IDEA-204206","IntelliJ IDEA","","Bulk rename of suffix/prefix","Anton Arhipov","13/12/2018 12:25","13/12/2018 13:44",,"Normal","Feature",,"anet","Java. Refactorings","2018.3.1 (183.4588.61)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","A number of classes in the project may be called with a specific prefix (or suffix). For instance: DataFlow, DataClazz, DataBase. A user wants to rename those at once by replacing 'Data' with ‘Stuff’, so the names become StuffFlow, StuffClazz, and StuffBase. Currently, it is only possible to do this by renaming the classes one-by-one. It would save a lot of time if the user could select either a set of classes and rename those all at once.","0"
"IDEA-113597","IntelliJ IDEA","reproduced","Smarter introduce field in instance/static context","Oleg Stepanov","13/09/2013 11:59","11/12/2018 15:48",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I introduce field from a literal in instance method context, and there are also occurences of this literal in static context, introduce field should suggest me to introduce a static field and replace more usages.</div>
","1"
"IDEA-70785","IntelliJ IDEA","reproduced","In place refactorings do not allow for combo box selection","Matthew Montgomery","08/06/2011 11:11","28/11/2018 09:58",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am seeing very odd behavior with the in place refactoring UI. For example, if I attempt to run &quot;Introduce Field&quot; the in place UI pops up as expected. When I click on the visibility combo box, the selections are briefly visible and the next item in the list is automatically selected, then the combo box closes. This is without any mouse movement nor am I releasing the mouse button. I&#39;ve seen the same issue with the other in place refactorings.<br/><br/>Mac OS X 10.6<br/>IntelliJ IDEA 10.5</div>
","4"
"IDEA-118678","IntelliJ IDEA","reproduced","Irrelevant suggestions in Rename Inheritors dialogue with inadequate result","Nikita Y Volkov","20/10/2012 13:23","22/11/2018 10:19",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><a href=""http://screencast.com/t/C2LB3Bd9YR"" target=""_blank"" rel=""noopener noreferrer"">http://screencast.com/t/C2LB3Bd9YR</a></div>
","0"
"IDEA-202522","IntelliJ IDEA","","Add possibility to move method to interface: add declaration to interface and move implementation to implementation class (if there is single implementation)","Nikita Sheremet","20/11/2018 08:29","20/11/2018 08:32",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Consider a code:
```
interface MyInterface {
    
}

public class MyService implements MyInterface {

}

public class ClientCode {
    @Autowired
    private MyInterface service;

   public void some() {
   }
    
}

```

Put cursor on `some` and try to move method via refacotring.
Actual result will be like that:
```
interface MyInterface {
    default  void some(ClientCode clientCode) {
   }
}
```
Expected result:
```
interface MyInterface {
    void some() ;
}

public class MyService implements MyInterface {
       public void some() {
       }
}
```

Notes:
 1. It is assumed that there is just single implementation of interface
 1. If there multiple implementation Intellij Idea may show popup with select box:
    1. Move code to default method
    1. Add declaration to interface and move code to all implementations
    1. Add declaration to interface and move code to one implementation (here drop down list or auto comple with class name)","0"
"IDEA-202505","IntelliJ IDEA","","Add possibility to inline interface method when there is a single implementation","Nikita Sheremet","20/11/2018 05:47","20/11/2018 07:53",,"Normal","Feature",,"anet","Java. Refactorings","2018.3 (183.4284.148)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Consider a code:

```
public interface MyInterface {

    User findUserByDate(Date date);
    User findUserLast();
}

public class MyService implements MyInterface {
    public static Date MAXD_DATE = ...

    public User findUserByDate(Date date) {
        //some implementation         
    }
    public User findUserLast() {
        return findUserByDate(MAXD_DATE);
    }
}

public class SomeClientClass {
    @Autowired
    private MyInterface myService;
    
    public void someFunc() {
        myService.findUserLast();
    }
}

```

When user try to inline:
 1. `MyInterface#findUserLast` Intellij Idea shows a popup that it can not inline abstract method
 1. `MyService#findUserLast` Intellij Idea inline this method but all client code which uses `MyInterface` are not touched.
 
Can Intellij Idea checks that:
 1. An interface have only sigle class implementation
 1. All functions in inlined method are public and static or belongs to *same* interface.

If all checks are passed Idea can inline interface method. (Of course it may show popup for user with warning about interface method inlining)","0"
"IDEA-202304","IntelliJ IDEA","","""Extract method object"" produces yellow and unclean code","Peter Gromov","15/11/2018 11:42","18/11/2018 04:14",,"Normal","Usability Problem",,"anet","Java. Refactorings","2018.3 (183.4284.148), 2019.1 (191.6183.87)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I tried it on today&#39;s version of <code class=""inline-code"">com.intellij.openapi.actionSystem.impl.Utils#expandActionGroup</code>. Some smells in the result:<br/>1. public constructor in a private (nested) class.<br/>2. fields are non-final where they could be.<br/>3. field names are shortened and lose meaning. E.g. <code class=""inline-code"">isInModalContext</code> becomes <code class=""inline-code"">myContext</code>.</div>
","0"
"IDEA-200750","IntelliJ IDEA","","Generate logger during method moving","Nikita Sheremet","18/10/2018 06:18","16/11/2018 13:23",,"Normal","Feature",,"anet","Java. Refactorings","2019.1 (191.6183.87)",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Consider a code:
```
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

    public class MyClass {
        private static final Logger logger = LoggerFactory.getLogger(MyClass.class);

        public static void myMethod() {
            logger.info(""ok"");
        }
    }

    public class OtherClass {

    }

```

If I press f6 on `myMethod` and select `OtherClass` as destination class I will got a warning and after click to ok button I got:
```
    public class OtherClass {
        MyClass.logger.info(""ok"");
    }
```
Where `MyClass.logger` highlighted as compilation error. I think that generating and removing `Logger`s is not a big issues. So could you please add a check box `Generate Logger in target class`. If user select this ckeck box the code will be:

```
     public class MyClass {

    }
    
    public class OtherClass {
        private static final Logger logger = LoggerFactory.getLogger(OtherClass.class);
        logger.info(""ok"");
    }
```","0"
"IDEA-202299","IntelliJ IDEA","","""Extract Method Object"" not available on method declaration","Peter Gromov","15/11/2018 10:12","15/11/2018 11:32",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;d expect it to work on the complete body of the method</div>
","0"
"IDEA-145205","IntelliJ IDEA","","Package rename works incorrectly in roots with package prefixes","Irina Petrovskaya","16/09/2015 13:02","07/11/2018 16:39",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">142.4859.6<br/><br/>lets the source root has package prefix like &#39;foo.boo.bar&#39;.<br/>Create some package with classes in it, so that classes get package statements like &#39;foo.boo.bar.aaa.bbb&#39;<br/>Invoke Refactor/Rename for &#39;bbb&#39; and enter the new path, adding new package to the structure, like<br/>&#39;foo.boo.bar.aaa.bbb.ccc&#39;:<br/>as a result, the package &#39;foo.boo.bar.foo.boo.bar.aaa.bbb.ccc&#39; is created<br/><br/>or specify target name like &#39;foo.boo.bar.aaa1.bbb&#39;: same results - the &#39;foo.boo.bar.foo.boo.bar.aaa1.bbb&#39; package is created.<br/><br/><br/>Rename works correctly if you just change the last package name, say  &#39;foo.boo.bar.aaa.bbb&#39; to  &#39;foo.boo.bar.aaa.ccc&#39;</div>
","2"
"IDEA-161080","IntelliJ IDEA","reproduced","Commented code indent is changed after var inlining","Stepan Tarasevich","12/09/2016 09:04","06/11/2018 11:10",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>IDEA version</strong>:<br/>IntelliJ IDEA 2016.2.3<br/>Build #IU-162.1812.17, built on August 30, 2016<br/>JRE: 1.8.0_112-release-b287 x86_64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/><br/><strong>Steps to reproduce</strong>:<br/>1. Create following code in any java class:<br/><pre class=""wikicode prettyprint"">  int method() {<br/>    int x = 1;<br/>    int y = 2;<br/>    return x;<br/>  }</pre><br/>2. Comment second line (y var declaration) using &quot;Comment line&quot;:<br/><pre class=""wikicode prettyprint"">  int method() {<br/>    int x = 1;<br/>//    int y = 2;<br/>    return x;<br/>  }</pre><br/>3. Inline &quot;x&quot; either using &quot;inline var&quot; refactoring or intention.<br/><br/><br/><strong>Expected result</strong>:<br/><pre class=""wikicode prettyprint"">  int method() {<br/>//    int y = 2;<br/>    return 1;<br/>  }</pre><br/><strong>Actual result</strong> (commented code indent is changed):<br/><pre class=""wikicode prettyprint"">  int method() {<br/>    //    int y = 2;<br/>    return 1;<br/>  }</pre></div>
","0"
"IDEA-200692","IntelliJ IDEA","","Add support for batch delegating","Nikita Sheremet","17/10/2018 10:37","17/10/2018 16:37",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","Consdier a code:
```
import org.springframework.stereotype.Component;

public class MyClass {
   public void myFirst() {
       System.out.println(""first"");
   }
   public void mySecond() {
       System.out.println(""second"");
   }
}
```
f I point cusrot to `MyClass` press right mouse button and select `Refactor/Extract/Delegate` I able to move methods only to single delegte class. Could you please add possibility to select several delegate classes and ""attache"" methods to each of them.
It is a common refactoring technique to split large class into multiple smaller ones why not to do this in batch?

P.S. do not forget to include functionality from https://youtrack.jetbrains.com/issue/IDEA-200691 task.","0"
"IDEA-200643","IntelliJ IDEA","","Find text occurrences when a method is moved from one class to another","Roman Leventov","16/10/2018 19:11","17/10/2018 05:28",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When method <code class=""inline-code"">foo</code> is moved from class <code class=""inline-code"">Bar</code> to <code class=""inline-code"">Buz</code>, it would be nice if IntelliJ searched for occurrences of <code class=""inline-code"">Bar.foo</code>, <code class=""inline-code"">bar.foo</code>, <code class=""inline-code"">Bar#foo</code>, etc. in String literals and comments and suggested to change them accordingly.</div>
","0"
"IDEA-129161","IntelliJ IDEA","reproduced","Canceling of refactoring of ""rename"" in test classes doesn't work","Viktor Alenkov","27/08/2014 19:01","05/10/2018 04:59",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Steps:<br/>1) Initial situation: <a href=""[](idea_rename_000.png)"">idea_rename_000.png</a><br/>2) We begin renaming (add char &quot;s&quot;): <a href=""[](idea_rename_001.png)"">idea_rename_001.png</a><br/>3) press key &quot;ESC&quot;: <a href=""[](idea_rename_002.png)"">idea_rename_002.png</a><br/><br/><div><details class=""wiki-details""><summary class=""wiki-cut-title"">russian text</summary>Не работает отмена рефакторинга &quot;rename&quot; в тестовых классах.<br/>1) Исходная ситуация: <a href=""[](idea_rename_000.png)"">idea_rename_000.png</a><br/>2) Начинаем переименование (добавили символ &quot;s&quot;): <a href=""[](idea_rename_001.png)"">idea_rename_001.png</a><br/>3) Нажимаем &quot;ESC&quot;: <a href=""[](idea_rename_002.png)"">idea_rename_002.png</a></details></div></div>
","0"
"IDEA-127165","IntelliJ IDEA","reproduced","refactoring ""Extract variable... "" captures also summaries","Viktor Alenkov","11/07/2014 04:51","05/10/2018 04:34",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Initial situation: <a href=""[](idea_ref_var_000.png)"">idea_ref_var_000.png</a><br/>the cursor was on &quot;mkdir ()&quot; in line 42: <a href=""[](idea_ref_var_001.png)"">idea_ref_var_001.png</a><br/>the cursor was on &quot;dirParent&quot; in line 42: <a href=""[](idea_ref_var_002.png)"">idea_ref_var_002.png</a><br/><br/><div><details class=""wiki-details""><summary class=""wiki-cut-title"">russian text</summary>рефакторинг &quot;Extract variable...&quot; захватывает и аннотации<br/>Исходная ситуация: <a href=""[](idea_ref_var_000.png)"">idea_ref_var_000.png</a><br/>курсор находился на &quot;mkdir()&quot; в строке 42: <a href=""[](idea_ref_var_001.png)"">idea_ref_var_001.png</a><br/>курсор находился на &quot;dirParent&quot; в строке 42: <a href=""[](idea_ref_var_002.png)"">idea_ref_var_002.png</a></details></div></div>
","0"
"IDEA-104354","IntelliJ IDEA","reproduced","Imports are not optimized after moving package","David Phillips","01/04/2013 19:14","25/09/2018 12:32",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have &quot;optimize imports on the fly&quot; enabled. When moving a package, IDEA fixes the imports, but it doesn&#39;t optimize them: they are not sorted properly.<br/><br/>It seems that I need to manually open every affected file in order to optimize the imports.<br/><br/>Original imports before moving package:<br/><br/><pre class=""wikicode prettyprint"">import com.example.a.A;<br/>import com.example.b.B;<br/>import com.example.c.C;</pre><br/>Expected imports after moving package:<br/><br/><pre class=""wikicode prettyprint"">import com.example.a.A;<br/>import com.example.c.C;<br/>import org.example.b.B;</pre><br/>Actual imports after moving package:<br/><br/><pre class=""wikicode prettyprint"">import com.example.a.A;<br/>import org.example.b.B;<br/>import com.example.c.C;</pre></div>
","5"
"IDEA-100760","IntelliJ IDEA","","Refactor/Move class doesn't reformat imports","Nick Minkler","08/02/2013 16:08","25/09/2018 12:32",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When moving/renaming a class, imports of that class in other classes are not properly reformatted automatically, the import is simply renamed to the new class/packagename. </div>
","2"
"IDEA-64748","IntelliJ IDEA","reproduced","Extracting an interface should refactor extended classes","Zach Hobbs","27/01/2011 22:51","24/09/2018 11:03",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Basic example code:<br/><br/>class Water extends Liquid { ... }<br/><br/>class Liquid {<br/> public void method();<br/>}<br/><br/>Reproduction steps:<br/> - Extract an Interface from Liquid and select &quot;method()&quot; to be extracted to new interface &quot;MyInterface&quot;.<br/> - Tell IDE to refactor instances of method() to use interface instead of Liquid class<br/><br/>Results:<br/><br/>((Liquid) obj).method() will change to: ((MyInterface) obj).method() as expected.<br/><br/>((Water) obj).method() is not refactored.  I would expect it to change to: ((MyInterface) obj).method() as well.</div>
","1"
"IDEA-198440","IntelliJ IDEA","","Introducing field of local class type should probably be disallowed","Bas Leijdekkers","05/09/2018 13:39","06/09/2018 08:55",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">For example introduce a field from the <code class=""inline-code"">new Local()</code> expression in the following code:<br/><pre class=""wikicode prettyprint"">class K {<br/>    void m() {<br/>        class Local {<br/>            void locally() {}<br/>        }<br/>        new Local().locally();<br/>    }<br/>}</pre><br/>result something like (depending on where the field is initialized):<br/><pre class=""wikicode prettyprint"">class K {<br/>    private final Local local;<br/><br/>    public K() {<br/>        local = new Local();<br/>    }<br/><br/>    void m() {<br/>        class Local {<br/>            void locally() {}<br/>        }<br/>        local.locally();<br/>    }<br/>}</pre>which does not compile.</div>
","0"
"IDEA-189551","IntelliJ IDEA","reproduced","Package move produces incorrect results in case of same names ","Irina Petrovskaya","04/04/2018 12:50","23/08/2018 13:27",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">182.1334<br/><br/>rather exotic case:<br/>consider the package aaa.bbb with classes A1, A2, B1 and package ccc.bbb, with classes A1, A2, C1.<br/>select the package aaa.bbb and move it to &#39;ccc&#39;:<br/>you get no warnings or promptings, and the results are as follows:<br/>the project still contains both aaa.bbb and ccc.bbb packages;<br/>the target (ccc.bbb) contains A1, A2, B1 and C1 classes: <br/><ul class=""wiki-list0""><li> untouched C1, <br/></li><li> correctly moved B1,<br/></li><li> A1 and A2 with original contents and correct package statements</li></ul><br/>The package  aaa.bbb still contains A1 and A2 classes, with original contents, but with &#39;ccc.bbb&#39; package statements.<br/><br/>The behavior is correct - the classes with not duplicated names are moved, the ones with existing names are skipped, - except the package statement updated for the skipped ones</div>
","0"
"IDEA-190495","IntelliJ IDEA","","Variable extract should create `var` for non denotable type in Java 10","Roman Ivanov","18/04/2018 06:31","22/08/2018 07:15",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","```
class Test {
    void f() {
        var x = new Object() {
            int a = 12;
        };
        x.a;
    }
}
```
Extracting `x` expression here leads to following code:
```
class Test {
    void f() {
        var x = new Object() {
            int a = 12;
        };
        Object x1 = x;
        ((Object) x1).a;
    }
}
```
Where `a` is unresolved.
I think, that after extraction code should be:
```
class Test {
    void f() {
        var x = new Object() {
            int a = 12;
        };
        var x1 = x;
        x1.a;
    }
}
```","1"
"IDEA-97113","IntelliJ IDEA","reproduced","Renaming properties renames too much","Erik Pragt","10/12/2012 08:43","21/08/2018 08:26",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">when I have this class:<br/><br/><pre class=""wikicode prettyprint"">class Person {<br/>   private String name;<br/><br/>   public String getName() {<br/>      return this.name;<br/>   }<br/>}</pre><br/>And I try to rename the &#39;name&#39; to, say, &#39;firstName&#39; variable in the method using shift+f6, IntelliJ also suggests to rename the getter and setter too, which is what one. When it does the renaming, IntelliJ is also looking in non-code stuff (which I don&#39;t want, no way to turn it off?), and because &#39;name&#39; is such a generic property, IntelliJ will find hundreds of (wrong) references. So, please, don&#39;t look in the noncode stuff. I have no way to rename this property now, or none that I&#39;m aware of, except for changing it by hand, recompiling the code, and see where it breaks. <br/><br/>PS: the 123.72 has a very weird location in the list of affected version, somewhere in the middle, making it hard to find.</div>
","0"
"IDEA-99605","IntelliJ IDEA","reproduced","Unable to Cut package ""org""","Vojtěch Krása","23/01/2013 11:25","20/08/2018 08:54",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I would like to move the whole packege into another location - another project, or module.<br/><br/>So I press ctrl+X and this comes up:<br/><br/>Warning:<br/><br/>Multiple directories correspond to package<br/>org:<br/><br/>D:\workspace.m2\repository\commons-httpclient\commons-httpclient\3.1\commons-httpclient-3.1.jar!\org<br/>D:\workspace.m2\repository\commons-codec\commons-codec\1.6\commons-codec-1.6.jar!\org<br/>D:\workspace.m2\repository\org\apache\commons\commons-lang3\3.1\commons-lang3-3.1.jar!\org<br/>D:\workspace.m2\repository\org\apache\httpcomponents\httpclient\4.2.2\httpclient-4.2.2.jar!\org<br/>D:\workspace.m2\repository\org\apache\httpcomponents\httpcore\4.2.2\httpcore-4.2.2.jar!\org<br/>D:\workspace.m2\repository\commons-logging\commons-logging\1.1.1\commons-logging-1.1.1.jar!\org<br/><br/>....<br/>All these directories will be moved, and all references to org <br/>will be changed.<br/>Do you wish to continue?<br/><br/><br/>F6 behaves nicer, but I do not want to waste time by choosing the path when I could just click on the right location and press ctrl+v</div>
","0"
"IDEA-195341","IntelliJ IDEA","","Introduce Variable doesn't replace all usages","Peter Gromov","10/07/2018 10:57","16/08/2018 10:45",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">Runnable r = () -&gt; {<br/>     int i = 4;<br/>   };<br/>   Predicate&lt;Integer&gt; prop = i -&gt; i != 4;</pre>Select the first <code class=""inline-code"">4</code> and introduce a variable named <code class=""inline-code"">some</code>, replacing both occurrences. Result:<br/><br/><pre class=""wikicode prettyprint"">    int some = 4;<br/>    Runnable r = () -&gt; {<br/>      int i = 4;<br/>    };<br/>    Predicate&lt;Integer&gt; prop = i -&gt; i != i;</pre></div>
","0"
"IDEA-137114","IntelliJ IDEA","reproduced","""add import"" offers not all valid options","Viktor Alenkov","28/02/2015 18:15","14/08/2018 06:08",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If code:<br/><pre class=""wikicode prettyprint"">public final class ComponentHelper {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public enum EventQueueName {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>PAGE;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre><br/>Have to try to call the action &quot;add import&quot; (Alt+Enter), then when the cursor is on the &quot;PAGE&quot; I got the only option (<a href=""[](pic01.png)"">pic01.png</a>), although I would like to see as an import option as if the cursor is on EventQueueName (<a href=""[](pic00.png)"">pic00.png</a>)<br/><br/>in other words, when the cursor is on the &quot;PAGE&quot; I want to be able to directly import static &quot;PAGE&quot;, and the parent &quot;EventQueueName&quot;<br/><br/><div><details class=""wiki-details""><summary class=""wiki-cut-title"">russian text</summary>&quot;add import&quot; предлагает не все допустимые варианты<br/><br/>Если некий исходный код:<br/><pre class=""wikicode prettyprint"">public final class ComponentHelper {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public enum EventQueueName {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>PAGE;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre><br/>Есть попробовать вызвать действие &quot;add import&quot; (Alt+Enter), то при нахождении курсора на &quot;PAGE&quot; я получую единственный вариант (<a href=""[](pic01.png)"">pic01.png</a>), хотя хотелось бы видеть так же вариант импорта, как если бы курсор находился на EventQueueName (<a href=""[](pic00.png)"">pic00.png</a>)<br/><br/>другими словами, при нахождении курсора на &quot;PAGE&quot; я хочу иметь возможность статического импорта как непосредственно &quot;PAGE&quot;, так и родительского &quot;EventQueueName&quot;</details></div></div>
","0"
"IDEA-59399","IntelliJ IDEA","","Rename method doesn't rename usages in same cases","Anton Makeev","04/10/2010 08:05","13/08/2018 11:43",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Foo.java:<br/><pre class=""wikicode prettyprint"">public class Foo {<br/>  public Foo() {<br/>    Bar b = new Bar();<br/>    b.bar(); // cursor is on the &#39;bar&#39;<br/>  }<br/>}</pre><br/>Bar.java:<br/><pre class=""wikicode prettyprint"">public class Bar {<br/>  private void bar() {<br/>  }<br/>}</pre><br/>Now staying on the b.bar() usage try renaming the method (note it is private method). After rename, the method itself is renamed, but the usage is not.<br/>Expected: usages to be renamed too.</div>
","0"
"IDEA-55326","IntelliJ IDEA","","Refactor: Extract Method Object suggests to replace duplicate expressions of not compatible type","Alexander Chernikov","27/05/2010 14:32","13/08/2018 11:24",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Provide code like:<br/><pre class=""wikicode prettyprint"">public class Some {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void context() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>long vl = 0L;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>vl++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(vl);<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int v2 = 0;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>v2++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(v2);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre>Select &quot;v1++;&quot; statement. Refactor / Extract Method Object. Agree to create inner class.<br/>Refactoring is running. Suggestion to replace duplicates appears. Agree to replace suggested fragment.<br/>Result: incompilable code due to incompatible types:<br/><pre class=""wikicode prettyprint"">public class Some {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void context() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>long vl = 0L;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>vl = new Inner(vl).invoke();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(vl);<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int v2 = 0;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>v2 = new Inner(v2).invoke(); // bug<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(v2);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>private class Inner {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>private long vl;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public Inner(long vl) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>this.vl = vl;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public long invoke() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>vl++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return vl;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre>Notice that at the moment when the suggestion shown, the resulted code of created Inner class is formatted rather badly, so it may be hard to foresee what will happen after.<br/><br/>Replace Method Duplicates in file does not find duplicates in the former source.<br/>96.278.</div>
","0"
"IDEA-53682","IntelliJ IDEA","","Refactor / Inline method inside for loop. Extra semicolon inserted.","Max Ishchenko","07/04/2010 11:54","13/08/2018 10:20",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    private void testInline() {<br/>        for (; ; go()) {<br/>        }<br/>    }<br/>    private void go() {<br/>        int a = 1;<br/>    }</pre>Now inline go() method and see that for loop looks like<br/><pre class=""wikicode prettyprint"">for (; ; int a = 1;) {</pre>See extra semicolon after inlined method body and notice that it is not highlighted as error. Type inside for loop body, and no errors for that semicolon as well. Edit anything before loop, then the error gets highlighted.</div>
","0"
"IDEABKL-7903","IntelliJ IDEA: Backlog","","Introduce variable fails for unclear reason","Maksim Medvedev","08/08/2018 07:00","13/08/2018 06:15",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","![](pic.png)","1"
"IDEA-196970","IntelliJ IDEA","","Copying a class should copy external annotations","Chris","08/08/2018 09:02","12/08/2018 10:49",,"Normal","Feature",,"anet","Java. Refactorings","2018.2.1 (182.3911.36)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>What steps will reproduce the issue?</strong><br/>1. Have a class with external annotations<br/>2. Use F5 to copy the class<br/><br/><strong>What is the expected result?</strong><br/><br/><code class=""inline-code"">annotations.xml</code> should be created/updated by copying all external annotations from the source class<br/><br/><strong>What happens instead?</strong><br/><br/>No external annotations are created.<br/><br/>IntelliJ IDEA 2018.2.1 (Ultimate Edition)<br/>Build #IU-182.3911.36, built on August 6, 2018<br/>Subscription is active until March 14, 2019<br/>JRE: 1.8.0_152-release-1248-b8 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 10 10.0</div>
","0"
"IDEA-103191","IntelliJ IDEA","","Inline inner class created invalid code","Thomas Singer","15/03/2013 08:29","10/08/2018 13:59",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Please take a look at attached sample code. Trying to inline <span class=""monospace"">create</span> in<br/><br/><div class=""wiki quote"">final Interface anInterface = bar.create();</div><br/><br/>will produce following red code:<br/><br/><div class=""wiki quote"">final Interface anInterface = new Bar.MyInterface();</div></div>
","0"
"IDEA-196277","IntelliJ IDEA","","Editor behaves really weird with imports of 'Aggregations' and 'Aggregation'","Dmitry Cherniachenko","27/07/2018 11:39","08/08/2018 05:47",,"Normal","Bug",,"anet","Java. Refactorings","2018.2.1 (182.3911.36)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am working with Elasticsearch and have a code like this:<br/><pre class=""wikicode prettyprint"">Aggregations aggregations = searchResponse.getAggregations();</pre><br/>Now I want to iterate the aggregations. So I type the &#39;foreach&#39; loop.<br/>But IDEA interferes and deletes a Space immediately after I type it - see 2018-07-27_16-24-15.mp4<br/><br/>Also with <code class=""inline-code"">for (Aggregation)</code> in the code I cannot add corresponding import manually.<br/>Deleting &#39;s&#39; in the <code class=""inline-code"">import org.elasticsearch.search.aggregations.Aggregations;</code> restores it back - see 2018-07-27_16-27-42.mp4<br/>Duplicating the above &#39;import&#39; statement deletes the copy immediately, before I have a chance to change the class name.<br/><br/>And even trying to select the import statement text behaves weirdly. Placing the caret at the beginning of the line and pressing Shift+End I get the text selected but then it immediately changes to:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEABKL-7896","IntelliJ IDEA: Backlog","","Make propagate parameters per-parameter instead of ""for all new""","Chris","29/07/2018 07:02","30/07/2018 14:39",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Currently, I either need to propagate all new parameters to the same locations or I need to invoke the refactoring multiple times.<br/><br/>It would be convenient if propagate parameters could be configured for each new parameter:<br/><br/>The button would be moved here, also, make it a bit more prominent by giving it a label &quot;propagate&quot;. This way, the feature is more discoverable.<br/>As it stands, this powerful feature is easily missed, especially because it&#39;s only available after adding a new parameter (that makes sense of course), but it adds to the subtle little things a user must pay attention to.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-196345","IntelliJ IDEA","","Allow ""Delegate via overloading method(s)"" when using parameter propagation for Change Signature","Chris","29/07/2018 07:48","30/07/2018 03:30",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently, I can either not propagate the parameters and choose to delegate, or propagate the parameters up the call chain and then use the defaults in all methods where I don&#39;t propagate.<br/><br/>It would be convenient if I could choose to delegate the parameters in combination with parameter propagation.<br/><br/>In this example scenario, IntelliJ will copy the default into 8 locations if I use default values with propagation:<br/><br/> <div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>An alternative would be to generate overloaded variants for all methods that are called from methods, that don&#39;t receive the new params.<br/><br/>With overloads, the default values would only be required in 4 additional overloads:<br/><br/> <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/>My current workflow is to leave the default value empty, and then manually create overloads:<br/>1. Go to next error<br/>2. Go to method name (needed if the methods took parameters before propagation)<br/>3. Go to method definition<br/>4. Alt-Enter: Overload with defaults<br/>5. (If more than one param) Take care to select the right params<br/>6. Insert the defaults<br/>7. Repeat for every other required overload<br/><br/><br/><br/>This, of course, is an artificial example, but it happens in practice, until now I didn&#39;t even know parameter propagation existed and did everything manually with &quot;extract parameter&quot;.<br/><br/>The number of overloads generated is always less or equal to the number of places default values need to be added.<br/><br/><br/><br/>Sample code:<br/>(I invoked change signature on the &quot;target&quot; method)<br/><br/><pre class=""wikicode prettyprint"">package refactor.signature.propagate.delegate;<br/><br/>public class CallChainBeforePropagation {<br/>    private void depth1_2_1() {<br/>        depth1_2();<br/>    }<br/><br/>    private void depth1_2_2() {<br/>        depth1_2();<br/>    }<br/><br/>    private void depth1_2_3() {<br/>        depth1_2();<br/>    }<br/><br/>    private void depth1_2_4() {<br/>        depth1_2();<br/>    }<br/><br/>    private void depth1_2() {<br/>        depth1();<br/>    }<br/><br/>    private void depth1_4() {<br/>        depth1_2();<br/>    }<br/>    <br/>    private void depth1_4_1() {<br/>        depth1_4();<br/>    }<br/><br/>    private void depth1_3() {<br/>        depth1();<br/>    }<br/>    <br/>    private void depth1_3_1() {<br/>        depth1_3();<br/>    }<br/><br/>    private void depth1_1() {<br/>        depth1();<br/>    }<br/><br/>    private void depth1() {<br/>        target();<br/>    }<br/><br/>    private void depth2() {<br/>        target();<br/>    }<br/><br/>    private void target() {<br/>    }<br/>}</pre></div>
","0"
"IDEA-196341","IntelliJ IDEA","","Propagate parameters: Rename parameters with conflicts","Chris","29/07/2018 05:52","30/07/2018 03:29",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">What steps will reproduce the issue?<br/>1. Change signature<br/>2. Add some parameter<br/>3. propagate it up the call chain (some method in the call chain must already have a parameter by that name!)<br/>4. Ignore conflicts and refactor<br/><br/>What is the expected result?<br/>IntelliJ could offer a way to rename the parameters only where there would be duplicates.<br/><br/>The obvious workaround is to simply choose a different name myself or use &quot;param2&quot; instead of param. However, this isn&#39;t very convenient if only a single method in the call chain has a parameter by that name, I want to use the &quot;proper&quot; name wherever possible only only use a different parameter name where needed.<br/><br/>If you have a couple of call chains, it would be inconvenient to go the other way around, especially since parameter renames aren&#39;t propagated up the call chain.<br/><br/>Just accepting the conflict also isn&#39;t ideal:<br/>(I added &quot;String param&quot; to depth3 and propagated it to depth2)<br/><br/> <div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>If you imagine the code to be a bit more complex, ideally the conflicting params have the same type to make it a bit more difficult, you then need to manually replace newly inserted &quot;param&quot;-arguments to the renamed parameter.<br/><br/>This is to be expected of course, it&#39;s just why this feature would be convenient.<br/><br/><strong>Solution ideas</strong> in ascending order of imagined difficulty :) and improved user experience<br/>1. Have IntelliJ add a prefix wherever the parameter name would result in conflicts<br/>2. Prompt for a different name for each conflict (you could still offer an &quot;ignore&quot; option<br/>3. Integrate the conflict resolution directly into the propagation dialog<br/> <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/><br/>In an ideal world, IntelliJ would offer the ability to rename propagated parameters directly in the above dialog.<br/>All parameters <strong>could</strong> be renamed if so desired, those that &quot;must&quot; be would give some red indicator in the tree.<br/>The user can still choose not to correct those issues.<br/>When the user hits &quot;Refactor&quot;, IntelliJ brings up a dialog if conflicts remain:<br/><ul class=""wiki-list0""><li> Auto-Rename all conflicting<br/></li><li> Choose different names (this would either open multiple prompts one after another or an all-in-one-prompt)<br/></li><li> Ignore conflicts</li></ul><br/><pre class=""wikicode prettyprint"">package generic;<br/><br/>public class CallChain {<br/>    private void depth1() {<br/>        depth2(&quot;My first parameter&quot;);<br/>    }<br/><br/>    private void depth2(String param) {<br/>        depth3();<br/>    }<br/><br/>    private void depth3() {<br/>        System.out.println(&quot;hello there&quot;);<br/>    }<br/>}</pre></div>
","0"
"IDEA-103910","IntelliJ IDEA","static import","Refactoring (moving package/source root) undoes static imports and breaks code","Anders Wallgren","25/03/2013 23:53","27/07/2018 14:47",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;ve noticed lately that when refactoring classes into different packages/source roots that static imports are &quot;undone&quot;, e.g.<br/><br/>someCall(foo) <br/><br/>reverts to <br/><br/>someCall(ClassName.foo)<br/><br/>However, (1) the static import remains in the file and (2) the import for ClassName is NOT inserted, so the code no longer compiles.</div>
","1"
"IDEABKL-7894","IntelliJ IDEA: Backlog","","Remove redundant ""this"" qualifier during extracting method.","Yaroslav Bedrov","26/07/2018 23:19","27/07/2018 05:11",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Imagine this code: <br/><br/><pre class=""wikicode prettyprint"">Verifier(Map&lt;String, String&gt; headers) { <br/>    this.headers = headers; <br/>    this.bibId = this.headers.get(Headers.X_BIB_ID); <br/>} </pre><br/>Imagine I select the second line of the constructor and press Ctrl+Alt+M for &quot;Extract method&quot; refactor. The result would be: <br/><br/><pre class=""wikicode prettyprint"">Verifier(Map&lt;String, String&gt; headers) { <br/>    this.headers = headers; <br/>    this.bibId = getBibId(); <br/>} <br/>private String getBibId() { <br/>    return this.headers.get(Headers.X_BIB_ID); <br/>} </pre><br/>Everytime I do this, i need to remove the redundant &quot;this&quot; in the extracted method. It&#39;s clear to me that it&#39;s there, because it&#39;s required in the constructor (because there is a field <code class=""inline-code"">headers</code> and a parameter <code class=""inline-code"">headers</code>). After extraction, though, it&#39;s not crucial anymore and this <code class=""inline-code"">this</code> is not necessary anymore, and I would like to get rid of it. <br/>Is there a possibility to create a settings with a checkbox: &quot;Remove redundant <code class=""inline-code"">this</code> after extracting method&quot;?</div>
","0"
"IDEA-163473","IntelliJ IDEA","","copy documentation to getter","Pascal Knueppel","02/11/2016 09:17","23/07/2018 09:03",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">in most cases the fields of a class are private and the getter methods often do not have the proper documentation. therefore I would like to ask of it is possible to add a feature in which the documentation of the member fields within a class can be copied directly to the getter method. At the moment I extended the getter creation with something like this<br/>/**<br/>         *  <a href=""https://youtrack.jetbrains.com/users/see"" title=""see"" data-user-id=""11-484099"">Stanislav Emelin</a> #articleTaxe<br/>         */<br/>but this is rather inconvenient when I want to use the getter and the documentation can only be seen when I click the link instead of seeing it directly. Therefore the documentation copy function would be a great thing. The same for setter hopefully vice versa from getter and setter to the field.</div>
","0"
"IDEA-63953","IntelliJ IDEA","reproduced","introduce variable: should not suggest inaccessible type","Taras Tielkes","07/01/2011 11:47","23/07/2018 05:46",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">package foo;<br/><br/>public interface BaseInterface {}</pre><pre class=""wikicode prettyprint"">package foo;<br/><br/>interface DerivedInterface extends BaseInterface {}</pre><pre class=""wikicode prettyprint"">package foo;<br/><br/>public class Target {<br/>    public static DerivedInterface getSomething() {<br/>        return null;<br/>    }<br/>}</pre><pre class=""wikicode prettyprint"">package bar;<br/><br/>import foo.Target;<br/><br/>public class Caller {<br/>    public static void main(String[] args) {<br/>        &lt;selection&gt;Target.getSomething()&lt;/selection&gt;;<br/>    }<br/>}</pre><br/>Invoke <em>Introduce Variable</em> from selection.<br/>IDEA will default to using inaccessible interface type <em>DerivedInterface</em> (it&#39;s package local, and cannot be referenced from the package of the caller).<br/>It would make more sense if IDEA would default to a type that is actually accessible, I think.</div>
","1"
"IDEA-90737","IntelliJ IDEA","reproduced","""Extract superclass"" and ""extract interface"" should offer to create inner class and interface when the current class is a nested one","Davide Baroncelli","28/08/2012 16:45","20/07/2018 13:53",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It frequently happens to me to want to build a small nested hierarchy inside another class, and it looks like IDEA does not have specific support for the &quot;extract&quot; refactorings applied to inner classes.</div>
","2"
"IDEA-195756","IntelliJ IDEA","reply needed","Refactoring: push method call in parameter to function","Igor Karpov","18/07/2018 15:10","19/07/2018 08:38",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","(Perhaps, this refactoring exists already, but I have no idea)

Quite often, there is need for the following refactoring: given
```java
Something something;
called(something.invokeSomeMethod());

void called(Type v) {
}
```
and want to refactor it into
```java
Something something;
called(something);

void called(Something something) {
...
Type v = something.invokeSomeMethod()
}
```

that is, invocation something.invokeSomeMethod() is ""pushed"" into method ""called"".
So, it is reverse of ""extract parameter"".
It would be nice, if the invocation ""Type v= ..."" would be placed nearer to it usage site with the narowest possible scope, e.g:

```java
Something something;
called(something);

void called(Something something) {
if (whatever()) {
  notImportant();
  Type v = something.invokeSomeMethod(); // invocation placed here, right before usage of 'v'
  v.used();
} else {
  //
}
}
```
.. or, pehaps, give a choice:
- place the invocation only once
- place the invocation before every usage

Not clear, what to do, if called() used from multiple places - perhaps, support only methods that are called from one place only.

It is possible to extract var + extract new method + inline old + move method if inlined method was in another class... that's time-consuming, and code formatting suffers..","0"
"IDEA-96653","IntelliJ IDEA","reproduced","Rename variable produces non compilable code while editing spaces between var name and type","Olesya Shafirova","05/12/2012 08:40","19/07/2018 06:24",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">code:<br/><br/>public class Test {<br/>    public static void main(String[] args) {<br/>        load1();<br/>        load2();<br/>        load3();<br/>        load4();<br/>        load5();<br/>    }<br/><br/>    private static void load1() {<br/>        //To change body of created methods use File | Settings | File Templates.<br/>    }<br/><br/>    private static void load2() {<br/>        //To change body of created methods use File | Settings | File Templates.<br/>    }<br/><br/>    private static void load3() {<br/>        //To change body of created methods use File | Settings | File Templates.<br/>    }<br/><br/>    private static void load4() {<br/>        //To change body of created methods use File | Settings | File Templates.<br/>    }<br/><br/>    private static void load5() {<br/>        int i = 0;<br/>    }<br/>}<br/><br/>Try to rename variable i, delete whitespace before it, add whitespace. Press enter. Whitespace deleted in the result code, code is non compilable. Choose &quot;Continue editing&quot; option. &quot;load5&quot; method name is deleted in the method call.</div>
","3"
"IDEA-195521","IntelliJ IDEA","","exception on moving a folder","Mihail Muhin","12/07/2018 14:26","18/07/2018 12:08",,"Major","Exception",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have moved a module (containing IDataFlowBuilder)<br/><br/><code class=""inline-code"">Assertion failed: PsiClass:IDataFlowBuilder<br/>java.lang.Throwable: Assertion failed: PsiClass:IDataFlowBuilder<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:163)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveClassesOrPackages.MoveJavaFileHandler.retargetUsages(MoveJavaFileHandler.java:76)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at org.jetbrains.kotlin.idea.refactoring.move.moveFilesOrDirectories.FqNameFixingMoveJavaFileHandler.retargetUsages(FqNameFixingMoveJavaFIleHandler.kt:53)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesProcessor.retargetUsages(MoveFilesOrDirectoriesProcessor.java:295)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesProcessor.performRefactoring(MoveFilesOrDirectoriesProcessor.java:195)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.lambda$doRefactoring$9(BaseRefactoringProcessor.java:475)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.lambda$doRefactoring$10(BaseRefactoringProcessor.java:486)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.impl.ApplicationImpl.lambda$runEdtProgressWriteAction$15(ApplicationImpl.java:971)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$1(CoreProgressManager.java:157)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:580)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:525)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:85)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:144)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.progress.util.PotemkinProgress.runInSwingThread(PotemkinProgress.java:167)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.impl.ApplicationImpl.runEdtProgressWriteAction(ApplicationImpl.java:971)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.impl.ApplicationImpl.runWriteActionWithNonCancellableProgressInDispatchThread(ApplicationImpl.java:951)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.doRefactoring(BaseRefactoringProcessor.java:486)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.lambda$execute$2(BaseRefactoringProcessor.java:313)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:129)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:95)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:85)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.execute(BaseRefactoringProcessor.java:311)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.doRun(BaseRefactoringProcessor.java:242)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.BaseRefactoringProcessor.run(BaseRefactoringProcessor.java:558)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesUtil$1.lambda$run$1(MoveFilesOrDirectoriesUtil.java:173)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:129)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:95)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:85)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesUtil$1.run(MoveFilesOrDirectoriesUtil.java:136)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesDialog.lambda$doOKAction$1(MoveFilesOrDirectoriesDialog.java:228)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:137)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:95)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:85)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:71)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesDialog.doOKAction(MoveFilesOrDirectoriesDialog.java:211)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.DialogWrapper$OkAction.doAction(DialogWrapper.java:1868)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.DialogWrapper$DialogWrapperAction.actionPerformed(DialogWrapper.java:1828)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:2022)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2348)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:402)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:259)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:252)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.processMouseEvent(Component.java:6548)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at javax.swing.JComponent.processMouseEvent(JComponent.java:3325)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.processEvent(Component.java:6313)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.processEvent(Container.java:2237)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEventImpl(Component.java:4903)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2295)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4725)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4889)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4526)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4467)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2281)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Window.dispatchEventImpl(Window.java:2746)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4725)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:764)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.access$500(EventQueue.java:98)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:715)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:709)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:90)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:737)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:735)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEvent(EventQueue.java:734)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:786)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:723)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:395)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:109)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.WaitDispatchSupport$2.run(WaitDispatchSupport.java:190)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.WaitDispatchSupport$4.run(WaitDispatchSupport.java:235)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.WaitDispatchSupport$4.run(WaitDispatchSupport.java:233)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.WaitDispatchSupport.enter(WaitDispatchSupport.java:233)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Dialog.show(Dialog.java:1077)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(DialogWrapperPeerImpl.java:694)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(DialogWrapperPeerImpl.java:426)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.DialogWrapper.invokeShow(DialogWrapper.java:1688)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.ui.DialogWrapper.show(DialogWrapper.java:1637)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.MoveFilesOrDirectoriesUtil.doMove(MoveFilesOrDirectoriesUtil.java:189)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.moveFilesOrDirectories.JavaMoveFilesOrDirectoriesHandler.doMove(JavaMoveFilesOrDirectoriesHandler.java:87)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.MoveHandler.doMove(MoveHandler.java:129)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.refactoring.move.MoveHandler.invoke(MoveHandler.java:118)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.projectView.impl.ProjectViewDropTarget$MoveDropHandler.lambda$doDrop$0(ProjectViewDropTarget.java:338)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(TransactionGuardImpl.java:88)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.openapi.application.TransactionGuardImpl.submitTransactionAndWait(TransactionGuardImpl.java:153)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.projectView.impl.ProjectViewDropTarget$MoveDropHandler.doDrop(ProjectViewDropTarget.java:337)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.projectView.impl.ProjectViewDropTarget$MoveDropHandler.doDrop(ProjectViewDropTarget.java:301)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.projectView.impl.ProjectViewDropTarget.doDrop(ProjectViewDropTarget.java:167)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.projectView.impl.ProjectViewDropTarget.drop(ProjectViewDropTarget.java:134)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.dnd.DnDManagerImpl$MyDropTargetListener.doDrop(DnDManagerImpl.java:678)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.dnd.DnDManagerImpl$MyDropTargetListener.drop(DnDManagerImpl.java:653)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.dnd.DropTarget.drop(DropTarget.java:455)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at sun.awt.dnd.SunDropTargetContextPeer.processDropMessage(SunDropTargetContextPeer.java:538)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at sun.lwawt.macosx.CDropTargetContextPeer.processDropMessage(CDropTargetContextPeer.java:143)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at sun.awt.dnd.SunDropTargetContextPeer$EventDispatcher.dispatchDropEvent(SunDropTargetContextPeer.java:852)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at sun.awt.dnd.SunDropTargetContextPeer$EventDispatcher.dispatchEvent(SunDropTargetContextPeer.java:776)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at sun.awt.dnd.SunDropTargetEvent.dispatch(SunDropTargetEvent.java:48)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEventImpl(Component.java:4758)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2295)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4725)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4889)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.processDropTargetEvent(Container.java:4600)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4462)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Container.dispatchEventImpl(Container.java:2281)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Window.dispatchEventImpl(Window.java:2746)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.Component.dispatchEvent(Component.java:4725)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:764)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.access$500(EventQueue.java:98)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:715)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$3.run(EventQueue.java:709)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:90)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:737)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue$4.run(EventQueue.java:735)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.AccessController.doPrivileged(Native Method)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventQueue.dispatchEvent(EventQueue.java:734)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:786)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:723)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:395)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)</code></div>
","0"
"IDEA-195552","IntelliJ IDEA","","Extract constant places comment at end of previous line","Scott Stewart","13/07/2018 08:34","13/07/2018 14:53",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","##### What steps will reproduce the issue?
1. Create a class like this:

```
public class ExtractConstantTest {

    private String a;

    public void testRefactor() {
        String b = ""test""; // Some comment
        System.out.println(b);
    }
}
```

2. Extract the variable `b` to a constant using the context menu or the keyboard shortcut

##### What is the expected result?

I would expect the comment to be extracted with the constant, either remaining on the same line as the extracted constant or on a blank line above the constant

##### What happens instead?

The comment is placed on the end of the line of the existing field `a`, i.e.

```
public class ExtractConstantTest {

    private String a;// Some comment
    private static final String B = ""test"";

    public void testRefactor() {
        System.out.println(B);
    }
}
```

##### IDE build

IntelliJ IDEA 2018.2 EAP (Ultimate Edition)
Build #IU-182.3684.2, built on July 10, 2018
IntelliJ IDEA EAP User
Expiration date: August 9, 2018
JRE: 1.8.0_152-release-1248-b8 x86_64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
macOS 10.12.4


","0"
"IDEA-195261","IntelliJ IDEA","","Make ""Escape"" consistent for refactoring/templates","Chris","09/07/2018 08:19","12/07/2018 04:01",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently, Escape does either of two things for different refactorings/intentions/templates:<br/><br/><ul class=""wiki-list0""><li> Accept &quot;refactoring&quot;/template<br/></li><li> Reject refactoring</li></ul><br/><br/>I think this isn&#39;t really intuitive nor desirable.<br/><br/><br/>I&#39;m assuming this is because some intentions such as &quot;Create variable&quot; or &quot;create field&quot; are implemented through live templates and hitting Escape for templates simply stops editing the template.<br/><br/><strong>I don&#39;t think the user should have to care about these implementation differences to understand why sometimes they can just smash escape to confirm a &quot;refactoring&quot; (intention that uses a template) and sometimes they throw away their refactoring.</strong><br/><br/>This is even more confusing because some postfix completions are actually shortcuts for refactoring, whereas others are shortcuts for templates.<br/>Some intentions are actual refactorings whereas other intentions may seem like refactorings but are actually inserting a template somewhere.</div>
","0"
"IDEABKL-7880","IntelliJ IDEA: Backlog","","Inline variable: Don't show dialog if there is only one occurrence","Chris","05/07/2018 08:54","09/07/2018 08:21",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Have code that triggers this inspection:<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>Then, instead of applying the quick-fix, use Ctrl-Alt-N (inline variable).<br/><br/>With the shortcut, I get this dialog:<br/> <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/>In this case, the dialog can be skipped. I expect the same behavior as when applying the quick fix.<br/><br/>(I don&#39;t want to check the &quot;do not show...&quot; checkbox because when a variable occurs multiple times, I want to see this dialog)</div>
","0"
"IDEA-195246","IntelliJ IDEA","","Inline this variable only and keep this reference: Cannot perform refactoring, variable is accessed for writing","Chris","09/07/2018 06:26","09/07/2018 07:30",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">String bla = &quot;bla&quot;;<br/><br/>        System.out.println(bla);<br/>        bla = &quot;bla3&quot;;<br/>        System.out.println(bla);<br/>        System.out.println(bla);<br/>        bla = &quot;bla4&quot;;<br/>        System.out.println(bla);</pre><br/><br/> <div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/><br/>1. Use Ctrl-Alt-N (inline) on the second assignment.<br/><br/>What is the expected result?<br/><br/>Don&#39;t allow me to choose something that won&#39;t work.<br/><br/>What happens instead?<br/><br/>IntelliJ tells me after the fact that this refactoring doesn&#39;t apply to this situation.<br/><br/> <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/>IntelliJ IDEA 2018.2 EAP (Ultimate Edition)<br/>Build #IU-182.3569.1, built on July 3, 2018<br/>IntelliJ IDEA EAP User<br/>Expiration date: August 2, 2018<br/>JRE: 1.8.0_152-release-1226-b7 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 10 10.0</div>
","0"
"IDEA-136864","IntelliJ IDEA","","""Copy class"" uses unmodified serialVersionUID","Stephan Windmüller","23/02/2015 11:34","27/06/2018 10:39",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When copying a class with the &quot;Copy class&quot; method, the serialVersionUID of the original class is copied as-is. This may result in duplicate UIDs, so it would be nice if IntelliJ just creates a new one.</div>
","0"
"IDEA-92605","IntelliJ IDEA","reproduced","Detect conflicts for rename local variable","Maksim Medvedev","08/10/2012 12:36","25/06/2018 13:45",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">int x = 0;<br/><br/>int y = -1;</pre><br/>try to rename &#39;y&#39; to &#39;x&#39;. No warning is shown.</div>
","2"
"IDEABKL-7858","IntelliJ IDEA: Backlog","","""Extract variable"" from function call does not analyze side effects","Sergey","11/06/2018 13:04","12/06/2018 10:52",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","What steps will reproduce the issue?
1. Make two (ore more) calls of function with side effects.
2. Use ""Extract variable"" at any call.
3. Select ""Replace all N occurences"".

What is the expected result?
Variable with result of one call will be created and used in all places in code.

What happens instead?
Same variable, but with reinitializing in all places where was function call.

It's normal behavior for functions without side effects, but it make bugs for functions with them. It would be nice to add a warning when used on a function that can have side effects. Or make possible change behavior: reinit at all places or not (""Replace all N occurences with reinitialization"").","0"
"IDEA-193565","IntelliJ IDEA","","Extracting function call with `this` as parameter to variable ignores scope of `this`","Kay-Uwe Janssen","08/06/2018 06:13","08/06/2018 07:54",,"Normal","Bug",,"anet","Java. Refactorings","2018.1.5 (181.5284.24)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","#### What steps will reproduce the issue?

    import java.util.function.Consumer;
    
    class Scratch {
        public static void main(String[] args) { new Scratch(); }
    
        private Scratch() {
            Scratch theScratch = f(this);
    
            new Runnable() {
                @Override
                public void run() {
                    Runnable theRunnable = f(this);
                }
            }.run();
    
            new Consumer<String>() {
                @Override
                public void accept(String s) {
                    Consumer<String> theFunction = f(this);
                }
            }.accept(null);
        }
    
        <T> T f(T o) { return o; }
    }
Try to extract one of the `f(this);` calls.

#### What is the expected result?
Extraction of that single call as none of the calls are equal to another due to differently scoped versions of `this`.

#### What happens instead?
IntelliJ asks if it should only replace the selected occurence or all three.
","2"
"IDEA-155244","IntelliJ IDEA","","Reuse existing variable for extracted expression","Dmitry Cherniachenko","26/04/2016 09:20","31/05/2018 16:46",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider the following code:<br/><pre class=""wikicode prettyprint"">        Map&lt;String, String&gt; props = new TreeMap&lt;&gt;();<br/><br/>        String value = props.get(&quot;abc&quot;);<br/>        if (value != null) {<br/>            System.out.println(props.get(&quot;abc&quot;));<br/>        }</pre><br/>When I run &quot;Extract Variable&quot; for either <code class=""inline-code"">props.get(&quot;abc&quot;)</code> IDEA finds the other instance and suggests to replace both occurrences.<br/>Here is the result of such extraction:<br/><pre class=""wikicode prettyprint"">        String abc = props.get(&quot;abc&quot;);<br/>        String value = abc;<br/>        if (value != null) {<br/>            System.out.println(abc);<br/>        }</pre><br/>IDEA could do better and end up with:<br/><pre class=""wikicode prettyprint"">        String value = props.get(&quot;abc&quot;);<br/>        if (value != null) {<br/>            System.out.println(value);<br/>        }</pre><br/>P.S. Probably in such case the popup (&quot;Replace this&quot; / &quot;Replace all&quot;) could have a third option: &quot;Reuse existing variable&quot;.</div>
","1"
"IDEA-192224","IntelliJ IDEA","","Copy Class user experience can be improved","Kevin Connor Arpe","17/05/2018 21:35","17/05/2018 21:46",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">IntelliJ IDEA 2018.2 EAP (Ultimate Edition)<br/>Build #IU-182.2371.4, built on May 15, 2018<br/>IntelliJ IDEA EAP User<br/>Expiration date: June 14, 2018<br/>JRE: 1.8.0_152-release-1226-b7 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 7 6.1<br/><br/>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/><br/>Imagine you have a package called <span class=""monospace"">a.b.c</span> with a test called <span class=""monospace"">MyTest</span>.  If you try to copy this class to a new package called <span class=""monospace"">a.b.d</span> and call the test class <span class=""monospace"">OtherTest</span>, IntelliJ will suggest to put new class (and package) in non-test &quot;main&quot; module / sub-dir.<br/><br/>Can this be improved?  Example: If copying a test, assume to use same module / sub-dir?  I am unsure of the best suggestion.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-171386","IntelliJ IDEA","","Change Signature dialog: parameter Type field: completion list is not hidden on leaving the field with Shift+Tab","Alexander Chernikov","12/04/2017 14:59","11/05/2018 06:24",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Call Change Signature dialog for any method/function.<br/>Alt+Ins to add a parameter. Reach Type field.<br/>Get completion list with types (either wait for autocompletion, or press Ctrl+Space, the issue occurs anyway).<br/>Shift+Tab to go to previous field: the focus jumps as requested, but the completion list is still shown. That&#39;s the issue. It should hide.<br/><br/>NB: by Tab the list hides: expected.<br/><br/>IDEA 172.1423.</div>
","0"
"IDEA-191636","IntelliJ IDEA","reproduced","Override method produces red code (in this slightly obscure case)","Bas Leijdekkers","09/05/2018 07:32","09/05/2018 07:32",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","To reproduce:

    package abc;
    class T {}
    class Simple<T> {

        <T> boolean containsNull(List<T> list) {
          for (T t : list) {
            if (t == null) return true;
          }
          return false;
        }
    }
    class LessSimple extends Simple<String> {
      // override containsNull() here.
    }

result:

    class LessSimple extends Simple<String> {
      @Override
      <T> boolean containsNull(List<abc.T> list) { // uses class T instead of type parameter 
        return super.containsNull(list);
      }
    }","0"
"IDEA-41437","IntelliJ IDEA","reproduced","Inline Local: No warning on reassignment of variable used in initializer","Maarten Hazewinkel","10/10/2007 11:57","01/05/2018 08:04",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">For the following code sample:<br/><br/><pre class=""wikicode prettyprint""><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public boolean fillBean(DataBean dataBean, Map&lt;Object, Object&gt; bibitSession) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>session = bibitSession;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// get the session token from databean<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>bean = (PayPalDataBean)dataBean;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>String token = bean.getToken();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>String payerId = bean.getPayerId();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// use this to retrieve stored bean<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>bean = (PayPalDataBean)session.get(token);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// figure out whether the Bibit confirmation page should be shown<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// or not<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>boolean showConfirmationPage = &quot;true&quot;.equals(PropertyFactory.get().getPropertyMap(&quot;paypal.api-&quot; + bean.getOrder().getMoney().getCurrencyCode().toLowerCase() + &quot;.*&quot;).get(&quot;showConfirmationPage&quot;));<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>if (!showConfirmationPage) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// TODO: always do this once all currencies have been configured to not use the confirmation page<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>bean.setPayerId(payerId);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>bean.setResult(SUCCESS);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>// now remove this session object, we don&#39;t need it any more<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>session.remove(token);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return true;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre><br/>If we inline the <span class=""monospace"">payerId</span> local variable, that is done without comment. This produces a logic bug since between the point where the variable is created/initialized with <br/><span class=""monospace"">String payerId = bean.getPayerId();</span><br/>and the point where it is used in <br/><span class=""monospace"">bean.setPayerId(payerId);</span><br/>the object from which it is initialized is changed by <br/><span class=""monospace"">bean = (PayPalDataBean)session.get(token);</span><br/><br/>This means that the resulting code of<br/><span class=""monospace"">bean.setPayerId(bean.getPayerId());</span><br/>is logically different from the previous code.<br/><br/>It would be good if a check could be part of the inline refactoring to prevent or at least warn about such inline actions.<br/><br/>Environment: n/a</div>
","3"
"IDEA-178342","IntelliJ IDEA","","Support 'Extract field' from method parameter","Andrey Turbanov","31/08/2017 14:16","30/04/2018 09:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class ExtractField {<br/>    public ExtractField(String &lt;caret&gt;value) {<br/>    }<br/>}</pre><br/>Invoke &#39;Extract field&#39; action<br/><br/><strong>Expected</strong><br/>IDEA creates field <code class=""inline-code"">value</code> and initialize it with from <code class=""inline-code"">value</code> parameter<br/><br/><strong>Actual</strong><br/>IDEA shows error about failed refactoring<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-190940","IntelliJ IDEA","","Bulk ""move to upper level""","Brice Dutheil","25/04/2018 10:00","27/04/2018 06:43",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","### What steps will reproduce the issue?

1. Have a class like 

```java
public interface Resource {

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    class A {
        ...
    }

    class B {
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    class C {
        ...
    }

    // and many more
}
```

2. Select the text off all inner classes (without the enclosing `Resource` class / interface), and move them else where, with your mouse. Or use the shortcut, usually F6.

#### What is the expected result?

IntelliJ IDEA moves in bulk mode those classes to the desired location, and ask them to be added to git in bulk mode as well.

#### What happens instead?

IntelliJ moves the enclosing type to the desired location, but may fail if the package is the same as the enclosing type.","0"
"IDEA-110797","IntelliJ IDEA","","very slow ""Change Signature""","Vladimir Krivosheev","19/07/2013 11:21","24/04/2018 07:29",,"Normal","Bug",,"daniil.ovchinnikov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">CPU: 3.4 GHz Intel Core i7 RAM: 16 GB IDEA caches on RAM drive, SSD RAID 0.<br/>And I wait 8 minutes to do simple change method signature (only two implementations).<br/><br/>ElementPreviewProvider, change method &quot;show&quot; — add last parameter &quot;boolean keyTriggered&quot;. </div>
","0"
"IDEABKL-7721","IntelliJ IDEA: Backlog","","Copy/Paste and Cut/Paste are not available for UI forms but Drag&Drop and Move (F6) do work","Mikhail Gedzberg","13/02/2007 10:20","20/04/2018 13:07",,"Normal","Usability Problem","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Open",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped""></div>
","0"
"IDEA-157638","IntelliJ IDEA","reproduced","'Extract variable' produces uncompilable source for lambda","Andrey Turbanov","19/06/2016 18:27","19/04/2018 09:09",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    void e(Collection&lt;? extends Number&gt; metrics) {<br/>        metrics.forEach(o -&gt;&lt;caret&gt; System.out.println(1));<br/>    }</pre><br/>Run refactoring: &#39;Extract variable&#39;<br/><br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">        Consumer&lt;Number&gt; consumer = o -&gt; System.out.println(1);<br/>        metrics.forEach(consumer);</pre><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">        Consumer&lt;? extends Number&gt; consumer = o -&gt; System.out.println(1);<br/>        metrics.forEach(consumer);</pre></div>
","2"
"IDEA-173583","IntelliJ IDEA","","""Join Lines"" could inline the earlier assignment","Dmitry Cherniachenko","29/05/2017 12:33","19/04/2018 07:18",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When joining two assignment lines where the second one uses the earlier assigned value, like here:<br/><pre class=""wikicode prettyprint"">        float reliabilityThreshold = Float.MAX_VALUE;<br/>        reliabilityThreshold = Math.min(reliabilityThreshold, calculateReliabilityThreshold(...));</pre><br/>IDEA could inline the earlier value (<code class=""inline-code"">Float.MAX_VALUE</code>) automatically:<br/><pre class=""wikicode prettyprint"">        float reliabilityThreshold = Math.min(Float.MAX_VALUE, calculateReliabilityThreshold(...));</pre></div>
","0"
"IDEA-189951","IntelliJ IDEA","","Pull Up Field changes the field visibility","Jonhnanthan Oliveira","10/04/2018 09:06","10/04/2018 14:47",,"Normal","Bug",,"anet","Java. Refactorings","2017.3.5 (173.4674.33)",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Applying the pull up field refactoring in B.f, the visibility of the field changed without any warning to the user.<br/><br/>&ndash;Before refactoring<br/><pre class=""wikicode prettyprint"">public class A {}<br/><br/>public class B extends A {<br/>  private int f = 11;<br/>  public long m(){<br/>    return f;<br/>  }<br/>}</pre>&ndash;Resulting Program<br/><pre class=""wikicode prettyprint"">public class A {<br/>  protected int f = 11;<br/>}<br/><br/>public class B extends A {<br/>  public long m(){<br/>    return f;<br/>  }<br/>}</pre></div>
","0"
"IDEA-189453","IntelliJ IDEA","","Wrap return value: support factory methods and custom getters","Anna Kozlova","03/04/2018 11:17","03/04/2018 13:25",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">To be able to wrap with <code class=""inline-code"">Optional</code>.</div>
","0"
"IDEA-188509","IntelliJ IDEA","javadoc","When IDEA suggests to rename parameter in hierarchy there should be an option for code / all occurrences","Dmitry Cherniachenko","19/03/2018 10:12","19/03/2018 15:20",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Reproduced","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Take the following code snippet for example:<br/><pre class=""wikicode prettyprint""><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public static abstract class A {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>/**<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span> * @param value a value to process<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span> */<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public abstract void callMe(int value);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public static class B extends A {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>@Override<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public void callMe(int value) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>if (value &lt; 0) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>throw new IllegalArgumentException(&quot;value must be positive&quot;);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}</pre><br/>When renaming either of the &#39;value&#39; parameters IDEA asks whether to rename code or all occurrences (to also update javadoc / exception message).<br/><br/>After renaming &#39;value&#39; in class <code class=""inline-code"">A</code> IDEA suggests to also rename the parameter in overridden method in <code class=""inline-code"">B</code>:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/>But there is no option for &quot;all occurrences&quot; there. So the exception message will be left referencing the old parameter name.</div>
","0"
"IDEA-185848","IntelliJ IDEA","","extract common members from two classes into new super class","Gregor Rosenauer","30/01/2018 10:34","02/03/2018 18:49",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Sometimes, lazy developers just duplicate classes and add one or two fields, e.g. to match a HTTP request in a mapping object.<br/>It would be very helpful to have a refactoring function that:<br/><ul class=""wiki-list0""><li> scans selected classes for duplicate members<br/></li><li> moves them to a common super class and<br/></li><li> removes duplicate members from now sub classes</li></ul><br/>Is such a feature planned? I see it was <a href=""https://intellij-support.jetbrains.com/hc/en-us/community/posts/206839375-extract-common-members-from-two-classes?page=1#community_comment_360000027650"" target=""_blank"" rel=""noopener noreferrer"">mentioned already in 2014 in the forums</a>, but got no further attention, unfortunately.<br/>Taking the sample code from there:<br/><pre class=""wikicode prettyprint"">class A {<br/>   pirvate String fieldName;<br/>   private String someOtherA;<br/>   //getters/setters here<br/>}<br/><br/><br/>class B {<br/>  private String fieldName;<br/>  private String someOtherB;<br/>   //getters/setters here<br/>}</pre><br/>would be transformed into:<br/><pre class=""wikicode prettyprint"">class Basic {<br/>     private String fieldName;<br/>        //getters/setters here<br/>}<br/><br/>class A extends  Basic {<br/>  private String someOtherA;<br/>      //getters/setters here<br/>}<br/><br/><br/>class B extends  Basic {<br/>  private String someOtherB;<br/>  //getters/setters here<br/>}</pre></div>
","0"
"IDEA-187275","IntelliJ IDEA","reproduced","Move Class doesn't report visibility problems for usages of its members","Alexey Sedunov","26/02/2018 11:36","26/02/2018 11:37",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Given two Java classes<br/><pre class=""wikicode prettyprint"">package test;<br/><br/>public class Foo {<br/>    static class Bar {<br/><br/>    }<br/>}</pre>and<br/><pre class=""wikicode prettyprint"">package test;<br/><br/>public class Test {<br/>    private Foo.Bar bar = new Foo.Bar();<br/>}</pre><br/>invoke Move refactoring on Foo class and specify different target package (say, test2)<br/>Result: <code class=""inline-code"">Bar</code> references in Test class become inaccessible, but refactoring doesn&#39;t report any problems</div>
","0"
"IDEA-181007","IntelliJ IDEA","","Extracting varible inside try-with-resources","Oleg Estekhin","23/10/2017 04:45","05/02/2018 10:59",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Expanding <code class=""inline-code"">var</code> in the following<br/><pre class=""wikicode prettyprint"">try(someExpressionThatReturnsClosableOfTypeT().var)</pre><br/>results in<br/><pre class=""wikicode prettyprint"">T t = someExpressionThatReturnsClosableOfTypeT();<br/>try(t)</pre><br/>which is not valid (in Java 8).<br/><br/>The expansion should leave the new var declaratiuon inside try-with-resources:<br/><pre class=""wikicode prettyprint"">try(T t = someExpressionThatReturnsClosableOfTypeT())</pre></div>
","0"
"IDEA-79609","IntelliJ IDEA","","static member accessed via instance reference --> convert to instance method","Ron Gross","04/01/2012 08:02","01/02/2018 04:11",,"Normal","Feature",,"basleijdekkers","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When refactoring, I have found myself often accessing static methods via instance references.<br/><br/>I propose a new Alt-Enter action: Convert static method to instance method. I know this action is available through the refactor menu, but not as an Alt-Enter action.</div>
","0"
"IDEA-42255","IntelliJ IDEA","","Rename getter or setter in call place should offer rename field and setter also","Dmitry Krasilschikov","07/12/2007 13:21","30/01/2018 13:39",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Rename getter or setter in call place should offer rename field and setter also<br/><br/>class A {<br/>  String foo = &quot;&quot;;<br/><br/>public String getFoo(){}<br/>public void setFoo(){}<br/>}<br/>class B{<br/> void bar(){<br/>   A a = new A();<br/>  a.getFoo() // should propose rename field foo<br/>}<br/>}</div>
","4"
"IDEA-119225","IntelliJ IDEA","","Pull Up refactoring from multiple classes","Ingmar van Dijk","10/01/2014 06:33","30/01/2018 10:57",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In Eclipse I could do a pull-up of a method [M1] from one subclass [S1] and it would move (remove) the same method [M2] from another subclass [S2] too if that method was a duplicate.<br/><br/>Currently, IntelliJ proposes to replace the body of [M2] and it makes a call to super.M1<br/><br/>I would love to have [M2] be removed from [S2] completely.<br/><br/>Next to that, the RefactoringEventListeners would be notified with the target class and the methods that would be pulled up which include [M1] and [M2].</div>
","1"
"IDEA-185300","IntelliJ IDEA","reproduced","If a field is renamed to the (simple) name of a class, any static method calls need to be refactored","Dico Karssiens","21/01/2018 17:16","22/01/2018 02:52",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","this bug exists, but it is a VERY low priority to fix it. 

Consider the following classes in separate files:

```
package a;

public class TestClass1 {
    public static void someStaticMethod() {}
}
```

```
package b;

import a.TestClass1;

public class TestClass2 {
    private static final int someStaticField = 1;

    public TestClass2() {
        TestClass1.someStaticMethod();
    }
}
```

What steps will reproduce the issue?
1. Make the classes shown above
2. Rename the field ""someStaticField"" in TestClass2 to ""TestClass1""
3. Notice that the reference to ""TestClass1.someStaticMethod()"" in the constructor of TestClass2 breaks.

What is the expected result?
the reference to TestClass1.someStaticMethod() should be refactored to include the full name of the class, including the package.

What happens instead?
the reference is unchanged and breaks because of the name conflict.

IntelliJ IDEA 2017.3 (Ultimate Edition)
Build #IU-173.3727.127, built on November 27, 2017
Licensed to Dico Karssiens
Subscription is active until November 13, 2018
JRE: 1.8.0_152-release-1024-b6 amd64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Windows 10 10.0

","0"
"IDEA-184680","IntelliJ IDEA","","New refactoring: split method by boolean parameter","Tagir Valeev","08/01/2018 23:56","09/01/2018 00:01",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Staying on the boolean parameter of the method the refactoring could be suggested: &quot;Split method by boolean parameter value&quot;.<br/><br/>It should show a dialog window asking for two method names providing reasonable defaults. E.g. if original method name is &quot;add&quot; and boolean parameter name is &quot;ordered&quot;, the dialog could look like this:<br/><br/><pre class=""wikicode prettyprint"">+-------------------------------------------+<br/>| Specify new method names              [x] |<br/>+-------------------------------------------+<br/>| Method name for ordered = false           |<br/>| [ addNonOrdered________________________ ] |<br/>| Method name for ordered = true            |<br/>| [ addOrdered___________________________ ] |<br/>|                                           |<br/>|                      [ Split ] [ Cancel ] |<br/>+-------------------------------------------+</pre><br/>After submitting this dialog the following steps should be performed:<br/><br/><ul class=""wiki-list0""><li> Two new methods created, named as specified, parameters are the same as in the original method except the boolean parameter, return type and type parameters are the same, body is copied from the original method<br/></li><li> Every boolean parameter reference is replaced to <code class=""inline-code"">true</code> or <code class=""inline-code"">false</code> respectively<br/></li><li> DFA is performed on both methods body and always true/always false conditions are fixed automatically (this may look like magic, but usually result will be desired).<br/></li><li> Original method call-sites are investigated. If <code class=""inline-code"">true</code> or <code class=""inline-code"">false</code> literal is passed explicitly, then the call is replaced with corresponding true-method or false-method. Otherwise the call is replaced with <code class=""inline-code"">if(booleanArgumentValue) trueMethod(otherParams); else falseMethod(otherParams);</code> for expressions statements or <code class=""inline-code"">booleanArgumentValue ? trueMethod(otherParams) : falseMethod(otherParams)</code> for normal expression (probably automatically removing negation if applicable).<br/></li><li> Original method is deleted.<br/></li></ul></div>
","1"
"IDEA-180284","IntelliJ IDEA","reproduced","Java. IDEA unnecessarily adds the package name as prefix to object type, while there is a class with the package's name, too","Schoko Tets","09/10/2017 19:00","08/01/2018 13:15",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The title pretty much sums it up. For example, I&#39;ve got a package called &quot;Apple&quot;, containing a class called &quot;Apple&quot;:<br/><br/><span class=""monospace"">package Apple;<br/><br/>public class Apple {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public final static int pong = 2;<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>static {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println(new Apple());<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</span><br/><br/>If I put my cursor on <span class=""monospace"">new Apple()</span> and press Ctrl+Alt+V, it extracts it to a variable: <span class=""monospace"">Apple.Apple x = new Apple();</span><br/>Unnecessarily, IntelliJ IDEA adds <span class=""monospace"">Apple.</span> . If I were to do this in another class, it would be converted to the same text as above, but then it would throw an error and highlight the second <span class=""monospace"">Apple</span> red: <em>Cannot resolve symbol &#39;Apple&#39;</em>. That&#39;s because it thinks I meant a subclass of the <span class=""monospace"">Apple</span> class.</div>
","0"
"IDEABKL-7635","IntelliJ IDEA: Backlog","","Manually reorder methods in a separate dialog","Alexey Yumashin","15/12/2017 06:04","15/12/2017 06:43",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","It would be nice to be able to manually reorder methods in a separate dialog - similar to the ""Change signature"" dialog with ""Up"" and ""Down"" arrows. Also it would be convenient to have the following button in this dialog: ""Order as in base class/interface"" (disabled/invisible when no inheritance found).","0"
"IDEA-47152","IntelliJ IDEA","","Quickfixes like ""Make static"" should reformat aligned arguments in method argument list","Dmitry Jemerov","22/12/2008 10:06","03/12/2017 06:06",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Code before the fix:<br/><pre class=""wikicode prettyprint"">private HighlightUsagesHandlerBase createHighlightTryHandler(final Editor editor,<br/>                                                             final PsiFile file,<br/>                                                             final PsiElement target,<br/>                                                             final PsiElement parent) {<br/>   ...<br/>  }</pre><br/>Code after the fix:<br/><pre class=""wikicode prettyprint"">private static HighlightUsagesHandlerBase createHighlightTryHandler(final Editor editor,<br/>                                                             final PsiFile file,<br/>                                                             final PsiElement target,<br/>                                                             final PsiElement parent) {<br/>  ...<br/>}</pre><br/>Note that the parameters are no longer aligned. Alignment should be preserved if possible.</div>
","0"
"IDEA-132195","IntelliJ IDEA","","Inline refactoring may work with decompiled sources","Sergey Ignatov","31/10/2014 08:27","16/11/2017 14:35",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Will be cool to have such feature :)</div>
","0"
"IDEA-178132","IntelliJ IDEA","","Packages view: package copy copies the class(es) from the single root only","Irina Petrovskaya","28/08/2017 11:58","13/11/2017 04:07",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">173.1888<br/><br/>consider the project with few src roots and similar package structure in all that roots<br/>open the Packages view - the classes from the same-named packages in different roots are shown all together<br/>select any package (that exists in few roots) and Copy<br/>Paste anywhere - you are suggested to select the target root, choose one:<br/>as a result the package from the single root (first one) is copied only.</div>
","0"
"IDEA-142281","IntelliJ IDEA","reproduced","Annotation for local variable lost in inlining","Guno Heitman","04/07/2015 05:44","02/11/2017 07:16",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When inlining a local variable that has an annotation, the annotation is lost.<br/>IntelliJ should warn the user that the annotation will be lost after the refactoring operation. After all, this might change the semantics of the code.<br/><br/>How to reproduce:<br/><br/>Inline s in the following code fragment:<br/><pre class=""wikicode prettyprint"">    public String foo() {<br/><br/>        @MyAnnotation<br/>        String s = &quot;&quot;;<br/><br/>        return s + &quot;&quot;;<br/>    }</pre><br/>Result is:<br/><pre class=""wikicode prettyprint"">    public String foo() {<br/><br/>        return &quot;&quot; + &quot;&quot;;<br/>    }</pre></div>
","1"
"IDEA-181298","IntelliJ IDEA","","Move Method and extract Delegate: include submethods as well","Lukas Taake","27/10/2017 04:06","27/10/2017 07:23",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I move a method into an existing (via move method) or new class (via extract delegate), I want private methods only used by the<br/>selected method to be moved as well. This behaviour would make splitting up too large classes much more efficient.</div>
","0"
"IDEA-178412","IntelliJ IDEA","","New refactoring action: ""Split Parameter Object"" which would be the reverse ""Extract Parameter Object""","Réda Housni Alaoui","02/09/2017 08:26","25/10/2017 10:47",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><h1>Intro</h1><br/><strong>Extract Parameter Object</strong> is great when you have multiple parameters that you want to group under a meaningful Parameter Object.<br/><br/>But sometimes people abuse of this technique. <br/>Some methods end up requiring <strong>huge meaningless parameter objects</strong> despite they use only one or two attributes among dozens.<br/><br/>It would be great for this kind of cases to have an opposite refactoring action.<br/><br/><h1>Example</h1><br/><div class=""java code title"">Parameter Object</div><pre class=""wikicode prettyprint"">public class HugeParameterObject {<br/>  public String attr1;<br/>  public String attr2;<br/>  public String attr3;<br/>  public String attr4;<br/>  public String attr5;<br/>}</pre><br/><div class=""java code title"">The callee and caller before auto refactoring</div><pre class=""wikicode prettyprint"">public void doSomething(HugeParameterObject payload){<br/>  System.out.println(&quot;I only use &quot; + payload.attr1 + &quot; and &quot; + payload.attr2 +&quot;. I don&#39;t care about the rest !&quot;);<br/>}<br/>HugeParameterObject payload = new HugeParameterObject();<br/>payload.attr1 = &quot;hello&quot;;<br/>payload.attr2 = &quot;world&quot;;<br/>payload.attr3 = &quot;used?&quot;;<br/>payload.attr4 = &quot;used?&quot;;<br/>payload.attr5 = &quot;used?&quot;;<br/>doSomething(payload);</pre><br/><div class=""java code title"">The callee and caller after auto refactoring</div><pre class=""wikicode prettyprint"">public void doSomething(String attr1, String attr2){<br/>  System.out.println(&quot;I only use &quot; + attr1 + &quot; and &quot; + attr2 +&quot;. I don&#39;t care about the rest !&quot;);<br/>}<br/>HugeParameterObject payload = new HugeParameterObject();<br/>payload.attr1 = &quot;hello&quot;;<br/>payload.attr2 = &quot;world&quot;;<br/>payload.attr3 = &quot;used?&quot;;<br/>payload.attr4 = &quot;used?&quot;;<br/>payload.attr5 = &quot;used?&quot;;<br/>doSomething(payload.attr1, payload.attr2);</pre></div>
","0"
"IDEA-177869","IntelliJ IDEA","","Refactoring with find crashing bottom tool windows (ShowFilePathAction is not working)","Al-Mothafar Al-Hasan","22/08/2017 04:36","19/10/2017 12:14",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;ll add example might be helpful for reproduce it, I was trying to do some refactoring for his enum:<br/><br/><pre class=""wikicode prettyprint"">package controllers.general;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/><br/>public enum ContactUsCategoryVO {<br/>    @JsonProperty(&quot;Billing&quot;)<br/>    BILLING(&quot;billing&quot;),<br/>    @JsonProperty(&quot;Service&quot;)<br/>    SERVICE(&quot;service&quot;);<br/><br/>    private String type;<br/><br/>    private ContactUsCategoryVO(String type) {<br/>        this.type = type;<br/>    }<br/><br/>    public String getType() {<br/>        return type;<br/>    }<br/><br/>    public ContactUsCategoryVO setType(String type) {<br/>        this.type = type;<br/>        return this;<br/>    }<br/>}</pre><br/>Then tried to rename &quot;type&quot; to something else using Refactor -&gt; Rename or &quot;Shift+F6&quot;, when I tried to rename asked me to rename setters and getters, said yes, then showed me window to refactor parameters, and selected it, once I click OK it is just not applied changes, the Find window showed but the window itself stayed hidden, and I can&#39;t re-open it or any of bottom windows, I need to restart IDE to see the others windows.<br/><br/>For sure you have to use this class in other classes, I think this is why I have to see the refactor effect before apply.<br/><br/><pre class=""wikicode prettyprint"">2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - Outdated stub in index: jar://C:/Users/almothafar/.ivy2/cache/org.springframework/spring-beans/srcs/spring-beans-4.3.9.RELEASE-sources.jar!/org/springframework/beans/factory/annotation/Qualifier.java null, doc=null, docSaved=true, wasIndexedAlready=true, queried at 1496865582000<br/>        2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - IntelliJ IDEA 2017.2.2  Build #IU-172.3757.52<br/>        2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - JDK: 1.8.0_152-release<br/>        2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - VM: OpenJDK 64-Bit Server VM<br/>        2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - Vendor: JetBrains s.r.o<br/>        2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - OS: Windows 10<br/>        2017-08-22 10:24:20,761 [518850318]  ERROR - j.psi.stubs.StubTreeLoaderImpl - Last Action: EditorPaste<br/>        2017-08-22 10:26:28,917 [518978474]   INFO - ide.actions.ShowFilePathAction -<br/>        Exit code 1</pre><br/>Tried again and got:<br/><pre class=""wikicode prettyprint"">2017-08-22 10:29:18,329 [519147886]   INFO - .script.IdeScriptEngineManager - javax.script.ScriptEngineManager initialized in 4045 ms <br/>2017-08-22 10:31:29,229 [519278786]   INFO - ide.actions.ShowFilePathAction - <br/>Exit code 1 </pre></div>
","0"
"IDEA-180397","IntelliJ IDEA","","extract from a string should use character literals wherever applicable","Nikolay Metchev","11/10/2017 06:44","11/10/2017 07:09",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Extracting the extractme string below leaves two single character strings. It would be good if it changed those to character literals<br/><br/>Before:<br/><pre class=""wikicode prettyprint"">public class Test2 {<br/>  void m() {<br/>    System.out.println(&quot;(extractme)&quot;);<br/>  }<br/>}</pre><br/>After:<br/><pre class=""wikicode prettyprint"">public class Test2 {<br/>  void m() {<br/>    String extractme = &quot;extractme&quot;;<br/>    System.out.println(&quot;(&quot; + extractme + &quot;)&quot;);<br/>  }<br/>}</pre><br/>Expected:<br/><pre class=""wikicode prettyprint"">public class Test2 {<br/>  void m() {<br/>    String extractme = &quot;extractme&quot;;<br/>    System.out.println(&#39;(&#39; + extractme + &#39;)&#39;);<br/>  }<br/>}</pre>IC-173.2941.3, JRE 1.8.0_152-release-1008-b1x64 JetBrains s.r.o, OS Windows 10(amd64) v10.0 , screens 2560x1600, 1280x1024</div>
","0"
"IDEABKL-7614","IntelliJ IDEA: Backlog","","Rename refactoring: perform search ahead","Sergey Rostov","10/09/2017 07:36","29/09/2017 14:45",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">In most cases, the search time is less than the time for which the user enters a new name.<br/><br/>It would be cool if Idea perform search right after start editing name.<br/>When user finish editing the name, Idea should show already found results (if search complete).</div>
","0"
"IDEA-179264","IntelliJ IDEA","","Refactor Extract Delegate of method with getter but not setter fails","James Morgan","19/09/2017 14:44","19/09/2017 15:01",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When extracting a method to a delegate (with generate accessors checked on), if the method to extract contains a non-public local field reference and a getter method exists but no setter method exists, the refactoring completes but leaves the extracted class in an invalid state since it assumed the necessary setter already exists.<br/><br/>The error is because the inner class com.intellij.refactoring.extractclass.ExtractClassProcessor.NecessaryAccessorsVisitor has an error in the visitAssignmentExpression method.  The inner most if-conditional begins with: <code class=""inline-code"">if (!hasGetter(field)...)</code>; this should be: <code class=""inline-code"">if (!hasSetter(field)...)</code>.<br/><br/>Attached is a tar file that contains before and after test data (<span class=""monospace"">testData/refactoring/extractClass/getterNoSetter</span>) to be used in the test <span class=""monospace"">testSrc/com/intellij/java/refactoring/ExtractClassTest</span> after adding the following method:<br/><pre class=""wikicode prettyprint"">public void testGetterNoSetter() throws Exception {<br/>   doTestMethod();<br/>}</pre>The test will currently fail because the necessary setter method will not be generated in <span class=""monospace"">after/Test.java</span>.</div>
","0"
"IDEA-178451","IntelliJ IDEA","reproduced","""Extract constant"" with ""Replace all occurrences"" only replaces first in line","Carsten  Otto","04/09/2017 09:01","04/09/2017 09:24",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have the following String:<br/><pre class=""wikicode prettyprint"">String x = &quot;......\n..OO..\n.O..O.\n..OO..\n......\n&quot;;</pre><br/>Extracting a constant <code class=""inline-code"">EMPTY_6</code> out of <code class=""inline-code"">&quot;......\n&quot;</code> gives the following String, although I checked &quot;Replace all occurrences&quot;:<br/><pre class=""wikicode prettyprint"">String x = EMPTY_6 + &quot;..OO..\n.O..O.\n..OO..\n......\n&quot;;</pre><br/>I expect:<br/><pre class=""wikicode prettyprint"">String x = EMPTY_6 + &quot;..OO..\n.O..O.\n..OO..\n&quot; + EMPTY_6;</pre><br/>IntelliJ IDEA 2017.2.3<br/>Build #IU-172.3968.16, built on August 21, 2017<br/>Licensed to Carsten Otto<br/>Subscription is active until March 15, 2018<br/>JRE: 1.8.0_152-release-915-b11 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 7 6.1</div>
","0"
"IDEA-178411","IntelliJ IDEA","","""Select Methods To Propagate Static"": No shortcut to check multiple checkboxes","Réda Housni Alaoui","02/09/2017 08:06","04/09/2017 05:14",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am refactoring a huge project.<br/>When the <strong>Select Methods To Propagate Static</strong> prompt is shown, there is often more than a hundred checkboxes.<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/>It seems that we have to check each one individually. <br/><br/>There is no shortcut to select them all or multiple of them :/</div>
","0"
"IDEA-52801","IntelliJ IDEA","","""Select Methods to Propagate New Exceptions dialog needs improvement","Anders Wallgren","11/03/2010 01:15","01/09/2017 04:18",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><ul class=""wiki-list0""><li> Sort the methods<br/></li><li> Suppress duplicate instance of methods<br/></li><li> Allow multi-select and select/deselect all<br/></li></ul></div>
","2"
"IDEA-177860","IntelliJ IDEA","","Extract Delegate expands diamond operator regardless project java version","Aleš Holý","21/08/2017 16:35","22/08/2017 12:38",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The refactoring tool Extract -&gt; Delegate correctly creates a new class with selected members, with a cosmetic issue though. The transferred code does not use the diamond operator even if it was used in the original code. The explicit generic types are then immediately underlined by code inspector.</div>
","0"
"IDEA-177816","IntelliJ IDEA","reply needed","Inline var should be smart enough to still work (when a local-var has not been defined)","Paul Hammant","20/08/2017 10:31","22/08/2017 07:26",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>^ option-command-n should forgive that I have no definition for txn and go ahead and complete the inline of the var. At least if <code class=""inline-code"">txn</code> is unique within scope: one def and one use.</div>
","0"
"IDEA-176401","IntelliJ IDEA","","UI Not responding after ""Extract variable"" action","Gaël Nieutin","21/07/2017 12:26","17/08/2017 11:03",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Trying to extract a plain string &quot;.&quot; contained in a method body into a variable made the whole UI freeze (all opened project).<br/>Some assertion failed inside inteeliJ (see idea.log part attached)</div>
","0"
"IDEA-177049","IntelliJ IDEA","reproduced","'Extract Field' adds 'final' even when assignment is under condition","Andrey Turbanov","02/08/2017 16:16","02/08/2017 16:55",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class NewField {<br/>    public NewField() {<br/>        if (Boolean.getBoolean(&quot;123&quot;)) {<br/>            Integer a&lt;caret&gt; = Integer.getInteger(&quot;321&quot;);<br/>        }<br/>    }<br/>}</pre><br/>Invoke &#39;Introduce field&#39;<br/><strong>Expected</strong><br/><pre class=""wikicode prettyprint"">private Integer a;</pre><strong>Actual</strong><br/><pre class=""wikicode prettyprint"">private final Integer a;</pre></div>
","0"
"IDEA-176646","IntelliJ IDEA","","Suggest spelling correction when renaming a symbol","Dmitry Cherniachenko","26/07/2017 09:42","26/07/2017 10:40",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If some symbol has a spelling error (e.g. &quot;enviroment&quot;) it would be convenient to have the proper spelling (&quot;environment&quot;) among the suggestions when launching Refactor | Rename.<br/><br/>There is &quot;Typo: Rename to...&quot; intention. But when I see a typo it&#39;s more natural for me to press Shift+F6 rather than call intentions (Alt+Enter) and look through the list to find the one that would fix the mistake.<br/>Moreover, the intention does not appear immediately. If I call intentions when the typo is already underlined in the editor I could still get the list without &quot;Typo: Rename to...&quot;.<br/><br/>The list in the Rename should probably include only corrections with the minimal distance.<br/>I.e. I would not expect &quot;enlistment&quot; to be suggested when renaming &quot;enviroment&quot;, unlike in &quot;Typo: Rename to...&quot;.</div>
","0"
"IDEA-176459","IntelliJ IDEA","reproduced","Bug Extrack Expression","Ivan","23/07/2017 08:56","25/07/2017 08:10",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Example:<br/><div class=""java code title"">Code</div><pre class=""wikicode lang-scala prettyprint"">        String s = &quot;123&quot;;<br/>        s.split(&quot;2&quot;);<br/>        System.err.println(s.split(&quot;2&quot;));</pre>Need extract &quot;s.split(&quot;2&quot;)&quot;<br/><br/>Expected result:<br/>???<br/><br/>Actual result:<br/><div class=""java code title"">Code</div><pre class=""wikicode lang-scala prettyprint"">        String s = &quot;123&quot;;<br/>        String[] split = s.split(&quot;2&quot;);<br/>        split;<br/>        System.err.println(split);</pre><br/>IntelliJ IDEA 2017.2<br/>Build #IC-172.3317.76, built on July 15, 2017<br/>JRE: 1.8.0_152-release-915-b5 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 10 10.0</div>
","0"
"IDEA-175843","IntelliJ IDEA","reproduced","Visibility is not escalated fully","Dmitry Cherniachenko","13/07/2017 13:09","13/07/2017 13:13",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Start with a class like this<br/><pre class=""wikicode prettyprint"">public class Demo<br/>{<br/>    private static class Data {<br/>        private String seed;<br/>    }<br/><br/>    private static Data getData() {<br/>        return new Data();<br/>    }<br/><br/>    public static String generateId() {<br/>        Data data = getData();<br/>        return data.seed;<br/>    }<br/>}</pre><br/>Now move <code class=""inline-code"">getData()</code> and <code class=""inline-code"">Data</code> to a new class in the same package - <code class=""inline-code"">DataUtil</code>. Make sure the option &quot;Escalate&quot; is selected for &quot;Visibility&quot;.<br/>IDEA will create a new class:<br/><pre class=""wikicode prettyprint"">public class DataUtil<br/>{<br/>    static Data getData() {<br/>        return new Data();<br/>    }<br/><br/><br/>    static class Data {<br/>        private String seed;<br/>    }<br/>}</pre><br/>But the <code class=""inline-code"">generateId()</code> method now has a compilation error because <code class=""inline-code"">seed</code> field visibility has not been escalated.</div>
","0"
"IDEA-175239","IntelliJ IDEA","","Refactor rename doesn't rename builder pattern with.. methods","ren hoek","30/06/2017 13:58","02/07/2017 04:21",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In case of renaming a field which value is assigned by a with... method, the rename doesn&#39;t affect the with.. method.<br/>The refactor should work the same with builders as it works with setters.</div>
","0"
"IDEA-174851","IntelliJ IDEA","","Inline single element enum","Сергей Цыпанов","22/06/2017 08:56","30/06/2017 05:39",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Say you have the following function<br/><pre class=""wikicode prettyprint"">public enum HasIdToIdFunc implements java.util.Function&lt;HasId&lt;Long&gt;, Long&gt; {<br/>    INST;<br/><br/>    @Override<br/>    @Nonnull<br/>    public Long apply(HasId&lt;Long&gt; hasId) {<br/>        return hasId.getId();<br/>    }<br/>}</pre><br/>IDEA should detect such classes and provide simplifying action like<br/><br/><pre class=""wikicode prettyprint"">hasIds.stream().map(HasIdToIdFunc.INST).collect(toList());</pre>turned into<br/><pre class=""wikicode prettyprint"">hasIds.stream().map(HasId::getId).collect(toList());</pre></div>
","0"
"IDEA-174960","IntelliJ IDEA","reply needed","Rename class does not correctly apply whitespace reformatting (indents) to wrapped constructor arguments","Kevin Connor Arpe","25/06/2017 01:30","26/06/2017 05:41",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">IntelliJ IDEA 2017.2 EAP<br/>Build #IU-172.3095.12, built on June 21, 2017<br/>IntelliJ IDEA EAP User<br/>Expiration date: July 21, 2017<br/>JRE: 1.8.0_152-release-915-b3 amd64<br/>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o<br/>Windows 7 6.1<br/><br/>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/><br/>Notice both constructor args are wrapped.  In the Real World, I wrap constructor args when class name is super long <strong>and</strong> constructor arg names are super long.  (I limit my code to 120 chars wide.)<br/><br/><pre class=""wikicode prettyprint"">    public final class X {<br/><br/>        public X(final int<br/>                     abc,<br/>                 final int<br/>                     def) {<br/>        }<br/>    }</pre><br/>Now, rename <strong>X</strong> to <strong>XYZ</strong> (Ctrl+F6).  Notice ctor args <strong>abs</strong> and <strong>def</strong> are /not/ reformatted correctly, but ctor arg types are correctly reformatted.  I expect two additional spaces added to indent for <strong>abc</strong> and <strong>def</strong>.<br/><br/><pre class=""wikicode prettyprint"">    public final class XYZ {<br/><br/>        public XYZ(final int<br/>                     abc,<br/>                   final int<br/>                     def) {<br/>        }<br/>    }</pre></div>
","0"
"IDEA-174874","IntelliJ IDEA","","Add a Command-N feature to automatically override builder-style setters for sub-classes","Shahin Amini","22/06/2017 12:09","22/06/2017 12:13",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><h1>Builder-style setters and inheritance</h1><br/>IntelliJ IDEA&#39;a feature to generate builder-style setters for classes. As in this example:<br/><br/><pre class=""wikicode prettyprint"">public class Parent {<br/>    private int value;<br/><br/>    public Parent() { }<br/><br/>    public Parent setValue(int value) {<br/>        this.value = value;<br/>        return this;<br/>    }<br/>}</pre><br/>The obvious problem with builder-style setters is they do not work with inheritance &quot;as is&quot;. So they need to be overriden, as in this example:<br/><br/><pre class=""wikicode prettyprint"">public class Child extends Parent {<br/>    public Child() { }<br/><br/>    @Override<br/>    public Child setValue(int value) {<br/>        super.setValue(value);<br/>        return this;<br/>    }<br/>}</pre><br/>Now this overriding is trivial and uniform, and since builder-style setters are automatically generated by IDEA, it is only logic <strong>to have a feature that generates the overriding setters</strong>.</div>
","0"
"IDEA-92818","IntelliJ IDEA","","'Introduce parameter' on an unresolved ref should invoke 'Create parameter from reference' fix","Maksim Medvedev","11/10/2012 14:53","09/06/2017 15:50",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown",,"1"
"IDEA-173994","IntelliJ IDEA","","Improve Add constructor parameter wizard logic","Mikhail Kopylov","06/06/2017 08:49","06/06/2017 10:46",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Assume a case:<br/><pre class=""wikicode prettyprint"">public class Dependency {}<br/><br/>public class A {}<br/><br/>public class B extends A{}</pre><br/>We use constructor dependency injecting, and want to add dependency to A. Simply add <br/><pre class=""wikicode prettyprint"">public class A {<br/>  private final Dependency dependency;<br/>}</pre><br/>IDEA suggests to add constructor parameter. After adding it becomes:<br/><br/><pre class=""wikicode prettyprint"">public class A {<br/>    private final Dependency dependency;<br/><br/>    public A( Dependency dependency ) {<br/>        this.dependency = dependency;<br/>    }<br/>}<br/><br/>public class B extends A {<br/>    public B() { //Dependency isn&#39;t injected here<br/>        super( dependency ); //dependency isn&#39;t defined yet, I have to add constructor parameter manually.<br/>    }<br/>}</pre><br/>The point is to add dependency to constructor parameters to all successor classes automatically or with user&#39;s help.</div>
","0"
"IDEA-173451","IntelliJ IDEA","","Replace occurrence when removing elements from list","Adrian Skrobacz","25/05/2017 11:37","25/05/2017 13:52",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Having piece of code like this:<br/><code class=""inline-code"">list.get(0).setSomething(value);<br/>list.remove(0);<br/>list.get(0).setSomething(value);<br/>list.remove(0);</code><br/><br/>When you highlight first <code class=""inline-code"">list.get(0)</code> and press ctrl+alt+v to extract variable it will replace both <code class=""inline-code"">list.get(0)</code> to one variable, resulting in:<br/><code class=""inline-code"">Element elem= list.get(0);<br/>elem.setItineraryGroup(currentGroupNumber);<br/>list.remove(0);<br/>elem.setItineraryGroup(currentGroupNumber);<br/>list.remove(0);</code><br/><br/>What obviously changes code since we have reference to the same element in <code class=""inline-code"">elem</code> variable. Valid code replacement would be:<br/><code class=""inline-code"">Element elem = list.get(0);<br/>elem.setItineraryGroup(currentGroupNumber);<br/>list.remove(0);<br/>elem = list.get(0);<br/>elem.setItineraryGroup(currentGroupNumber);<br/>list.remove(0);</code><br/><br/>Since you can always select to replace only one occurence it&#39;s more like a feature to make it more inteligent than a bug.</div>
","0"
"IDEA-173112","IntelliJ IDEA","reproduced","Find duplicates not working for single class","Anton","18/05/2017 12:28","19/05/2017 04:31",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Tryed to run <strong>Refactor | Find and Replace Code Duplicates</strong><br/>on this class:<br/><br/><div><details class=""wiki-details""><summary class=""wiki-cut-title"">Test.class</summary><pre class=""wikicode prettyprint"">public class Test {<br/>    public static void main(String[] args) {<br/>        {<br/>            int a = 1;<br/>            int b = 2;<br/>            <br/>            System.out.println(a + b);<br/>        }<br/>        {<br/>            int a = 1;<br/>            int b = 2;<br/><br/>            System.out.println(a + b);<br/>        }<br/>        {<br/>            int a = 1;<br/>            int b = 2;<br/><br/>            System.out.println(a + b);<br/>        }<br/>        {<br/>            int a = 1;<br/>            int b = 2;<br/><br/>            System.out.println(a + b);<br/>        }<br/>    }<br/>    <br/>    private int add1(int a, int b) {<br/>        a = a * 3;<br/>        b = b - 2;<br/>        <br/>        return a + b;<br/>    }<br/><br/>    private int add2(int a, int b) {<br/>        a = a * 3;<br/>        b = b - 2;<br/>        <br/>        return a + b;<br/>    }<br/>}</pre></details></div><br/><br/>Time to time different behaviour...<br/><br/>1.  When right click outside of function:<br/><br/><div class=""wiki picture""><img src=""[](error.png)""/></div><br/>Why such restriction exists?<br/><br/>2.  Sometimes IDEA see duplicates only for <strong>a+b</strong> in this System.out.println(a + b);<br/><br/>3.  And in most cases nothing showed up</div>
","0"
"IDEA-157417","IntelliJ IDEA","reproduced","""Replace with method reference"" leaves cast (not redundant? though)","Lyubomyr Shaydariv","13/06/2016 06:34","02/05/2017 05:00",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Hi,<br/>please consider the following code:<br/><pre class=""wikicode prettyprint"">final Collection&lt;? extends ConstraintViolation&lt;?&gt;&gt; violations = ...;<br/>...<br/>violations<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>.stream()<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>.collect(toImmutableMap(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>new Function&lt;ConstraintViolation&lt;?&gt;, Object&gt;() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>@Override<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public Object apply(final ConstraintViolation&lt;?&gt; v) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return v.getPropertyPath();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>},<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>new Function&lt;ConstraintViolation&lt;?&gt;, Object&gt;() {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>@Override<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>public Object apply(final ConstraintViolation&lt;?&gt; v) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return v.getMessage();<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>));</pre>In the code above two functional interface anonymous classes can be replaced with method references. However, refactoring the anonymous class instances into method references is as follows:<br/><pre class=""wikicode prettyprint"">violations<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>.stream()<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>.collect(toImmutableMap(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>(Function&lt;ConstraintViolation&lt;?&gt;, Object&gt;) ConstraintViolation::getPropertyPath,<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>(Function&lt;ConstraintViolation&lt;?&gt;, Object&gt;) ConstraintViolation::getMessage<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>));</pre><br/>ideally, I would expect a shorter form, without explicit type casting:<br/><pre class=""wikicode prettyprint"">violations<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>.stream()<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>.collect(toImmutableMap(<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>ConstraintViolation::getPropertyPath,<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>ConstraintViolation::getMessage<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>));</pre></div>
","0"
"IDEA-171995","IntelliJ IDEA","","refactor duplicate method to best possible module","Pascal Knueppel","26/04/2017 06:29","26/04/2017 17:35",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Hi,<br/><br/>I am currently refactoring a project containing 29 modules. I found that 3 of these modules declared the same static method using the same dependencies that does nothing else but to lookup a declaration in the server configuration. Id like to put this method into a single method in a way that all modules will have access to this method. To do this it would be great to have a way to let IntelliJ show me an overview of modules that all of theses modules share.<br/><br/>for example:<br/>module A, B and C define the same method. If lucky than all of these modules depend on module D where the method can safely be placed. <br/>Or maybe C and C depend on A. It might be also a nice feature if IntelliJ does directly suggest a module if this is possible.<br/><br/>On the other hand would it be nice to have a better overview of dependencies. As an example (I use maven) In some cases you can see in the dependency overview that some dependencies have been omitted  because of duplicates. It would be great if it were possible to select the duplicate dependency directly. I already had some cases where I needed to exclude the dependencies that were taken over the omitted ones. So a text-search field for the dependency tree could be a huge help too.</div>
","0"
"IDEA-171422","IntelliJ IDEA","","On-demand imports referring to old package name are not removed after package rename","Alexey Sedunov","13/04/2017 10:07","13/04/2017 10:15",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider file &#39;J.java&#39; in package a.b:<br/><pre class=""wikicode prettyprint"">package a.b;<br/><br/>import c.d.*;<br/><br/>public class J {<br/>    K k = new K();<br/>}</pre>and &#39;K.java&#39; in package c.d:<br/><pre class=""wikicode prettyprint"">package c.d;<br/><br/>public class K {<br/>}</pre><br/>Invoke rename on package c.d, proceed with &quot;Rename package&quot;, change package name to x.y, Ok to go<br/>Result (J.java):<br/><pre class=""wikicode prettyprint"">package a.b;<br/><br/>import c.d.*; // &lt;- UNRESOLVED REFERENCE<br/>import x.y.K;<br/><br/>public class J {<br/>    K k = new K();<br/>}</pre></div>
","0"
"IDEA-171406","IntelliJ IDEA","","Cross-Project Refactoring","Christian Schneider","13/04/2017 06:20","13/04/2017 06:30",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Having opened a library/dependency as a separate project in IDEA is the common practice. Unfortunately this does not allow to refactor depending projects along with the library/dependency.<br/><br/>So if I e.g. rename a method in the library in IDEA project A, I would expect to have method usages in project B updated as well (if project B is opened as well).<br/><br/>Instead project B is not modified at all.<br/><br/><a href=""/issue/IDEA-65293"" target=""_self"" data-issue-id=""25-234264"" title=""View multiple IntelliJ IDEA projects in a single frame"">IDEA-65293</a> would be a workaround but not as convenient as regarding projects opened in other windows.</div>
","0"
"IDEA-171103","IntelliJ IDEA","reproduced","""Make class implement interface"" quickfix for generic class generates invalid code; should prompt to select the type parameter","Igor Baltiyskiy","06/04/2017 18:27","07/04/2017 04:11",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><div class=""java code title"">Before</div><pre class=""wikicode prettyprint"">interface I&lt;T&gt; {<br/>  void f(T t);<br/>}<br/><br/>class C {}<br/><br/>class X {<br/>  &lt;T&gt; void h(I&lt;T&gt; i) {<br/><br/>  }<br/><br/>  &lt;T&gt; void g() {<br/>    h(new C()); // Error: I&lt;T&gt; in X cannot be applied to C<br/>  }<br/>}</pre><br/>After applying the quickfix on <code class=""inline-code"">new C()</code> and choosing methods to implement, class C becomes:<br/><br/><div class=""java code title"">After</div><pre class=""wikicode prettyprint"">class C implements I&lt;T&gt; {<br/>  @Override<br/>  public void f(T t) {<br/>    <br/>  }<br/>}</pre><br/>I&#39;d expect IDEA to display a prompt in place of T, so that the developer can choose the appropriate type. Otherwise, if there are many methods, it&#39;s a pain to fix. Otherwise, one has to remember to not choose any methods to implement, type in the proper type, and then implement, but that disrupts workflow. <br/><br/>Note that it&#39;s what I originally intended in <a href=""/issue/IDEA-82093"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-387639"" title=""&quot;Make class implement interface&quot; quickfix for class with bounded type parameters generates invalid code; should prompt to select the type parameter"">IDEA-82093</a>, but it seems that the fix was to simply substitute <code class=""inline-code"">Integer</code> in the case described there.</div>
","0"
"IDEA-170848","IntelliJ IDEA","","F5 is always ""Copy class"" for .java file (no access to ""Copy file"")","Dmitry Cherniachenko","03/04/2017 06:42","03/04/2017 07:31",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When the caret is on the class name or inside the class both F5 and F6 trigger &quot;class&quot; actions (&quot;Copy class&quot; and &quot;Move class&quot; respectively).<br/>However when the caret is outside of the class F6 triggers &quot;Move file&quot; while F5 still executes &quot;Copy class&quot;.<br/><br/>It would be convenient to have easy access to &quot;Copy file&quot;, similarly to &quot;Move file&quot;.<br/><br/>P.S. I needed to copy a file to non-source directory - &quot;Copy class&quot; wouldn&#39;t work.</div>
","0"
"IDEABKL-7541","IntelliJ IDEA: Backlog","","Refactor / Move: ""Show Conflicts in View"" shows only one conflict of several existing","Alexander Chernikov","23/03/2017 13:58","28/03/2017 12:10",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Provide a package local Java class:<br/><code class=""inline-code"">class PackageLocal {}</code><br/>And <strong>more than one</strong> class using it. Tested the same usage code:<br/><pre class=""wikicode prettyprint"">public class RefOne {<br/>    public void refer() {<br/>        Object v = new PackageLocal();<br/>    }<br/>} </pre><br/>Focus on <code class=""inline-code"">PackageLocal</code>, Refactor / Move (F6), specify different package, Ok to go.<br/>Get Problems Detected dialog showing all usages: correct.<br/>Press Show Conflicts in View. Get Find window with only one usage. That&#39;s the issue.<br/><br/>NB: on commenting shown usage and re-try the next usage is shown: better than nothing.<br/>NB: tested in presence of Kotlin plugin, hope it does not affect the behavior.<br/>IDEA 171.4011.</div>
","0"
"IDEA-150533","IntelliJ IDEA","reproduced","Refactor / Move: ""Move everything to another directory"" removes full name qualification from references in comments and string literals","Alexander Chernikov","17/01/2016 15:53","23/03/2017 14:35",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Provide the following packages and Java source files:<br/><div class=""java code title"">first/MovingJava.java</div><pre class=""wikicode prettyprint"">package first;<br/>public class MovingJava {} </pre><div class=""java code title"">second/FqnReferrerJava</div><pre class=""wikicode prettyprint"">package second;<br/>public class FqnReferrerJava {<br/>    // first.MovingJava<br/>    private String f = &quot;first.MovingJava&quot;;<br/>} </pre>Move the package <code class=""inline-code"">first</code> to one more package <code class=""inline-code"">third</code>. (Tested drag-and-drop in Project tree.)<br/>Get choice dialog: &quot;Move package&quot; or &quot;Move everything to another directory.&quot;<br/>Select &quot;Move package&quot;, answer Ok-Ok on all questions, check the result: all FQN references are updated.<br/>Ok, Undo Move.<br/><br/>Repeat Move, select &quot;Move everything&quot;.<br/>Get no more questions, and resulted references are no more fully qualified:<br/><pre class=""wikicode prettyprint"">...<br/>    // MovingJava<br/>    private String f = &quot;MovingJava&quot;;<br/>... </pre><br/>NB: references in code, e.g. import statements _are_ updated in both scenarios.<br/>IDEA 143.1901.</div>
","0"
"IDEA-169932","IntelliJ IDEA","","Undo / Redo: button tooltip text could be changed for actions that reference the class/file name","Irina Petrovskaya","20/03/2017 13:32","21/03/2017 07:42",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">171.3780.95<br/><br/>for example if the last action for which Undo is available is the class Delete, the tooltip displayed when ypu point to Undo button displays the text like &#39;Undo deleting class &lt;some part of class fqn starting from top&gt;&#39;, like &#39;Undo deleting class com.mytests.spr&#39; for class &#39;com.mytests.spring.springJPA.projections.services.FooService&#39; that has been deleted.<br/>It would be better to display the class short name in the tooltip.<br/>Same - for class rename etc<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>Similar situation - with the files: file deleting action is displayed with the file short name, but file creation Undo tooltip displays the part of the full file path starting from C:/ :<br/><div class=""wiki picture""><img src=""[](image2.png)""/></div></div>
","0"
"IDEA-169884","IntelliJ IDEA","","Paste type and name in one go in ""Change signature"" parameter editor","Dmitry Cherniachenko","20/03/2017 06:00","20/03/2017 17:07",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">To save some typing I often copy the type + name string to clipboard before opening the &quot;Change signature&quot; dialog: <code class=""inline-code"">Map&lt;String, Object&gt; values</code>.<br/><br/>It would be nice if new parameter edit fields recognized this format and split the text automatically.<br/>Then one could paste both type and name with one Ctrl+V press.</div>
","0"
"IDEA-81203","IntelliJ IDEA","","Extract Superclass for several classes simulteanously","Julien Cohen","10/02/2012 12:29","15/03/2017 09:03",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I would need that Extract Superclass would apply to several classes simulteanously.<br/><br/><br/>For instance, if I have the following two classes A and B:<br/>class A { int m (){...} }<br/>class B { int m (){...} }<br/><br/>I would like to get:<br/>abstract class S { int m ();}<br/>class A extends S { int m (){...} } <br/>class B extends S { int m (){...} }<br/><br/>(maybe with additional @Override annotations).<br/><br/>Currently, I could only get:<br/>abstract class S { int m ();}<br/>class A extends S { int m (){...} }<br/>class B { int m (){...} }<br/><br/>and I found no easy way to add S as a superclass of B (unless typing &quot;extends...&quot; myself which is error prone).<br/><br/>Ok, you need also to extend the UI of the operation to select which set of class you want to consider. See Eclipse for an example of UI that does that.<br/><br/>Additionally, I would be interested for Extract Interface for multiple classes also :-)<br/><br/>Julien.</div>
","3"
"IDEA-169264","IntelliJ IDEA","","""Replace Constructor with Builder"" refactoring for Java should also replace constructor in Java code.","Fotios Lioutsis","07/03/2017 09:43","07/03/2017 13:00",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently to use &quot;Replace Constructor with Builder&quot; refactoring in a Java bean I am forced to explicitly create a constructor first and then use this refactoring method. When the builder is created it uses the constructor in its create method instead of replacing it and using setters to build the Java bean object. <br/>I would like to have the option to replace the constructor completely, it would be also better if I don&#39;t have to manually create a constructor first. <br/><br/>There was a plugin providing this functionality (<a href=""https://github.com/mjedynak/builder-generator-idea-plugin"" target=""_blank"" rel=""noopener noreferrer"">https://github.com/mjedynak/builder-generator-idea-plugin</a>) but is no longer working in affected version (2016.3.4).</div>
","0"
"IDEA-168425","IntelliJ IDEA","","The emergence of excessive string variable during the action ""Extract to variable""","Viktor Alenkov","18/02/2017 06:28","02/03/2017 14:31",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The video shows a repeating sequence of &quot;Ctrl+Shift+V&quot; and Esc<br/><br/><div><details class=""wiki-details""><summary class=""wiki-cut-title"">russian text</summary>Появление избыточной строки с переменной во время действия &quot;Extract to variable&quot;<br/><br/>На видео показана повторяющаяся последовательность действий из &quot;Ctrl+Shift+V&quot; и Esc</details></div></div>
","0"
"IDEA-106419","IntelliJ IDEA","","Rename refactoring should warn if there are too many non-code usages","Dimitri Trofim","29/04/2013 11:52","02/03/2017 11:25",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Normally I like to see non-code usages when I perform rename refactoring, but sometimes when I rename a field named &#39;myData&#39; the refactoring hangs for a 5-10 minutes and I can&#39;t work with IDEA till it finds that I have 7545 non-code usages. I don&#39;t know what to do with more then 7000 usages so I don&#39;t read them and exclude all. Thats why I think it would be better for me if IDEA said in the very beginning that the number of out-of-code usages is to big(&gt;500 for example) and asked wheather I want to search them anyway.</div>
","1"
"IDEA-168875","IntelliJ IDEA","","Inconsistent pre-selection when renaming scratch files","Dmitry Cherniachenko","28/02/2017 12:41","28/02/2017 12:41",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When renaming a scratch file via tab context menu &gt; Rename File... only the file name is pre-selected in the dialog input.<br/>But when doing that with Shift+F6 shortcut (when caret is at the very beginning of the file) the full name, including the file extension is pre-selected.<br/><br/>P.S. Tried this with JSON and Plain text scratch files.<br/>P.P.S. Pressing Shift+F6 in the JSON while not on a property name does nothing. It should probably show the same Rename File dialog.</div>
","0"
"IDEA-167960","IntelliJ IDEA","","Find duplicates of methods with type parameters","Anna Kozlova","09/02/2017 11:53","09/02/2017 11:53",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    &lt;T&gt; T bar(Supplier&lt;T&gt; s) {<br/>        return s.get();<br/>    }<br/><br/>    String foo(final Supplier&lt;String&gt; s) {<br/>        return s.get();<br/>    }</pre><br/>foo is a specialization of bar with &#39;String&#39; as type argument; currently IDEA doesn&#39;t find the duplicate though such cases could help a lot during extracting functional strategies</div>
","0"
"IDEA-48796","IntelliJ IDEA","reproduced","Change method signatire for class implementing I1 and I2 changes signature of I2, but not I1","Serge Baranov","28/04/2009 05:55","06/02/2017 15:38",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">interface i1 {<br/>  void foo();<br/>}<br/><br/>interface i2 {<br/>  void foo();<br/>}<br/><br/>class c implements i1, i2 {<br/>  public void foo() {};<br/>}</pre><br/>Change c.foo signature, only one interface will be affected.</div>
","3"
"IDEA-167551","IntelliJ IDEA","","Inline Iterable#forEach sometimes produces fully-qualifed class names","Andrey Turbanov","02/02/2017 09:39","02/02/2017 10:31",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">        Consumer&lt;SettlementPrice&gt; settlementPriceConsumer = System.out::println;<br/>        settlementPrices.forEach(settlementPriceConsumer);</pre><br/>When I inline forEach call IDEA expands SettlementPrice to fully qualifed name.</div>
","0"
"IDEA-150766","IntelliJ IDEA","reproduced","Extract variable doesn't find occurrences that are exactly the same","Róbert Papp","22/01/2016 12:06","01/02/2017 07:36",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Given the following code:<br/><pre class=""wikicode prettyprint"">private void f(List&lt;int[]&gt; lefts, List&lt;int[]&gt; rights) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>for (int i = 0, j = 0; i &lt; lefts.size() || j &lt; rights.size(); ) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int[] left = lefts.get(i);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int[] right = rights.get(j);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>if (i &lt; lefts.size() &amp;&amp; j &lt; rights.size() &amp;&amp; left[0] == right[0]) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>i++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>j++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>} else if (j &gt;= rights.size() || (i &lt; lefts.size() &amp;&amp; j &lt; rights.size() &amp;&amp; left[0] &lt; right[0])) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>i++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>} else if (i &gt;= lefts.size() || i &lt; lefts.size() &amp;&amp; j &lt; rights.size() &amp;&amp; left[0] &gt; right[0]) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>j++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre><br/>Try to extract <code class=""inline-code"">rights.size()</code> into a new local variable:<br/><div class=""wiki picture""><img src=""[](image2.png)""/></div><br/>all is well, but if I extend the selection to <code class=""inline-code"">i &lt; lefts.size() &amp;&amp; j &lt; rights.size()</code> I get the following dialog:<br/><div class=""wiki picture""><img src=""[](image3.png)""/></div><br/><br/>As you can see with Find It&#39;s clear that the three occurrences are textually equal, so Extract Variable should pick it up:<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","1"
"IDEABKL-7430","IntelliJ IDEA: Backlog","","Extract constant in-place should allow to change visibility scope","Marcin Zajaczkowski","31/10/2013 20:01","26/01/2017 14:34",,"Normal","Usability Problem","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">With &quot;Enable in-place mode&quot; extract constant refactoring generates always public constants (public static final). There could be a dialog (like in &quot;Extract field&quot;) to choose (and remember for further usage) what scope extracted constant should have (a combobox or just a simple checkbox - make it private).<br/><br/>The faster option could be changing the default scope in in-place mode for constants to private. When extracting constants it is usually better to make it private (and change later to public if needed somewhere outside).</div>
","2"
"IDEA-72500","IntelliJ IDEA","","Let us TEST private fields and methods with JUnit or TestNG - finally a solution!","Marcelo Glasberg","27/07/2011 10:41","22/01/2017 11:16",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Lots of people use Java reflection to access private methods for testing purposes (with JUnit, TestNG...). This is cumbersome and prevents <strong>refactoring </strong> (since methods must be accessed by Strings). Some other people change methods and fields from private to protected just to be able to test them, which is, of course, very undesirable.<br/> <br/>This page explains the problem in detail: <em><a href=""http://www.artima.com/suiterunner/private.html"" target=""_blank"" rel=""noopener noreferrer"">http://www.artima.com/suiterunner/private.html</a></em><br/> <br/>There was no good solution until recently. But things have changed. The recently released dp4j library from K. Gabriele, an open-source annotation processor, lets us access any private constructors, methods and fields, only inside test methods (the ones marked with the <a href=""https://youtrack.jetbrains.com/users/test"" title=""test"" data-user-id=""11-210808"">Richard Sun</a> annotation or @InjectReflection). This library is now <strong>recommended by the JUnit website</strong>, and it <strong>works!</strong> It lets us test private methods, making testing much easier. Here it is:<br/> <br/>   <em><a href=""http://www.junit.org/node/591"" target=""_blank"" rel=""noopener noreferrer"">http://www.junit.org/node/591</a></em><br/> <br/>   <em><a href=""http://dp4j.com"" target=""_blank"" rel=""noopener noreferrer"">http://dp4j.com</a></em><br/> <br/>The problem is that although the tests compile and run, yielding the right results, IntelliJ still underlines the private fields and methods as errors, and tells us: <strong>&quot;XXX has private access&quot;</strong>.<br/> <br/>I could put up with the red line errors (although I would prefer not), but the unacceptable side effect is that this prevents me to <strong>refactor the code</strong>, since IntelliJ will not refactor them in this state.<br/> <br/><br/>There should be a way to configure IntelliJ so that, inside of methods annotated with <a href=""https://youtrack.jetbrains.com/users/test"" title=""test"" data-user-id=""11-210808"">Richard Sun</a>, private fields and methods should be treated as if they were public (since now they can be accessed inside these tests). In more detail:<br/><br/>1) inside of methods annotated with <a href=""https://youtrack.jetbrains.com/users/test"" title=""test"" data-user-id=""11-210808"">Richard Sun</a>, we should be able to <strong>refactor</strong> private fields and methods (THIS IS THE MOST IMPORTANT). <br/><br/>2) inside of methods annotated with <a href=""https://youtrack.jetbrains.com/users/test"" title=""test"" data-user-id=""11-210808"">Richard Sun</a>, accessing private fields and methods should not marked as errors (since they now compile).<br/><br/>3) inside of methods annotated with <a href=""https://youtrack.jetbrains.com/users/test"" title=""test"" data-user-id=""11-210808"">Richard Sun</a>, private fields and methods should appear during the auto-complete (this is not as important).<br/><br/> <br/><div class=""java code title"">Code Example - how to test private methods by simply adding DP4J to the classpath</div><pre class=""wikicode lang-scala prettyprint""><br/>public class ObjectToTestDp4j<br/>    {<br/>    private int privateField;<br/>    private ObjectToTestDp4j() { this.privateField = 123; }<br/>    private int privateMethod() { return 456; }<br/>    }<br/><br/>public class TestAcessingPrivateObject {<br/>    @Test<br/>    public void testAcessingObjectDP4J() throws Exception {<br/>        ObjectToTestDp4j testObject = new ObjectToTestDp4j();<br/>        assertEquals(123, testObject.privateField);<br/>        assertEquals(456, testObject.privateMethod());<br/>        }<br/>    }</pre></div>
","3"
"IDEA-165593","IntelliJ IDEA","","NPE extracting variable","Timur Yuldashev","16/12/2016 14:37","20/01/2017 13:36",,"Normal","Bug",,"roman.shevchenko","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">171.1754<br/><br/>To reproduce use code snippet below<br/><ul class=""wiki-list0""><li>Make sure that when &#39;Extract variable&#39; refactoring invoked setting <strong>&quot;Declare final&quot; is OFF</strong><br/></li><li>Place care on <span class=""monospace"">list</span> and extract variable - exception thrown, though produced code looks the same as i would expect</li></ul><br/><pre class=""wikicode prettyprint"">void test(List&lt;String&gt; list) {<br/>        int i =<br/>        for(String s : &lt;caret&gt;list) { // extract variable<br/>    <br/>        }<br/>    }</pre><br/>null<br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.NullPointerException</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.JavaVariableInplaceIntroducer.createFieldToStartTemplateOn(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/JavaVariableInplaceIntroducer.java"" lne=""403"" title=""Open in IDE"">JavaVariableInplaceIntroducer.java:403</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.createFieldToStartTemplateOn(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/AbstractJavaInplaceIntroducer.java"" lne=""79"" title=""Open in IDE"">AbstractJavaInplaceIntroducer.java:79</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.createFieldToStartTemplateOn(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceParameter/AbstractJavaInplaceIntroducer.java"" lne=""33"" title=""Open in IDE"">AbstractJavaInplaceIntroducer.java:33</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.a(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/AbstractInplaceIntroducer.java"" lne=""191"" title=""Open in IDE"">AbstractInplaceIntroducer.java:191</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.a(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""149"" title=""Open in IDE"">CoreCommandProcessor.java:149</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""109"" title=""Open in IDE"">CoreCommandProcessor.java:109</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""99"" title=""Open in IDE"">CoreCommandProcessor.java:99</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""85"" title=""Open in IDE"">CoreCommandProcessor.java:85</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/AbstractInplaceIntroducer.java"" lne=""189"" title=""Open in IDE"">AbstractInplaceIntroducer.java:189</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.IntroduceVariableBase$3.pass(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/IntroduceVariableBase.java"" lne=""668"" title=""Open in IDE"">IntroduceVariableBase.java:668</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.IntroduceVariableBase$3.pass(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/IntroduceVariableBase.java"" lne=""639"" title=""Open in IDE"">IntroduceVariableBase.java:639</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduce.inplace.OccurrencesChooser.showChooser(<a class=""dsLink"" txt=""com/intellij/refactoring/introduce/inplace/OccurrencesChooser.java"" lne=""93"" title=""Open in IDE"">OccurrencesChooser.java:93</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.IntroduceVariableBase.invokeImpl(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/IntroduceVariableBase.java"" lne=""720"" title=""Open in IDE"">IntroduceVariableBase.java:720</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.IntroduceVariableBase.a(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/IntroduceVariableBase.java"" lne=""279"" title=""Open in IDE"">IntroduceVariableBase.java:279</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.introduceVariable.IntroduceVariableBase.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/introduceVariable/IntroduceVariableBase.java"" lne=""145"" title=""Open in IDE"">IntroduceVariableBase.java:145</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/actions/BaseRefactoringAction.java"" lne=""129"" title=""Open in IDE"">BaseRefactoringAction.java:129</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil$1.run(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""208"" title=""Open in IDE"">ActionUtil.java:208</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.a(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""89"" title=""Open in IDE"">TransactionGuardImpl.java:89</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.submitTransactionAndWait(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""157"" title=""Open in IDE"">TransactionGuardImpl.java:157</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""222"" title=""Open in IDE"">ActionUtil.java:222</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$1.performAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""570"" title=""Open in IDE"">IdeKeyEventDispatcher.java:570</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.a(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""619"" title=""Open in IDE"">IdeKeyEventDispatcher.java:619</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.TransactionGuardImpl.performUserActivity(<a class=""dsLink"" txt=""com/intellij/openapi/application/TransactionGuardImpl.java"" lne=""202"" title=""Open in IDE"">TransactionGuardImpl.java:202</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""618"" title=""Open in IDE"">IdeKeyEventDispatcher.java:618</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.e(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""477"" title=""Open in IDE"">IdeKeyEventDispatcher.java:477</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""211"" title=""Open in IDE"">IdeKeyEventDispatcher.java:211</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""624"" title=""Open in IDE"">IdeEventQueue.java:624</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""365"" title=""Open in IDE"">IdeEventQueue.java:365</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""105"" title=""Open in IDE"">EventDispatchThread.java:105</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""101"" title=""Open in IDE"">EventDispatchThread.java:101</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""93"" title=""Open in IDE"">EventDispatchThread.java:93</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""82"" title=""Open in IDE"">EventDispatchThread.java:82</a>)</pre></details></div></div>
","0"
"IDEA-112022","IntelliJ IDEA","","Refactoring: convert boolean params into enum ","Yann Cebron","14/08/2013 06:32","09/01/2017 12:38",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><a href=""https://twitter.com/mikaelgrev/status/367574555550035968"" target=""_blank"" rel=""noopener noreferrer"">https://twitter.com/mikaelgrev/status/367574555550035968</a> </div>
","3"
"IDEA-165778","IntelliJ IDEA","","Change Signature dialog (Ctrl+F6) UX can be improved with editing parameter types","Kevin Connor Arpe","21/12/2016 23:31","22/12/2016 07:45",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I use IntelliJ Ultimate EAP (latest) on Windows with Java 8.<br/><br/>IntelliJ IDEA 2016.3<br/>Build #IU-163.7743.44, built on November 18, 2016<br/>Licensed to Kevin Arpe<br/>You have perpetual fallback license for this version<br/>Subscription is active until November 27, 2017<br/>JRE: 1.8.0_92-b14 amd64<br/>JVM: Java HotSpot(TM) 64-Bit Server VM by Oracle Corporation<br/><br/>To recreate the issue:<br/><ol class=""wiki-list0""><li> Create two types (classes or interfaces) where their names only differ by a small suffix.  Example: MyService and MyService2.  Create a method using this type, e.g., MyService.<br/></li><li> Place the cursor on the method name and strike Ctrl+F6 to open the Change Signature dialog.<br/></li><li> Select a parameter to edit. <div class=""wiki picture""><img src=""[](image.png)""/></div><br/></li><li> Edit the paramter type to add the small suffix, e.g., MyService -&gt; MyService2<br/></li><li> The text will become red to indicate an import is missing.   <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/></li><li> Notice the tiny red lightbulb appears, but the tooltip hint does not automatically appear.<br/></li><li> Now press the left arrow key to move the cursor one character to the left.<br/></li><li> Notice how the tooltip hint now automatically appears.  <div class=""wiki picture""><img src=""[](image3.png)""/></div></li></ol><br/>Why does the UX change when I move the cursor by one character?  The behaviour is a bit strange.<br/>Perhaps this is intentional and &quot;by-design&quot;.  If so, please kindly explain.  Else, this UX feels inconsistent.<br/><br/>This is a very, very small issue, so I am marking as a feature, not a bug.  You may re-categorise if you please.</div>
","0"
"IDEA-165675","IntelliJ IDEA","reproduced","'Extract interface' refactoring does not replace static imports for enum constants which breaks compilation","Alexander Dmitriev","20/12/2016 05:56","20/12/2016 11:26",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider the following code (it is also attached): <br/><pre class=""wikicode prettyprint"">package foo;<br/><br/>import static foo.bar.Bar.Type.A;<br/><br/>public class Foo {<br/><br/>    public void foo() {<br/>        System.out.println(A);<br/>    }<br/>}</pre><pre class=""wikicode prettyprint"">package foo.bar;<br/><br/>public interface Bar {<br/>    enum Type {<br/>        A, B, C;<br/>    }<br/>}</pre><br/>Steps to reproduce (screenshots attached):<br/><ol class=""wiki-list0""><li> Use <em>Extract interface</em> refactoring on <code class=""inline-code"">Bar</code> and include <code class=""inline-code"">Type</code> as <em>member to form interface</em>. <br/></li><li> Accept suggestion to replace usages.</li></ol>Actual result:<br/><ol class=""wiki-list0""><li> Usages are not found - &quot;No usages found&quot; dialog is present<br/></li><li> Code does not compile</li></ol>Expected result:<br/>Usage in static import is replaced and code compiles.</div>
","1"
"IDEA-165299","IntelliJ IDEA","","Introduce a ""Delete method"" refactoring that allows deleting method calls","Manoel Campos da Silva Filho","10/12/2016 13:00","12/12/2016 08:52",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The &quot;Safe delete&quot; refactoring doesn&#39;t allow deleting method calls. A new refactoring &quot;Method Delete&quot; would be included or the &quot;Safe delete&quot; dialog should provide an option to enable deleting such calls.</div>
","0"
"IDEA-165015","IntelliJ IDEA","reproduced","""Push members down"" should push corresponding constructor arguments down as well","Igor Baltiyskiy","05/12/2016 08:25","05/12/2016 12:57",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><div class=""java code title"">Initial</div><pre class=""wikicode prettyprint"">class Base {<br/>  protected final String myField;<br/><br/>  Base(String field) {<br/>    myField = field;<br/>  }<br/>}<br/><br/>class Derived extends Base {<br/>  Derived(String field) {<br/>    super(field);    <br/>  }<br/>}</pre><br/>Invoke &quot;Push members down&quot; on <span class=""monospace"">myField</span>.<br/><br/>Observed: &quot;Problems Detected&quot; dialog with the following message<br/><br/><div class=""wiki quote""> Constructor Base(String) uses field myField, which is pushed down</div><br/><br/>Click Continue.<br/><br/><div class=""java code title"">Observed</div><pre class=""wikicode prettyprint"">class Base {<br/><br/>  Base(String field) {<br/>    myField = field;<br/>  }<br/>}<br/><br/>class Derived extends Base {<br/>  protected final String myField;<br/><br/>  Derived(String field) {<br/>    super(field);    <br/>  }<br/>}</pre><br/>Note that the code becomes invalid.<br/><br/>Expected: IDEA detects that Base&#39;s constructor argument <span class=""monospace"">field</span> is only used to initialize the member that is being pushed down, so the constructor argument gets pushed down as well:<br/><br/><div class=""java code title"">Expected</div><pre class=""wikicode prettyprint"">class Base {<br/>  Base() {<br/>  }<br/>}<br/><br/>class Derived extends Base {<br/>  protected final String myField;<br/><br/>  Derived(String field) {<br/>    super();<br/>    myField = field;    <br/>  }<br/>}</pre><br/>or even <br/><br/><pre class=""wikicode prettyprint"">class Base {<br/>}<br/><br/>class Derived extends Base {<br/>  protected final String myField;<br/><br/>  Derived(String field) {<br/>    myField = field;    <br/>  }<br/>}</pre><br/>----<br/>I&#39;m observing this on 2016.2.4, but I can&#39;t select this version in Affected versions field.</div>
","1"
"IDEA-163816","IntelliJ IDEA","reproduced","Cannot extract method argument of vararg type with Ctl+Alt+V","Сергей Цыпанов","10/11/2016 10:45","11/11/2016 04:51",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">see attachment<br/><br/>getMaxDate() takes vararag Date... as argument</div>
","0"
"IDEA-42932","IntelliJ IDEA","","Spring + aop: refactor-rename of package used in pointcut expression is not performed correctly","Irina Petrovskaya","15/02/2008 07:01","27/10/2016 10:07",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">for example, with the following advices configured in xml:<br/>&lt;aop:before method=&quot;m02&quot; pointcut=&quot;execution(* newtest.*.*(..))&quot;&gt;&lt;/aop:before&gt;<br/> &lt;aop:before method=&quot;m02&quot; pointcut=&quot;within(mytest..*)&quot;&gt;&lt;/aop:before&gt;<br/><br/>rename the &#39;newtest&#39; package to &#39;newtest_re&#39; or &#39;mytest&#39; package to &#39;mytest1:<br/><br/>as a result the &#39;newtest_re_re&#39; and &#39;mytest_1_1&#39; appear in xml.<br/><br/>If there are few pointcut expressions in same or different files, some of them may be refactored correctly, and some ones get extra suffix.<br/><br/>Problem exists both in 7701 and 8158 builds<br/><br/>classes/annotations/methods renaming seems to be performed correctly</div>
","0"
"IDEA-139251","IntelliJ IDEA","","Impossible to Delete/Rename/Move package that exists in both library jar(s) and in project root(s) from Packages view with ShowModules off","Irina Petrovskaya","15/04/2015 10:55","24/10/2016 15:37",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">142.1183<br/><br/>consider even the single-module project with top package named &#39;com&#39;, &#39;org&#39; etc - i.e. the same-named package should exist in library jars.<br/>Switch to Packages view and uncheck the &#39;show modules&#39; option.<br/>Select the above package in tree and try to invoke any refactoring for it:<br/>Shift-F6 - Rename - shows error message &quot;cannot perform refactoring. Selected package is not located inside project&quot;.<br/>Del - delete directory - no reaction (disabled)<br/>Alt-Del, F6 - dialog &quot;multiple directories correspond to package..., do you wish to continue?&quot; - yes - &quot;refactoring cannot be performed&quot;.<br/><br/>Thus there is no possibility to process the fs directory only.<br/><br/>If the &#39;show modules&#39; option is ON, i can <br/><ul class=""wiki-list0""><li> delete the package (del, alt-del) (all same-named packages in the specific module roots are removed)<br/></li><li> rename the package (the packages in the specific module roots (&#39;current directory&#39; option) or in all modules are renamed)</li></ul><br/>It would be nice to allow deleting and renaming for such packages in this mode also</div>
","0"
"IDEA-161095","IntelliJ IDEA","","A slow running refactoring uses only 1 CPU","David Pérez","12/09/2016 10:44","13/09/2016 04:01",,"Normal","Performance Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I&#39;m renaming a very used Java static method, and the running time is slow.<br/>When looking at the processor use, only 1 processor is used.<br/>It would be nice if some kind of parallelization is performed.  Nowadays, all the computers have several cores.<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-160417","IntelliJ IDEA","","Move classes does not work if source root folder is not created","Eugene Petrenko","28/08/2016 08:35","29/08/2016 15:06",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In gradle project I have a number of modules that does not have respective folders created<br/>I cannot set Gradle checkbox to create all folders (as it will generate too much mess)<br/><br/>In a move class dialog I cannot select module root if directory does not exist. <br/>So I have to manually create directory prior to moving something<br/><br/>Let&#39;s make Move class dialog show all source roots, even it they are not yet created</div>
","0"
"IDEA-159845","IntelliJ IDEA","reproduced","Spellcheck inspection quickfix applied to JavaDoc doesn't update actual code","Timur Yuldashev","15/08/2016 11:21","15/08/2016 11:23",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider code sample below:<br/><br/>1. Put caret on <span class=""monospace"">typee</span> word inside <strong>JavaDoc</strong><br/>2. &#39;Alt-Enter&#39; - &#39;Change to&#39; - select &#39;type&#39; - note that actual parameter name of the method parameter is not changed so JavaDoc becomes broken.<br/><br/>This does not happen when user directly applies rename refactoring to the JavaDoc param.<br/><br/><pre class=""wikicode prettyprint"">    /**<br/>     * @param typee - input<br/>     */<br/>    void foo(String typee) {}</pre></div>
","0"
"IDEA-55197","IntelliJ IDEA","","locate newly generated elements to the last one of the same type (instance variable, class variable, etc)","Alexey Pegov","21/05/2010 10:07","12/08/2016 11:20",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown",,"0"
"IDEA-151036","IntelliJ IDEA","","Inline parameter is not properly formatted","Filipe Sousa","29/01/2016 14:31","30/07/2016 08:09",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><br/>IntelliJ IDEA 15.0.3<br/>Build #IU-143.1821, built on January 19, 2016<br/>JRE: 1.8.0_72-b15 x86_64<br/>JVM: Java HotSpot(TM) 64-Bit Server VM by Oracle Corporation<br/>OSX</div>
","0"
"IDEA-158922","IntelliJ IDEA","","""Cast conflicts with 'instanceof'"" inspection triggers with adding outer IF","Timur Yuldashev","22/07/2016 08:38","22/07/2016 08:38",,"Normal","Bug",,"basleijdekkers","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 163.1707</strong><br/><br/>Consider boundary case below, though both cases are quite similar only in second user gets a warning due conflict with outer <span class=""monospace"">if (o instanceof I)</span>. Probably we should not warn in case there is inner qualifying if statement. There are quite many such samples in IDEA code, so i believe it make sense to implement, maybe with inspection option.<br/><br/><pre class=""wikicode prettyprint"">interface I {}<br/>class A implements I {}<br/>class B implements I {}<br/><br/>public class AdditioinalIf{<br/>    void ignores(Object o) { // OK<br/>        if (o instanceof A) {<br/>            A a = (A) o;<br/>        } else {<br/>            B b = (B) o; // no warning<br/>        }<br/>    }<br/><br/>    void warns(Object o) {<br/>        if (o instanceof I) { // additional qualifying if<br/>            if (o instanceof A) {<br/>                A a = (A) o;<br/>            } else {<br/>                B b = (B) o; // warning here<br/>            }<br/>        }<br/>    }<br/>    <br/>}</pre></div>
","0"
"IDEA-94353","IntelliJ IDEA","","Better usability support for extract enum","Kirill Likhodedov","07/11/2012 08:50","06/07/2016 11:48",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">0. Suppose, I have several constants that I want to convert to enum:<br/><pre class=""wikicode prettyprint"">  public static final String COMMIT_EDITMSG = &quot;COMMIT_EDITMSG&quot;;<br/>  public static final String CONFIG = &quot;config&quot;;<br/>  public static final String HEAD = &quot;HEAD&quot;;</pre>(for the example to reproduce you may take a look at the constants from <span class=""monospace"">GitRepositoryFiles</span>)<br/><br/>1. I select these lines, right click, select &quot;Refactor&quot; -&gt; &quot;Extract&quot; -&gt; &quot;Class&quot;.<br/>I would like to see &quot;Extract&quot; -&gt; &quot;Enum&quot; in this list along with existing Class, Interface and Superclass, that would open a specialized dialog for extracting enum<br/><br/>2. In the Extract Class dialog the fields I&#39;ve selected are not checked in the table.<br/>(If I select just one constant, it is selected, but for several constants it doesn&#39;t work).<br/><br/>3. I select the constants I want to extract.<br/><br/>4. I select the checkbox &quot;Extract as enum&quot;.<br/><br/>5. And now I need to set other &quot;As enum&quot; checkboxes again! <br/><br/>6. Press &quot;Refactor&quot;.<br/><br/>7. Some analysis is performed, and I get the following question: &quot;Found more than 10 roots to migrate. Do you want to preview?&quot;<br/>What are &quot;roots&quot; here? This is not clear.<br/><br/>8. Select &quot;Yes&quot;.<br/><br/>9. Now I get another confusing dialog: <br/>&quot;Unable to migrate statement to enum constant.  <br/>Constructor requires moved members.&quot;<br/><br/>10. I click &quot;Show in view&quot; and get the problem view. It is not clear for me, why the engine is &quot;unable to migrate&quot;, but OK, that&#39;s fine from the usability point of view (although more details would help to understand why it is so):<br/><pre class=""wikicode prettyprint"">private GitRepositoryFiles(@NotNull VirtualFile gitDir) { (Constructor requires moved members)<br/>public static final String INDEX = &quot;index&quot;; (Unable to migrate statement to enum constant.)</pre><br/>Summarizing, here is what I would expect the following:<br/><ul class=""wiki-list0""><li> A separate action &quot;Extract Enum&quot; that would concentrate on this task.<br/></li><li> If I select several fields before invoking the refactoring, they should be selected in the table.<br/></li><li> Why I need to select checkboxes twice if I want a enum?<br/></li></ul></div>
","3"
"IDEA-153518","IntelliJ IDEA","reproduced","Add @Override to renamed method if it's implement base method","Timur Yuldashev","23/03/2016 10:27","01/07/2016 10:32",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When user renames method and new name is the same as one of base class/interfaces methods IDEA detects such problem and asking confirmation.<br/><br/>I think it would be nice to add <span class=""monospace"">@Override</span> annotation to such method if user selects <em>Continue</em>. The same as we remove such annotation in opposite situation.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-158103","IntelliJ IDEA","reproduced","Rename refactoring shows wrong warning that method call will be linked to another one","Timur Yuldashev","01/07/2016 10:17","01/07/2016 10:28",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 162.1120.1</strong><br/><br/>Code sample below demonstrates the problem.<br/><br/><ul class=""wiki-list0""><li>Use quickfix &#39;Rename to equals&#39; or just Rename refactoring on <span class=""monospace"">A.equal</span><br/></li><li>Rename method <span class=""monospace"">equal</span> to <span class=""monospace"">equals</span> - note warning appears that method call <span class=""monospace"">new B().equal(1);</span> will be relinked to <span class=""monospace"">Object.equals</span><br/></li><li>But complete refactoring and see that still <span class=""monospace"">A.equals</span> is called.</li></ul><br/><br/><pre class=""wikicode prettyprint"">class A {<br/>    void equal(Integer i) { // rename to equals<br/>        System.out.println(&quot;A.foo&quot;);<br/>    }<br/>}<br/><br/>class B extends A {}<br/><br/>class Client {<br/>    public static void main(String[] args) {<br/>        new B().equal(1);<br/>    }<br/>}</pre><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-157889","IntelliJ IDEA","","Refactoring Move Method should also list variables as targets","Eduard Wirch","27/06/2016 04:28","27/06/2016 04:47",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Take this code:<br/><pre class=""wikicode prettyprint"">Merger merger = new Merger();<br/>mergedConfiguration = merge(....);</pre><br/>This is the only invocation of <span class=""monospace"">merge()</span>. When invoking &quot;Move...&quot; on the method invocation, the dialog presents the field list as targets. The variable <span class=""monospace"">Merger merger</span> should be part of the suggested list.</div>
","0"
"IDEABKL-7377","IntelliJ IDEA: Backlog","","Refactor/rename works incorrectly in java files outside source root & scratches","Irina Petrovskaya","06/06/2016 08:13","22/06/2016 08:16",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">162.822<br/><br/>create the java-type scratch file like follows:<br/><br/><pre class=""wikicode prettyprint"">public class Foo{<br/><br/>    public static void main(String[] args) {<br/>        InnerFoo innerFoo = new InnerFoo();<br/>        innerFoo.boo(&quot;world&quot;);<br/><br/>    }<br/>/**<br/> * inner class<br/> * **/<br/>static class InnerFoo{<br/>    void boo(String sss){<br/>        System.out.println(&quot;hello &quot;+sss);<br/>    }<br/><br/>}<br/>}</pre><br/>invoke refactor/rename for the InnerFoo class, or boo method (for reference or declaration) - as a result rename is performed, but then the reference rename is undone.<br/>Same - if multiple non-public classes are declared in teh same file and reference each other, like<br/><pre class=""wikicode prettyprint"">class Class1{<br/>    public static void main(String[] args) {<br/>        Class2 class2 = new Class2();<br/>        System.out.println(class2.aClass2Method());<br/>    }<br/>}<br/>class Class2{<br/>    public String aClass2Method(){return  &quot;foo&quot;;}<br/>}</pre><br/><br/><strong>UPD</strong> Create java file outiside of any source root.<br/>Resolve works, while &#39;rename&#39; live template doesn&#39;t show up for class references.</div>
","0"
"IDEA-157756","IntelliJ IDEA","","Allow to extract variable to existing non-final field","Alexander Kass","22/06/2016 06:28","22/06/2016 06:28",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">For example Ctrl+Alt+V first creates local variable, on the second stroke suggests local variables if any, on the third one - non-final fields.</div>
","0"
"IDEA-156705","IntelliJ IDEA","","Extract parameter: provide varargs parameter type additionally to array types","Yann Cebron","27/05/2016 06:45","31/05/2016 12:54",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Extract parameter for <br/><br/><span class=""monospace"">&quot;char&quot;, &quot;double&quot;, &quot;java&quot;, &quot;javax&quot;</span><br/><br/>only array-types are provided in &quot;parameter of type&quot; chooser<br/><br/>expected: varargs should be provided as well (String..., CharSequence ...)</div>
","1"
"IDEA-156459","IntelliJ IDEA","","Delegate equals(): more consistent code template","Dmitry Cherniachenko","23/05/2016 11:24","23/05/2016 13:28",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When delegating <code class=""inline-code"">equals()</code> method IDEA generates a generic method stub:<br/><pre class=""wikicode prettyprint"">@Override<br/>public boolean equals(Object obj) {<br/>    return delegate.equals(obj);<br/>}</pre><br/>This method however is quite special. And the code like this is probably more appropriate:<br/><pre class=""wikicode prettyprint"">@Override<br/>public boolean equals(Object obj) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>if (obj == this) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return true;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>if (obj instanceof WrapperClass) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return delegate.equals(((WrapperClass) obj).delegate);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>return false;<br/>}</pre><br/>Yes, (almost) the same result can be achieved by using &quot;generate&quot; instead of &quot;delegate&quot;. But when creating multiple method delegates it would be convenient to have more consistent (fail-safe) <code class=""inline-code"">equals()</code> implementation by default.</div>
","0"
"IDEA-155110","IntelliJ IDEA","","Refactoring 'Use Interface where possible' applied to library type java.util.ArrayList breaks Undo","Timur Yuldashev","22/04/2016 11:00","18/05/2016 09:55",,"Major","Bug",,"anton.makeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.1397</strong><br/><br/>And also update type parameter to fully qualified identifier.<br/><br/>Consider code below:<br/><br/><pre class=""wikicode prettyprint"">package Temp;<br/><br/>import java.util.ArrayList;<br/>import java.util.List;<br/><br/>public class ListOfString {<br/>    public static void main(String[] args) {<br/>        ArrayList&lt;BaseClass&gt; list = new ArrayList&lt;&gt;();<br/>    }<br/>}</pre><br/><ul class=""wiki-list0""><li> Assume i want to change type of variable declaration from ArrayList to List everywhere possible.<br/></li><li> Set caret on <span class=""monospace"">ArrayList</span> and go to declaration &quot;Ctrl-B&quot;.<br/></li><li> Invoke <strong>&#39;Use Interface where possible&quot;</strong> for <span class=""monospace"">ArrayList</span> to update it to <span class=""monospace"">List</span>.<br/></li><li> Code is modified to:</li></ul><br/><pre class=""wikicode prettyprint"">List&lt;Temp.BaseClass&gt; list = new ArrayList&lt;&gt;();</pre><br/>There are two problems with that:<br/>1. Undo doesn&#39;t work after that, even confirmation dialog appears at &#39;Ctrl-Z&#39;. (Because of this increase priority to Major.)<br/>2. <span class=""monospace"">BaseClass</span> class is replaced with <span class=""monospace"">Temp.BaseClass</span>, which is not necessary.</div>
","0"
"IDEA-156090","IntelliJ IDEA","reply needed","Very slow typing inside new variable name","Egor Ushakov","16/05/2016 11:43","17/05/2016 14:32",,"Normal","Bug",,"zolotov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">master from 16.05.16<br/>steps to reproduce:<br/><ul class=""wiki-list0""><li> go to EditorImpl<br/></li><li> extract any variable<br/></li><li> start typing it&#39;s name<br/></li></ul></div>
","0"
"IDEA-155996","IntelliJ IDEA","reproduced","Missing suggestion to create constructor/change signature when method reference is passed as parameter","Andrey Turbanov","13/05/2016 07:22","13/05/2016 10:00",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","Yes","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">public class Construct {<br/>    public Construct(String s) {<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        new Construct(Construct::main);<br/>    }<br/>}</pre>IDEA doesn&#39;t suggest anything useful in this case</div>
","0"
"IDEA-155320","IntelliJ IDEA","","""Cannot perform refactoring"" after attempting to rename class from Hibernate mapping definition.","Rob Gillen","27/04/2016 12:46","13/05/2016 06:02",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Attempting to refactor/rename a Java class from within a Hibernate mapping file (via the &quot;name&quot; attribute for the &quot;class&quot; element) fails (CTRL-F6 hotkey appears to do nothing).  Afterward, any attempts to perform any other refactoring operations result in the following dialog:<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>Clicking on either button does nothing except to close the dialog.  Attempts to use refactoring capabilities continue to fail with the dialog until IDEA is restarted.</div>
","0"
"IDEA-155054","IntelliJ IDEA","reproduced","'Use Interface Where Possible' refactoring creates uncompilable code for method reference.","Timur Yuldashev","21/04/2016 11:33","26/04/2016 06:24",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.1397</strong><br/><br/>If it&#39;s reference to an instance method of an arbitrary object.<br/><br/>Please try apply refactoring <strong>&#39;Use Interface Where Possible&#39;</strong> in code below. In result it creates uncompilable code.<br/><br/><pre class=""wikicode prettyprint"">class A {}<br/><br/>class B extends A { // apply &#39;Use Interface Where Possible&#39;<br/>    int foo() {<br/>        return 1;<br/>    }<br/>}<br/><br/>class MethodReference {<br/>    static void main(String[] args) {<br/>        Consumer&lt;B&gt; cons = B::foo;<br/>    }<br/>}</pre></div>
","0"
"IDEA-155126","IntelliJ IDEA","reproduced","'Use Interface where possible' creates uncompilable code for call of protected method","Timur Yuldashev","22/04/2016 12:31","25/04/2016 12:21",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.1397</strong><br/><br/>In case method declared in another package protected method could become unreachable after applying refactoring <strong>&#39;Use Interface where possible&#39;</strong>.<br/><br/>For example use this code snippet:<br/><pre class=""wikicode prettyprint"">class C {}<br/><br/>class Clone extends C { // Invoke &#39;Use Interface Where Possible&#39;<br/>    void cloneIt(Clone source) throws CloneNotSupportedException {<br/>        source.clone(); // after: error: clone() has protected access in java.lang.Object<br/>    }<br/>}</pre></div>
","0"
"IDEA-155122","IntelliJ IDEA",""," 'Use interface where possible' enable 'Use interface/superclass in instaceof' by default","Timur Yuldashev","22/04/2016 12:24","25/04/2016 12:21",,"Minor","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Refactoring <strong>&#39;Use interface where possible&#39;</strong>.<br/><br/>Documentation to it sounds like usage of option <em> &#39;Use interface/superclass in instaceof&#39; </em> is a good practice, because otherwise wrong code could be produced. No disadvantages mentioned there.<br/><br/>Shouldn&#39;t we enable it by default then or at least remember it state between refactoring invokations.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-155115","IntelliJ IDEA","reproduced","'Use interface where possible' substitutes static method of super class with hidden in base class","Timur Yuldashev","22/04/2016 11:49","25/04/2016 12:21",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 143.1397</strong><br/><br/>Shouldn&#39;t we warn user in this situation?<br/><br/><pre class=""wikicode prettyprint"">class A {<br/>    static void whoAmI() {<br/>        System.out.println(&quot;I&#39;m A&quot;);<br/>    }<br/>}<br/><br/>class B extends A { // invoke &#39;Use interface where possible&#39;<br/>    static void whoAmI() {<br/>        System.out.println(&quot;I&#39;m B&quot;);<br/>    }<br/>}<br/><br/>public class StaticProblem {<br/>    public static void main(String[] args) {<br/>        B.whoAmI(); // becomes A.whoAmI()<br/>    }<br/>}</pre></div>
","1"
"IDEA-155103","IntelliJ IDEA","reproduced","'Use Interface where possible' not recognize that class used as type parameter in library method call","Timur Yuldashev","22/04/2016 10:29","25/04/2016 12:21",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.1397</strong><br/><br/>Consider following code snippet:<br/><br/><pre class=""wikicode prettyprint"">class A {}<br/><br/>class B extends A {} // invoke &#39;Use Interface where possible&#39; refactoring<br/><br/>class C {<br/>        void foo() {<br/>           List&lt;B&gt; list = new ArrayList&lt;&gt;(); // modified and fails on next line<br/>           Declaration.listing(list);<br/>        <br/>           Declaration.listing(new ArrayList&lt;B&gt;());  //not updated and works fine<br/>        }<br/>}</pre><br/>where <span class=""monospace"">Declaration</span> came from library, so cannot be modified<br/><br/><pre class=""wikicode prettyprint"">public class Declaration { <br/>    public static void listing(List&lt;B&gt; list) {<br/>        list.stream().forEach(System.out::println);<br/>    }<br/>}</pre></div>
","0"
"IDEA-155093","IntelliJ IDEA","reproduced","Refactoring 'Use interface where possible' creates uncompilable code for inner class instantination","Timur Yuldashev","22/04/2016 08:57","25/04/2016 12:21",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.1397</strong><br/><br/>Consider such code snippet:<br/><br/><pre class=""wikicode prettyprint"">interface I {}<br/><br/>class C implements I { // invoke &#39;Use interface where possible&#39;<br/>    class Inner {}<br/>}<br/><br/>public class InnerClassIssue {<br/>    public static void main(String[] args) {<br/>        C c = new C();<br/>        c.new Inner();<br/>    }<br/>}</pre></div>
","0"
"IDEA-155091","IntelliJ IDEA","reproduced","Refactoring 'Use interface where possible' doesn't resolve conflict with local variable","Timur Yuldashev","22/04/2016 08:29","25/04/2016 12:21",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.1397</strong><br/><br/>Consider code below:<br/><br/><pre class=""wikicode prettyprint"">class A {}<br/><br/>class B extends A {} // invoke &#39;Use interface where possible&#39; <br/><br/>public class ConflictWithLocalVar {<br/>    public static void main(String[] args) {<br/>        B b = new B();<br/>        A a = new A();<br/>        <br/>        b.toString();<br/>    }<br/>}</pre><br/>Invoke <strong>&#39;Use interface where possible&#39;</strong> and also rename locale variable <span class=""monospace"">b</span> to <span class=""monospace"">a</span> as suggested by IDEA, what conflicts with existing variable. Also it doesn&#39;t rename <span class=""monospace"">b.toString()</span> to <span class=""monospace"">a.toString()</span> in that case.</div>
","0"
"IDEA-154917","IntelliJ IDEA","reply needed","""Occurrences found in comments"" should be first in refactoring preview window","Stepan Koltsov","18/04/2016 18:18","19/04/2016 13:22",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In previous versions of Idea &quot;occurrences found in comments&quot; were first in the list of affected changes. Now it is after &quot;references in code&quot;.<br/><br/>I think occurrences in comments, strings etc. should be first, because such changes are the most dangerous, and often contain false positives. Placing these changes first in the list reduces a chance of overlooking those changes.<br/><br/>If I recall correctly, &quot;occurrences found in comments&quot; were first in the list before Idea 2016.1.<br/><br/>Attached a screenshot of refactoring preview window.</div>
","0"
"IDEABKL-7346","IntelliJ IDEA: Backlog","","Cannot move out last class from java file","Timur Yuldashev","13/04/2016 12:19","14/04/2016 11:32",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">I had a java file containing a test example with several classes and interface. Then decided to move them to separate files in dedicated package. But was not able complete this task, because last one cannot be moved outside file.<br/><br/>Here is the structure i had:<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/><ul class=""wiki-list0""><li> move <span class=""monospace"">I, A, B</span>, one by one into <span class=""monospace"">Inheritance</span> packaged. Ignore (continue) on warnings about inaccessibility.<br/></li><li> <span class=""monospace"">I</span> and <span class=""monospace"">A</span> moved without problem<br/></li><li> but last one <span class=""monospace"">B</span> left in the Inheritance.java even i was promted for this refactoring</li></ul><br/> <div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><br/>I believe this should be allowed.<br/><br/>Also such steps seems cause problem with Undo functionality. At some moment undo command became throwing exception, though i have no exact steps to repeat that.<br/><br/>2016-04-13 17:28:17,193 [ 528498]  ERROR - llij.ide.plugins.PluginManager - null <br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.AssertionError</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.openapi.command.impl.UndoRedoStacksHolder.removeFromStacks(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/UndoRedoStacksHolder.java"" lne=""161"" title=""Open in IDE"">UndoRedoStacksHolder.java:161</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.UndoRedo.execute(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/UndoRedo.java"" lne=""137"" title=""Open in IDE"">UndoRedo.java:137</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandMerger.undoOrRedo(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandMerger.java"" lne=""217"" title=""Open in IDE"">CommandMerger.java:217</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.UndoManagerImpl$4.run(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/UndoManagerImpl.java"" lne=""432"" title=""Open in IDE"">UndoManagerImpl.java:432</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""131"" title=""Open in IDE"">CoreCommandProcessor.java:131</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CoreCommandProcessor.java"" lne=""100"" title=""Open in IDE"">CoreCommandProcessor.java:100</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.UndoManagerImpl.b(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/UndoManagerImpl.java"" lne=""445"" title=""Open in IDE"">UndoManagerImpl.java:445</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.UndoManagerImpl.undo(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/UndoManagerImpl.java"" lne=""410"" title=""Open in IDE"">UndoManagerImpl.java:410</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.actions.UndoAction.perform(<a class=""dsLink"" txt=""com/intellij/ide/actions/UndoAction.java"" lne=""30"" title=""Open in IDE"">UndoAction.java:30</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.actions.UndoRedoAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/ide/actions/UndoRedoAction.java"" lne=""39"" title=""Open in IDE"">UndoRedoAction.java:39</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAware(<a class=""dsLink"" txt=""com/intellij/openapi/actionSystem/ex/ActionUtil.java"" lne=""193"" title=""Open in IDE"">ActionUtil.java:193</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$3.performAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""593"" title=""Open in IDE"">IdeKeyEventDispatcher.java:593</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""644"" title=""Open in IDE"">IdeKeyEventDispatcher.java:644</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.d(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""483"" title=""Open in IDE"">IdeKeyEventDispatcher.java:483</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(<a class=""dsLink"" txt=""com/intellij/openapi/keymap/impl/IdeKeyEventDispatcher.java"" lne=""213"" title=""Open in IDE"">IdeKeyEventDispatcher.java:213</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""635"" title=""Open in IDE"">IdeEventQueue.java:635</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""392"" title=""Open in IDE"">IdeEventQueue.java:392</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""116"" title=""Open in IDE"">EventDispatchThread.java:116</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""105"" title=""Open in IDE"">EventDispatchThread.java:105</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""101"" title=""Open in IDE"">EventDispatchThread.java:101</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""93"" title=""Open in IDE"">EventDispatchThread.java:93</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""82"" title=""Open in IDE"">EventDispatchThread.java:82</a>)</pre></details></div>2016-04-13 17:28:17,195 [ 528500]  ERROR - llij.ide.plugins.PluginManager - IntelliJ IDEA 2016.2 EAP  Build #IU-146.1211 <br/>2016-04-13 17:28:17,195 [ 528500]  ERROR - llij.ide.plugins.PluginManager - JDK: 1.8.0_74 <br/>2016-04-13 17:28:17,195 [ 528500]  ERROR - llij.ide.plugins.PluginManager - VM: Java HotSpot(TM) 64-Bit Server VM <br/>2016-04-13 17:28:17,195 [ 528500]  ERROR - llij.ide.plugins.PluginManager - Vendor: Oracle Corporation <br/>2016-04-13 17:28:17,196 [ 528501]  ERROR - llij.ide.plugins.PluginManager - OS: Windows 8.1 </div>
","0"
"IDEA-153658","IntelliJ IDEA","reproduced","Selection left after unsuccessful extraction of variable ","Timur Yuldashev","25/03/2016 11:53","25/03/2016 11:53",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 146.685</strong><br/><br/>Put caret on <span class=""monospace"">for</span> in the line <br/><br/><span class=""monospace"">for (int i = 0; i &lt; 5; i++) {}</span><br/><br/>and try to <strong>extract variable</strong>, get error message <em>Cannot perform refactoring...</em><br/><br/>But after that whole line is selected for some reason.<br/><div class=""wiki picture""><img src=""[](image.png)""/></div></div>
","0"
"IDEA-152455","IntelliJ IDEA","reproduced","Complex situation with usage inner and anonymous classes may confuse inline refactor","Timur Yuldashev","02/03/2016 08:55","09/03/2016 10:07",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 145.184.1</strong><br/><br/>Here is simplified example based on IDEA&#39; code: com.intellij.history.integration.ExternalChangesAndRefreshingTest#setUp<br/><pre class=""wikicode prettyprint"">public class Outer extends BaseOuter {<br/>    void performActions(List&lt;String&gt; actionNames) {<br/>        actionNames.stream().forEach(Outer.super::perform); // inline perfrom method<br/>    }<br/>}<br/><br/>public class BaseOuter {<br/>    public String PREFIX = &quot;Base:&quot;;<br/><br/>    public void perform(String action) {<br/><br/>        Runnable runnable = new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                System.out.println(PREFIX + action); //should it be private refactoring warns user<br/>                subPerform(&quot;Calling SubPerform&quot;); //should it be private refactoring warns user<br/>            }<br/>        };<br/>    }<br/><br/>    public void subPerform(String s) {<br/>        System.out.println(s);<br/>    }<br/>}</pre><br/>If user inlines method <span class=""monospace"">perform()</span> on 3rd line it produces uncompilable code:<br/><br/><pre class=""wikicode prettyprint"">public void run() {<br/>                    System.out.println(BaseOuter.this.PREFIX + action); <br/>                    BaseOuter.this.subPerform(&quot;Calling SubPerform&quot;);<br/>                }</pre></div>
","0"
"IDEA-152367","IntelliJ IDEA","","Replace with lambda could be combined with remove unnecessary qualifier","Egor Ushakov","01/03/2016 05:10","01/03/2016 05:10",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If anonymous class used a reference to base class this (or super), after replacing to lambda it highlight unnecessary (now) qualifier.<br/>This could be removed automatically.<br/>For example see com/intellij/ui/popup/AbstractPopup.java:271 (ActionListener references AbstractPopup.this)</div>
","0"
"IDEA-144360","IntelliJ IDEA","","""Extract parameter object"": Improvements when using existing class","Jonas Kvarnström","26/08/2015 04:37","26/02/2016 15:32",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When you use &quot;extract parameter object&quot; and select &quot;use existing class&quot;, IDEA could be more helpful:<br/><br/><ol class=""wiki-list0""><li> If the user selects a number of parameters, they may not be in the same order as in the constructor of the selected existing class.  As long as the types are distinct, IDEA could automatically reorder them in the only possible way.<br/><br/></li><li> If the selected existing class does not have constructors with parameters of a certain type, then those could automatically be deselected from the list of parameters to extract.  Or maybe this should only be done if IDEA can uniquely determine which parameters should be used.  For example, suppose I want to extract a parameter object using an existing class whose only constructor is Foo(int,String,List&lt;String&gt;).  Suppose the method where I invoked the refactoring has 8 parameters, but there is exactly one int parameter, one String parameter and one List&lt;String&gt; parameter.  Then those three parameters could be preselected since they are the only ones that could possibly make the refactoring succeed.<br/><br/></li><li> Sometimes automatic reordering or selection won&#39;t be possible (multiple parameters of the same type).  Then it can be hard to remember the constructor parameter order for the existing class.  It would be useful to show this in some way, for example by including a small &quot;code window&quot; showing the constructor declarations (without the actual code) from the existing class &ndash; or maybe you can come up with some better variation.<br/></li></ol></div>
","0"
"IDEA-151952","IntelliJ IDEA","","'Pull up' refactoring: methods required for interface method should be red in dialog","Timur Yuldashev","20/02/2016 14:21","20/02/2016 14:21",,"Minor","Cosmetics",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build:144.4216</strong><br/><br/>When user pulls up implementation of some interface without moving required methods, such methods highlighted blue in the refactoring dialog. Also hitting <strong>&#39;Refactor&#39;</strong> button applies refactoring without warnings and create incompilable code.<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>I think in this case we should highlight red and show error message, because continuation creates erroneous code.<br/><br/>The same as we do with method referencing instance field, it&#39;s highlighted by red and additionally <em>Problems Detected</em> dialog shown.<br/><br/><div class=""wiki picture""><img src=""[](image2.png)""/></div><div class=""wiki picture""><img src=""[](image3.png)""/></div></div>
","0"
"IDEA-151770","IntelliJ IDEA","reproduced","'Pull up' refactoring doesn't work correctly with hidden fields","Timur Yuldashev","16/02/2016 14:50","18/02/2016 15:10",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build: 144.4216</strong><br/>Let&#39;s have such 3 level hierarchy:<br/><pre class=""wikicode prettyprint"">public class T1            { int x = 1; }<br/>public class T2 extends T1 { int x = 2; }<br/>public class T3 extends T2 {<br/>    void test() {<br/>        System.out.println(&quot;super.x=\t\t&quot;    + super.x);<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        new T3().test(); // prints &quot;super.x=2&quot;<br/>    }<br/>}</pre><br/>User <strong>&#39;Pull members Up&#39;</strong> refactoring for <span class=""monospace"">test()</span> method and move it up into <span class=""monospace"">T2</span> class.<br/>Now program prints <strong>super.x=1</strong>, as access to <span class=""monospace"">super.x</span> left as is instead of being simply <span class=""monospace"">x</span>.</div>
","0"
"IDEA-151061","IntelliJ IDEA","","Rename Class could rename default toString() even without ""Comments & Strings""","Vincent Mallet","30/01/2016 23:16","30/01/2016 23:16",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Food for though on this one:<br/>In the case where the toString() method of a class is generated using the default toString() template, it could be quite convenient to have the Rename Class refactoring also rename the name of the type in the toString() method even when the &quot;Search in comments and strings&quot; option is not enabled.<br/><br/>The reasoning is that &quot;Search in comments and strings&quot; can be unsafe and requires a lot of attention so leaving it out is quite common; however it could be reasonably safe to touch the toString() of the actual class we are renaming especially if it has been generated by IDEA using the default template.<br/><br/>Of course it would violate the &quot;search in comments and strings&quot; option; so maybe it&#39;s a bad idea. Or maybe it could be another option (&quot;special case toString()&quot;) but maybe adding another option is not worth it. <br/><br/>Something to think about :)</div>
","0"
"IDEA-151017","IntelliJ IDEA","reproduced","Package rename refactoring doesn't update all references","Andrew Shulaev","29/01/2016 08:53","29/01/2016 09:57",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Setup: have a Java file like following:<br/><pre class=""wikicode prettyprint"">package com.example;<br/><br/>public class TestOne {<br/>  public static void main(String[] args) {<br/>    System.out.println(&quot;Hello world&quot;);<br/>  }<br/>}</pre>And an XML file, say, src/metadata.xml:<br/><pre class=""wikicode prettyprint"">&lt;link package=&quot;com.example&quot; /&gt;</pre><br/>&quot;com.example&quot; is recognized as a package reference, with autocompletion and Ctrl+Click working. Now, if you&#39;ll go to TestOne.java, point to &quot;example&quot;, invoke rename refactoring and enter &quot;com.example2&quot;, reference in metadata.xml would be updated. However, invoking again with more complex rename, say, to &quot;com.foo.bar.baz&quot;, wouldn&#39;t change metadata.xml.<br/><br/>I would assume that the reason for that is RenamePsiPackageProcessor discarding PsiPackage instance (and, consequently, all references to it) and invokes MoveDirectoryWithClassesProcessor which only operates on directories.</div>
","0"
"IDEA-130038","IntelliJ IDEA","reproduced","""Change signature"" to allow ""final"" parameters","Michael Strelnikov","19/09/2014 00:13","28/01/2016 14:08",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The &quot;Change signature&quot; does not allow &quot;final&quot; parameters.</div>
","0"
"IDEA-150910","IntelliJ IDEA","","Incorrect message in package rename refactoring preview","Andrew Shulaev","27/01/2016 08:55","27/01/2016 14:43",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Setup:<br/>1. Have a class com.example.production.NiceClass<br/>2. Have a non-code occurrence of &quot;com.example.production&quot; (needed for refactoring preview to pop out)<br/>3. Invoke package rename refactoring on &quot;package com.example.production;&quot; line in NiceClass java, enter e.g. &quot;staging&quot; as rename result<br/>4. Get refactoring preview as shown on screenshot<br/><br/>Preview dialog contains text &quot;Directory to be renamed to com.example.staging&quot; (same also occurs down in &quot;References in code to...&quot; text) and there is no such directory. Also, &quot;Package&quot; after a comma in the middle of sentence is capitalized (and probably shouldn&#39;t be)</div>
","0"
"IDEA-150771","IntelliJ IDEA","","Make Extract Variable suggestions show occurrences","Róbert Papp","22/01/2016 12:26","22/01/2016 12:26",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">private void f(List&lt;int[]&gt; lefts, List&lt;int[]&gt; rights) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>for (int i = 0, j = 0; i &lt; lefts.size() || j &lt; rights.size(); ) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int[] left = lefts.get(i);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int[] right = rights.get(j);<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>if (i &lt; lefts.size() &amp;&amp; j &lt; rights.size() &amp;&amp; left[0] == right[0]) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>i++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>j++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>} else if (j &gt;= rights.size() ||  (i &lt; lefts.size() &amp;&amp; j &lt; rights.size() &amp;&amp; left[0] &lt; right[0])) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>i++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>} else if (i &gt;= lefts.size() || i &lt; lefts.size() &amp;&amp; j &lt; rights.size() &amp;&amp; left[0] &gt; right[0]) {<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>j++;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>}<br/>}</pre><br/>When pressing Extract variable where it&#39;s ambigous:<br/><div class=""wiki picture""><img src=""[](image2.png)""/></div><br/>should show how many occurrences can be extracted for that subexpression:<br/><div class=""wiki picture""><img src=""[](image3.png)""/></div><br/>1 occurrence doesn&#39;t need to show, it would just use up space. An alternate wording could be &quot;(and <a href=""/issue/LAB-1"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-2546634"" title=""Centaur: Two-process IntelliJ architecture"">n-1</a> other occurences)&quot;.</div>
","0"
"IDEA-150537","IntelliJ IDEA","","Shift+F6: Class rename that causes file system clash: Error / UX can be improved","Kevin Connor Arpe","17/01/2016 23:04","18/01/2016 12:35",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I use IntelliJ Ultimate 16+ EAP on Windows with Java 8.<br/><br/>When renaming a class, IntelliJ often suggests to rename others.  If a &quot;secondary/suggested&quot; rename causes a file system clash (file already exists), IntelliJ fails the refactoring with a message box.  (See attached image.)<br/><br/>Better: UX can be improved.  IntelliJ can know if rename will cause file system clash.  Either: (1) Avoid suggestion of rename, or (2) provide some strategy / UI for user to resolve issue.  (1) is much easier than (2).<br/><br/>Simple code example:<br/><pre class=""wikicode prettyprint"">File: Base2.java<br/>public interface Base2 { }<br/><br/>File: Base2Impl.java<br/>public final class Base2Impl implements Base {}<br/><br/>File: BaseImpl.java<br/>public final class BaseImpl implements Base {}</pre><br/>If you try to rename Base2 to Base you should see the error.<br/><br/>Intentional: I am marking this as a feature, not a bug.  IntelliJ is still doing the correct thing &ndash; nothing is lost and user gets an error message.  This issue I raise helps to improve UX.  (You may disagree and recategorise if you like.)</div>
","0"
"IDEA-150150","IntelliJ IDEA","","Ctrl+F6 Change Class Signature dialog has weird resize ""animation"" when adding the first generic type parameter","Kevin Connor Arpe","08/01/2016 01:09","08/01/2016 14:32",,"Normal","Cosmetics",,"kb","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I use IntelliJ Ultimate 16+ EAP on Windows with Java 8.<br/><br/>Start with this code:<br/><br/><pre class=""wikicode prettyprint"">    public final class X {<br/>    }</pre><br/><ol class=""wiki-list0""><li> Place cursor on <span class=""monospace"">X</span>, then strike <span class=""monospace"">Ctrl+F6</span> to open Change Class Signature dialog.<br/></li><li> Strike <span class=""monospace"">Alt+Insert</span> to add the first generic type parameter.  Woah... crazy (Java Swing?) resize &quot;animation&quot; happens.  =)</li></ol><br/>This is strictly cosmetic.  The dialog still works correctly.</div>
","1"
"IDEA-144508","IntelliJ IDEA","","Ctrl+F6: Change Signature dialog sometimes ""says"" (via MessageBox) parameter type cannot be resolved","Kevin Connor Arpe","28/08/2015 10:48","08/01/2016 00:56",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Update: I just noticed in my test case, I am changing an impl method in class from an interface.  So the interface file is probably missing the import.<br/><br/>So the trick might be...<br/>Create interface + impl.  Use the type in a private method.  Then try to modify public @Override method signature in impl class.  That woudl require import in interface file... but import already exists in impl class.  Looks like there is a cross wire or two in there... (!)<br/>~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/><br/>I am struggling to replicate this issue, but I definitely see it from time to time.  It <strong>seems</strong> to trigger when I copy paste a &quot;type + name&quot; string from the clipboard into the Type box, then very quickly delete the name (and one space), then strike tab.  Ok, let me try to explain with clear steps.<br/><br/><ol class=""wiki-list0""><li> Copy a &quot;type + name&quot; string on the clipboard.<br/><ul class=""wiki-list1""><li> Example: <code class=""inline-code"">ReutersActiveRsslConfig reutersActiveRsslConfig</code><br/></li></ul></li><li> Make sure the type is already imported into the current class/module.  Important!<br/></li><li> Select any method, move cursor to method name.<br/></li><li> Strike Ctrl+F6 to open Change Signator dialog.<br/></li><li> Strike Alt+Insert to add a new parameter.<br/></li><li> Now the focus is in the <code class=""inline-code"">Type</code> lineedit.<br/></li><li> Strike Ctrl+V to paste the clipboard text (example: <code class=""inline-code"">ReutersActiveRsslConfig reutersActiveRsslConfig</code>)<br/></li><li> Using the keyboard, select the variable name and cut then delete the space.<br/><ul class=""wiki-list1""><li> More exactly... After the paste, your cursor will be at the end of the <code class=""inline-code"">Type</code> lineeedit.<br/></li></ul></li><li> Exact keystrokes: Shift+Left to highlite var name.  Ctrl+X to cut to clipboard.  Backspace to delete one space char.  Tab to jump to <code class=""inline-code"">Name</code> lineedit.<br/></li><li> Now in the <code class=""inline-code"">Name</code> lineedit... Strike Ctrl+V to paste var name.<br/></li><li> Tab to <code class=""inline-code"">Default value</code> lineedit... Again: Strike Ctrl+V to paste var name.<br/></li><li> See image #1.  You should match.  (Var type/name may be slightly diff for you.)<br/><ul class=""wiki-list1""><li> Notice the var type is <strong>not</strong> red (unknown).<br/></li></ul></li><li> Strike Enter to accept new param.<br/></li><li> Using Alt+Up to push to top.  (I don&#39;t really know if this step matters.)<br/></li><li> See image #2.  You should match.  (Var type/name may be slightly diff for you.)<br/></li><li> Strike Alt+R to click <code class=""inline-code"">Refactor</code> button.<br/></li><li> Message box pops up... See image #3.<br/></li><li> Click Cancel twice to click message box and Change signature box.<br/></li><li> Try again... results may vary.</li></ol><br/>Arrrrrgggggg... Of course this is such a tiny issue...  but so tough to replicate!</div>
","0"
"IDEA-150106","IntelliJ IDEA","","Introduce variable fails with exception","Maksim Medvedev","07/01/2016 06:22","07/01/2016 06:22",,"Normal","Exception",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Introducing variable from the following code fails with an exception. <br/><pre class=""wikicode prettyprint"">return  &amp;&amp; &lt;caret&gt;((SwiftExtensionSymbol)targetClassSymbol).getBaseClassSymbol();</pre><br/>I have no idea what is the correct behaviour</div>
","0"
"IDEA-129660","IntelliJ IDEA","","Refactor | Move package: not fail if directory/package already exists","Andrey Dernov","09/09/2014 10:57","28/12/2015 06:52",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I use &#39;move package&#39; on the &#39;com.x&#39; package and move it to &#39;com.y&#39; the result is a &#39;com.y.x&#39; package. We&#39;re trying to merge the &#39;com.x&#39; package into the &#39;com.y&#39; package, meaning that &#39;com.x.somepackage&#39; should become &#39;com.y.somepackage&#39;.<br/><br/>Using the <strong>Move package</strong> we can move each subpackage separately from &#39;com.x&#39; to &#39;com.y&#39;, but that would take a lot of time to execute given the amount of packages residing within the &#39;com.x&#39; package across our whole product (multiple projects).<br/><br/>The rename package&#39;s preview seems to try what we want (rename all &#39;com.x&#39; package(-folders) to &#39;com.y&#39;, across all projects), but it seems that feature cannot cope with already existing target package(-folders).</div>
","2"
"IDEA-149777","IntelliJ IDEA","","Change Signature dialog should have an indicator (colouring?) for unused parameters","Kevin Connor Arpe","24/12/2015 06:59","24/12/2015 15:56",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I use IntelliJ Ultimate 15+ EAP on Windows.<br/><br/>IntelliJ has a very useful feature to color unused ctor/method params in grey text.<br/><br/>Can you also add this to the Change Signature dialog?  (Ctrl+F6)<br/><br/>Why?  We have some ctors with 100+ params (dependency injection).  We can clearly see unused params in the ctor sig when refactoring, but using Ctrl+F6 can be a bit tough with 100+ params.  =)  This is not a bug; a feature request!<br/><br/>See attached screenshot.</div>
","0"
"IDEA-148244","IntelliJ IDEA","","Refactoring Dialogs should not Block Editor","Fabian E","19/11/2015 11:01","19/11/2015 17:07",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When doing a refactoring like <span class=""monospace"">Pull Up</span>, I&#39;d like to examine the code in order to decide which methods I want to pull up. But when the <span class=""monospace"">Pull Up</span> dialog is opened, I cannot scroll the editor window in the back anymore. Enabling this would help a lot.</div>
","0"
"IDEA-147796","IntelliJ IDEA","not reproduced","Refactor extract variable not working in JSP files","Gary Jacobson","11/11/2015 12:06","11/11/2015 14:00",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In a JSP or JSPF file, if I highlight some code and try to extract a variable, it immediately creates the new variable without giving me the option to change the name, but doesn&#39;t replace the highlighted code.<br/><br/>Example JSP file:<br/><br/>&lt;%<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int i = 1;<br/>%&gt;<br/><br/>If I highlight the &quot;1&quot; and invoke the extract variable command, I end up with:<br/><br/>&lt;%<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int i1 = 1;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>int i = 1;<br/>%&gt;<br/><br/>The cursor moves to in front of the i1 but the highlighted &quot;1&quot; remains highlighted.</div>
","0"
"IDEA-147052","IntelliJ IDEA","","Extract Superclass doesn't take generic class param","Romi Kuntsman","29/10/2015 11:17","29/10/2015 11:17",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">1. create class A&lt;T&gt;<br/>2. create method A.foobar<br/>3. put the following code:<br/>    Function&lt;T, Boolean&gt; a = new Function&lt;T, Boolean&gt;() {<br/>      @Override public Boolean call(T v1) throws Exception {<br/>        return null;<br/>      }<br/>    };<br/><br/>4. select the function and then do &quot;Extract Superclass&quot;<br/><br/>actual:<br/>public class aaa extends Function&lt;T, Boolean&gt; {<br/>  public Boolean call(T v1) throws Exception {<br/>    return null;<br/>  }<br/>}<br/>Function&lt;T Boolean&gt; a = new aaa() {};<br/>+ Message saying &quot;At this stage IDEA can analyze usages of null and replace them with...&quot;<br/><br/>expected:<br/>public class aaa&lt;T&gt; extends Function&lt;T, Boolean&gt; {<br/>  public Boolean call(T v1) throws Exception {<br/>    return null;<br/>  }<br/>}<br/>Function&lt;T, Boolean&gt; a = new aaa&lt;T&gt;() {};</div>
","0"
"IDEA-146087","IntelliJ IDEA","","Java quick fixes: can't create new method from usage if any overloads exist","Maksim Medvedev","07/10/2015 06:31","07/10/2015 06:57",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">E.g. I have a method call which is resolved to a method with the same name and inappropriate signature. In such a case I can&#39;t alt+enter &quot;create new method&quot;. <br/>If I invoke &quot;change signature from usage&quot; there is no &quot;delegate via overloading&quot; option in the dialog</div>
","0"
"IDEA-37488","IntelliJ IDEA","","Unwanted 'result' variable as the result of inline method in JSPX","Maxim Shafirov","12/03/2007 16:54","14/09/2015 09:28",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">&lt;jsp:root xmlns:jsp=&quot;<a href=""http://java.sun.com/JSP/Page"" target=""_blank"" rel=""noopener noreferrer"">http://java.sun.com/JSP/Page</a>&quot; xmlns=&quot;<a href=""http://www.w3.org/1999/xhtml"" target=""_blank"" rel=""noopener noreferrer"">http://www.w3.org/1999/xhtml</a>&quot; version=&quot;2.0&quot;&gt;<br/><br/>    &lt;jsp:expression&gt;xxx()&lt;/jsp:expression&gt;<br/><br/>    &lt;jsp:declaration&gt;&lt;![CDATA[<br/>        private boolean xxx() {<br/>            return 1 &lt; 2;<br/>        }<br/>    ]]&gt;&lt;/jsp:declaration&gt;<br/>&lt;/jsp:root&gt;</pre><br/>Inline of xxx() method results in<br/><pre class=""wikicode prettyprint"">&lt;jsp:root xmlns:jsp=&quot;<a href=""http://java.sun.com/JSP/Page"" target=""_blank"" rel=""noopener noreferrer"">http://java.sun.com/JSP/Page</a>&quot; xmlns=&quot;<a href=""http://www.w3.org/1999/xhtml"" target=""_blank"" rel=""noopener noreferrer"">http://www.w3.org/1999/xhtml</a>&quot; version=&quot;2.0&quot;&gt;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;jsp:scriptlet&gt;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>final boolean result = 1 &amp;lt; 2;<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;/jsp:scriptlet&gt;<br/><br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>&lt;jsp:expression&gt;result&lt;/jsp:expression&gt;<br/><br/>    &lt;jsp:declaration&gt;&lt;![CDATA[<br/><span class=""wiki tab"">&nbsp;&nbsp;&nbsp;&nbsp;</span>    ]]&gt;&lt;/jsp:declaration&gt;<br/>&lt;/jsp:root&gt;</pre></div>
","2"
"IDEA-144904","IntelliJ IDEA","","Introduce variable: support Java enhanced 'for' loops","Dmitry Cherniachenko","08/09/2015 10:20","08/09/2015 10:27",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">for (mappings.entrySet()) {<br/><br/>}</pre><br/>Trying to introduce variable for &#39;mappings.entrySet()&#39; creates one outside of the loop. While the most reasonable thing in such case is to change the code to something like:<br/><pre class=""wikicode prettyprint"">for (Map.Entry&lt;String, String&gt; entry : mappings.entrySet()) {<br/><br/>}</pre><br/>P.S. The same transformation could also be added to the QuickFix intentions list to be accessible with Alt+Enter</div>
","0"
"IDEA-57328","IntelliJ IDEA","reproduced","Renaming method does not resolve a conflict","Vladimir Reshetnikov","09/08/2010 06:32","03/09/2015 14:18",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">package pck;<br/><br/>abstract class A{<br/>    abstract int foo(Object x);<br/>    abstract void bar(int x);<br/>    void baz(){<br/>        int x = foo(1);<br/>    }<br/>}</pre><br/>Rename bar to foo. Result:<br/><br/><pre class=""wikicode prettyprint"">abstract class A{<br/>    abstract int foo(Object x);<br/>    abstract void foo(int x);<br/>    void baz(){<br/>        int x = foo(1); // incompatible types<br/>    }<br/>}</pre><br/>Expected:<br/><br/><pre class=""wikicode prettyprint"">package pck;<br/><br/>abstract class A{<br/>    abstract int foo(Object x);<br/>    abstract void foo(int x);<br/>    void baz(){<br/>        int x = foo((Object) 1); // OK<br/>    }<br/>}</pre></div>
","0"
"IDEA-68386","IntelliJ IDEA","not reproduced","Move static method refactoring produces unneeded FQNs","Greg Shrago","18/04/2011 12:41","03/09/2015 14:14",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Moving isSomething() method from:<br/><pre class=""wikicode prettyprint"">a.b.C {<br/>static boolean isSomething();<br/>}</pre><br/>to<br/><br/><pre class=""wikicode prettyprint"">c.d.C {<br/>}</pre><br/>Produces fully qualified calls in every usage: c.d.C.isSomething()</div>
","0"
"IDEA-87538","IntelliJ IDEA","","Introduce parameter can pull the initialization to the call site","Alexander Kirillin","18/06/2012 13:46","03/09/2015 13:24",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">  void f() {<br/>    g();<br/>  }<br/><br/>  void g() {<br/>    &lt;alt-enter&gt;l = 12;<br/>    l ++;<br/>  }</pre><br/>This can be refactored to<br/><br/><br/><pre class=""wikicode prettyprint"">  void f() {<br/>    g(12);<br/>  }<br/><br/>  void g() {<br/>    l ++;<br/>  }</pre><br/>However this one should be kept as it is now:<br/><br/><pre class=""wikicode prettyprint"">  void f() {<br/>    g();<br/>  }<br/><br/>  void g() {<br/>    l ++;<br/>    &lt;alt-enter&gt;l = 12;<br/>  }</pre></div>
","0"
"IDEA-90681","IntelliJ IDEA","","Move refactor ""class will not be accessible"" should offer to add dependencies","Anders Wallgren","27/08/2012 23:03","03/09/2015 13:23",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If I move a class from module A to B and that class is used from module C, it would be nice if the refactor offered to add a dependency from C to B.</div>
","1"
"IDEA-89264","IntelliJ IDEA","","Move member: Add a button for ticking dependencies","Jan Thomä","25/07/2012 11:07","03/09/2015 13:23",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When you move a member of a class the dependencies of this member are already marked in blue, so you see that you need to move with the member. It would be nice if there was a button that ticked all these dependencies automatically.</div>
","1"
"IDEA-144700","IntelliJ IDEA","reproduced,static import","'Encapsulate Fields' refactoring does not work with static imports","Yuriy Yatsyk","02/09/2015 16:28","02/09/2015 16:30",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Try applying &#39;Encapsulate Fields&#39; to the FOO var in class A below. Class B won&#39;t be updated.<br/><br/>class A:<br/><pre class=""wikicode prettyprint"">public class A {<br/>    public static final String FOO = &quot;Foo&quot;;<br/>}</pre><br/>class B:<br/><pre class=""wikicode prettyprint"">import static A.FOO;<br/><br/>public class B {<br/>    public static void main(String... args) {<br/>        System.out.println(FOO);<br/>    }<br/>}</pre></div>
","0"
"IDEA-144587","IntelliJ IDEA","","Control drag to copy files in package explorer tries copying to dependency jars if the target package appears before the actual module","Mitchel Pyl","31/08/2015 14:23","01/09/2015 09:43",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When using the package explorer to copy classes inside a module, with another module appearing before it alphabetically that has a dependency with a package that has the same name, the Copy dialog will incorrectly chose the package inside of a dependency rather than the package inside the module that was selected.<br/><br/>Steps to reproduce:<br/><ul class=""wiki-list0""><li> Create a new empty project<br/></li><li> Switch the project view to package view<br/></li><li> Create a new module (example, abc)<br/></li><li> Create a second new module, note that the name of the second module must come after the first module alphabetically (example, def)<br/></li><li> Create a package in the second module (example, test.idea)<br/></li><li> Create a new class in the new package (example, TestClass1)<br/></li><li> Create a new artifact that takes the compile output of the second module (example name, def.jar)<br/></li><li> Build the new artifact<br/></li><li> Link the built artifact jar file as a dependency (using JARs or directories) for the first module<br/></li><li> Go to the package view and select the first class you made<br/></li><li> Start dragging the class and hold down Ctrl, drag it to the package the class is currently in and when it gets highlighted, release to copy the class to the package under a new name<br/></li><li> The &quot;To directory&quot; will be linked to the artifact output jar, rather than the module source path where the first class is located<br/></li><li> Pressing ok to copy will create a new directory next to the artifact with an added exclamation mark (example, def.jar!), and into a structure that matches the package inside</li></ul><br/>Preferably during the second last step IDEA should try to copy the file to the package of the project that was actually selected, rather than the first instance of it that can be found in the package explorer.<br/><br/>(Side note: the copying to jar files should insert into the jar, rather than creating a new folder with an added exclamation mark)</div>
","0"
"IDEA-144366","IntelliJ IDEA","","Combine ""extract delegate"" and ""extract parameter object""","Jonas Kvarnström","26/08/2015 05:21","26/08/2015 05:21",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If I have a class with a number of fields that I want to extract to a separate class, I can do this with &quot;extract delegate&quot;.  Often these fields are also initialized directly from corresponding constructor parameters that are present in every constructor, and I want the constructor(s) to be modified to also use the new class instead of all of the separate parameters.  I can do this with &quot;extract parameter object&quot; using an &quot;existing class&quot; (the one I just created with &quot;extract delegate&quot;), but that leads to a lot of intermediate steps where I have to repeatedly select parameters to be extracted, make sure they are in the right order, and so on.<br/><br/>I would love to have a simple way to combine these two refactorings so that:<br/><br/><ol class=""wiki-list0""><li> I select a number of fields in class Foo (let&#39;s say &quot;public final int foo; public final double bar;&quot;) to be extracted into a separate class FooParam<br/></li><li> IDEA automatically notices that these fields were initialized directly from constructor parameters:  public Foo(int foo1, double bar2) { this.foo = foo1; this.bar = bar2 }.  Then it can unambiguously see that this constructor call can initialize the new FooParam field (call it x) from <br/></li><li> IDEA asks if I want to use the parameter object for the Foo constructor:  public Foo(FooParam x) { this.x = x; }</li></ol><br/>This is related to <a href=""/issue/IDEA-144364"" target=""_self"" data-issue-id=""25-1003794"" title=""&quot;Extract delegate&quot;:  Better handling of constructors, final fields"">IDEA-144364</a> &ndash; the difference is that here I want to go a step further and change the parameters of the original constructor(s), so that the call to &quot;new FooParam()&quot; is made by those who call Foo(), not inside Foo().</div>
","0"
"IDEA-142705","IntelliJ IDEA","","CodeSnippet (Java): Refactoring ""Extract Variable"" fails","Romeo Frenksen","16/07/2015 03:39","18/08/2015 15:07",,"Normal","Bug",,"jeka","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Using the following code below in a <strong>Java Code Scratch</strong> (CTRL+ALT+SHIFT+INSERT), the refactoring &quot;Extract Variable&quot; produces an error: <br/><br/><pre class=""wikicode prettyprint"">class Junk {<br/>    public static void main(String[] args) {<br/>        Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4sdsd&quot;, &quot;kdjkdfjdl&quot;)<br/>    }<br/>}</pre><br/><div class=""wiki picture""><img src=""[](image2.png)""/></div></div>
","0"
"IDEA-143429","IntelliJ IDEA","reproduced","Extract Variable refactoring doesn't validate identifier name","Eugene Auduchinok","03/08/2015 14:59","04/08/2015 05:39",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I use Rename refactoring, it validates names after renamed. But when I extract variable it allows me to set name like &quot;``&quot; which is not a proper behaviour.</div>
","1"
"IDEA-142874","IntelliJ IDEA","reproduced","Refactor / Move: import statement can be removed on moving a class into referred package","Alexander Chernikov","20/07/2015 14:39","20/07/2015 14:39",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Create two classes in different packages:<br/><div class=""java code title"">ImportJavaReferred.java</div><pre class=""wikicode prettyprint"">package removeImport.from;<br/>public class ImportJavaReferred {} </pre><div class=""java code title"">ImportJavaReferrer.java</div><pre class=""wikicode prettyprint"">package removeImport.to;<br/>import removeImport.from.ImportJavaReferred;<br/>public class ImportJavaReferrer {<br/>    public void refer(ImportJavaReferred p) {}<br/>} </pre>Refactor / Move <code class=""inline-code"">ImportJavaReferred</code> to package <code class=""inline-code"">removeImport.to</code>: import statement in <code class=""inline-code"">ImportJavaReferrer</code> is removed. Ok.<br/>Undo changes.<br/>Refactor / Move <code class=""inline-code"">ImportJavaReferrer</code> to package <code class=""inline-code"">removeImport.from</code>: import statement is not removed.<br/>It seems to be possible to remove the import? Anyway, after the move import is the same to package statement.<br/>142.3230.1</div>
","0"
"IDEA-142771","IntelliJ IDEA","reply needed","'Safe Delete' and 'Rename' refactorings search for strings only in modules which depends on current module","Nikolay Chashnikov","17/07/2015 06:47","19/07/2015 08:15",,"Major","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Suppose that I have two modules: &#39;a&#39; and &#39;b&#39;, and the following classes in them:<br/>a/src/xxx/Foo.java:<br/><pre class=""wikicode prettyprint"">package xxx;<br/>public class Foo {<br/>    public Foo() throws ClassNotFoundException {<br/>        Class.forName(&quot;xxx.Bar&quot;);<br/>    }<br/>}</pre>b/src/xxx/Bar.java:<br/><pre class=""wikicode prettyprint"">package xxx;<br/>public class Bar {}</pre>If I invoke &#39;Safe Delete&#39; on &#39;Bar&#39; class and tick &#39;Search in comments and strings&#39; option IDEA will not warn me about usage in &#39;Foo&#39; if &#39;a&#39; module doesn&#39;t depend on &#39;b&#39;. Probably we should search for non-code occurrences in the whole project. &#39;Rename&#39; refactoring on &#39;Bar&#39; also won&#39;t rename usage in module &#39;a&#39;.</div>
","0"
"IDEA-142824","IntelliJ IDEA","","I would like more options for variable names","Viktor Alenkov","19/07/2015 07:35","19/07/2015 07:35",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Using static methods, I would like to Refactoring &quot;allocate variable&quot; (Ctrl + Alt + V), offered options are not only based on the name of the called method or type of the variable, but based on the name passed to the method.<br/><br/>For example screenshot The figure would be in the proposed list of potential names to see the variable name of &quot;preorder&quot;<br/><br/>using method: <a href=""https://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/BooleanUtils.html#toBoolean%28java.lang.Boolean%29"" target=""_blank"" rel=""noopener noreferrer"">https://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/BooleanUtils.html#toBoolean%28java.lang.Boolean%29</a><br/><br/><div><details class=""wiki-details""><summary class=""wiki-cut-title"">russian text</summary>Хочется больше вариантов для имён переменных<br/><br/>Используя статические методы, хотелось бы, чтобы при рефакторинге &quot;выделить в переменную&quot; (Ctrl+Alt+V), предлагались варианты не только на основе имени вызываемого метода или типа переменной, но и на основе имени передаваемого метода.<br/><br/>Например на приведённом скрине хотелось бы в предложенном списке потенциальных имён переменной увидеть имя &quot;preorder&quot;</details></div></div>
","0"
"IDEA-122400","IntelliJ IDEA","","Refactor action for Demeter style statements","Brice Dutheil","18/03/2014 15:44","10/07/2015 17:31",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Suppose I have a code like that, that breaks the Demeter law :<br/><br/><pre class=""wikicode prettyprint"">if (!scanner.lineArray().isEmpty()) {<br/>    // ...<br/>}</pre><br/>I think it would be reasonable quick action / refactor action when the cursor is somewhere on the following statement <span class=""monospace"">!scanner.lineArray().isEmpty()</span> to propose to <em>push down</em> this code in a <em>Tell, Don&#39;t Ask</em> fashion to the <span class=""monospace"">Scanner</span> object. (<span class=""monospace"">Scanner</span> is a custom type)<br/><br/>So you&#39;ll have after this refactoring the following code :<br/><br/><pre class=""wikicode prettyprint"">if (scanner.hasNewLines()) {<br/>    // ...<br/>}</pre><br/><pre class=""wikicode prettyprint"">class Scanner {<br/>    // ...<br/>    public boolean hasNewLines() {<br/>        return !lineArray.isEmpty()<br/>    }<br/>}</pre></div>
","2"
"IDEA-142130","IntelliJ IDEA","reproduced","Refactoring ""Extract... Delegate"" not allowed on enums","Romeo Frenksen","01/07/2015 03:58","01/07/2015 08:36",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently it&#39;s no problem to use the refactoring &quot;Delegate&quot; on method &quot;doSomethingElse&quot; from the following class<br/><br/><pre class=""wikicode prettyprint"">class JUNK {<br/><br/>    public void doSomething() {<br/>        doSomethingElse();<br/>    }<br/><br/>    public void doSomethingElse() {<br/>        System.out.println(&quot;bar&quot;);<br/>    }<br/><br/>}</pre><br/>Repeating &quot;Delegate...&quot; on enums (see below) stops with <strong>Can not perform refactoring. The selected class is an enumeration</strong>.<br/><br/><pre class=""wikicode prettyprint"">enum JUNK {<br/>    INSTANCE;<br/><br/>    public void doSomething() {<br/>        doSomethingElse();<br/>    }<br/><br/>    public void doSomethingElse() {<br/>        System.out.println(&quot;bar&quot;);<br/>    }<br/><br/>}</pre><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>Actually, I am wondering why this is not allowed. Could you please elaborate on this?</div>
","0"
"IDEA-141668","IntelliJ IDEA","windows","[14.0.2] Renaming a package on Windows doesn't rename the underlying folder if only capitalization (myPackage -> mypackage) is changed","Christian Balzer","19/06/2015 06:36","23/06/2015 09:15",,"Normal","Bug",,"roman.shevchenko","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Renaming myPackage to mypackage using IntelliJ&#39;s Refactor options on Windows will change all package references, but not the actual directories. This is presumably because for Windows, the two folder names are identical. IntelliJ should either warn that renaming a package will not work for the underlying directories if only the capitalization is changed on Windows, or first rename to a temporary folder/package name and then to the final name. (My colleague got a question from IntelliJ asking if he wanted to rename the package or the folder; he selected the package. Not sure that had anything to do with it.)</div>
","0"
"IDEA-141633","IntelliJ IDEA","","IV from ""collection.iterator().next()"": suggest ""firstCollectionType"" as variable name","Taras Tielkes","18/06/2015 09:18","18/06/2015 09:18",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When creating a variable from the pattern &quot;<span class=""monospace"">collection.iterator().next()</span>&quot;, it would be nice if IDEA added a name suggestion for &quot;<em>first{CollectionType}</em>&quot;.<br/><br/>For example:<br/><pre class=""wikicode prettyprint"">Set&lt;Date&gt; dates = ...;<br/>dates.iterator().next()&lt;caret&gt;</pre><br/>Invoking IV at caret location would contribute a name suggestion of &quot;<span class=""monospace"">fistDate</span>&quot;.</div>
","0"
"IDEA-141622","IntelliJ IDEA","reproduced","Extract Variable generates red code","Bas Leijdekkers","18/06/2015 07:01","18/06/2015 07:04",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Introduce a variable for the getClass() expression below:<br/><pre class=""wikicode prettyprint"">class LocalClasses {<br/>  void f() {<br/>    class A {<br/>      class B {<br/>      }<br/>    }<br/>    new A().new B().getClass();<br/>  }<br/>}</pre><br/>Result:<br/><pre class=""wikicode prettyprint"">class LocalClasses {<br/>  void f() {<br/>    class A {<br/>      class B {<br/>      }<br/>    }<br/>    final Class&lt;? extends B&gt; aClass = (Class&lt;? extends B&gt;) new A().new B().getClass();<br/>  }<br/>}</pre>The unqualified B reference does not compile.<br/><br/>Expected result:<br/><pre class=""wikicode prettyprint"">class LocalClasses {<br/>  void f() {<br/>    class A {<br/>      class B {<br/>      }<br/>    }<br/>    final Class&lt;? extends A.B&gt; aClass = new A().new B().getClass();<br/>  }<br/>}</pre></div>
","0"
"IDEA-141452","IntelliJ IDEA","","Rename code-only references action for Refactoring Preview dialog","Eugene Petrenko","15/06/2015 07:10","15/06/2015 09:38",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Recently I see the following UI to confirm rename<br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>I with I have an action around called: <span class=""monospace"">Just rename code references</span>. In most cases <br/><ul class=""wiki-list0""><li> I do not care about non-code usages<br/></li><li> The UI is show is to complicated and thus breaks current activity flow<br/></li><li> I click cancel and perform the refactoring manually<br/></li></ul></div>
","0"
"IDEA-132233","IntelliJ IDEA","","""Replace Constructor with Builder"" refactoring improvement","Laszlo Balazs-Csiki","01/11/2014 04:35","12/06/2015 09:27",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently the &quot;Replace Constructor with Builder&quot; refactoring creates an external class, and although it replaces the calls of the constructor, it does not replace the constructor itself. Instead, an improvement would be if the user could generate a static internal builder class and the original constructor would be made private. See Item 2 in the &quot;Effective Java&quot; book for an example.</div>
","3"
"IDEA-141304","IntelliJ IDEA","","Refactor/use interface where possible works incorrectly for EnumSet","Irina Petrovskaya","10/06/2015 04:37","10/06/2015 04:37",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">142.2327<br/><br/>as a result of any refactoring (extract interface, use interface where posible) the enum usage is substituted with interface implemented by this enum<br/><pre class=""wikicode prettyprint"">public enum Bar implements BarInterface {...}<br/>...<br/> EnumSet&lt;Bar&gt; bars = EnumSet.allOf(Bar.class);</pre>you get<br/><pre class=""wikicode prettyprint"">public enum Bar implements BarInterface {...}<br/>...<br/> EnumSet&lt;BarInterface&gt; bars = EnumSet.allOf(Bar.class);</pre></div>
","0"
"IDEA-140893","IntelliJ IDEA","reproduced","Add refactor option: wrap specific return type in Optional when returning Optional.empty","Henrik Huttunen","30/05/2015 08:03","30/05/2015 08:07",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">String foobar() {<br/>  return Optional.empty();<br/>}</pre><br/>alt+enter suggest that Make &#39;foobar&#39; return java.util.Optional&lt;T&gt; but it should also(?) suggest as the first option to return java.util.Optional&lt;String&gt;<br/><br/>The current suggestion is bad because the code ends up statically incorrect.<br/><br/><pre class=""wikicode prettyprint"">Optional&lt;T&gt; foobar() {<br/>    return Optional.empty();<br/>}</pre><br/>but should be<br/><br/><pre class=""wikicode prettyprint"">Optional&lt;String&gt; foobar() {<br/>    return Optional.empty();<br/>}</pre></div>
","0"
"IDEA-140892","IntelliJ IDEA","","Add new refactor action `create class with constructor and fields`","Henrik Huttunen","30/05/2015 07:08","30/05/2015 07:36",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Support generating a new class from a use-site constructor invocation.<br/>That should create the class, constructor and fields in one refactor action.<br/><br/>There should also be option to generate the fields as public and/or final.<br/><br/>Motivation: we have a module-wide default that data-transfer-objects have fields declared with <code class=""inline-code"">public final</code> attributes.<br/>When generating constructor, one needs always to replace-and-find the private fields. This is unsatisfactory situation.<br/><br/>No class <code class=""inline-code"">Foobar</code> exists before this.<br/><pre class=""wikicode prettyprint"">int v = 3;<br/>new Foobar(v)</pre><br/>&lt;refactor happens here&gt; and the following is the result<br/><br/><pre class=""wikicode prettyprint"">public final class Foobar {<br/>   public final int v;<br/><br/>   Foobar(int v) {<br/>     this.v = v;<br/>   }<br/>}</pre><br/>Note that constructor parameter is not final - which would be unnecessary obfuscation.<br/>The configuration of how exactly the default generation goes should belong to Preferences -&gt; Editor -&gt; Code style -&gt; Java -&gt; Code generation [tab].</div>
","0"
"IDEA-140022","IntelliJ IDEA","","Rename parameters dialog: edit variable name via keyboard","Greg Shrago","06/05/2015 16:09","06/05/2015 16:10",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">F2, Shift Enter, F4 do not work.<br/><br/>Also toolbar &quot;under gear&quot; action(s) seems to be too difficult to reach by mouse.</div>
","0"
"IDEA-139796","IntelliJ IDEA","reply needed","Improve Renaming support","Yaroslav Bedrov","29/04/2015 06:37","06/05/2015 05:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When a software entity (e.g., a field) is renamed for some reason (e.g., correcting a typo), it likely that other related and similar entities should be renamed accordingly. The rationale is that if an engineer makes a mistake in naming a software entity it is likely for her to make the same mistake in naming similar and closely related software entities. However, existing renaming tools, e.g., Visual studio and Eclipse, could not suggest developers to rename such related entities.<br/><br/>To solve this problem, we have proposed an approach. The approach is presented in the attached paper which was accepted for publication by IEEE Transactions on Software Engineering a few days ago.<br/><br/>Our evaluation results (on open-source applications) show that the proposed approach is accurate in recommending entities to be renamed (average precision 82%) and in recommending new names for such entities (average precision 93%). Evaluation results also suggest that a substantial percentage (varying from 20% to 23%) of rename refactorings are expansible.<br/><br/>We hope that this could be implemented in IntelliJ that is widely accepted as the smartest IDE. An prototype implementation for Eclipse is available at <a href=""http://sei.pku.edu.cn/~liuhui04/tools/rename/"" target=""_blank"" rel=""noopener noreferrer"">http://sei.pku.edu.cn/~liuhui04/tools/rename/</a></div>
","1"
"IDEA-139793","IntelliJ IDEA","","Refactor - Rewrite statements","Filip Bellander","29/04/2015 05:09","29/04/2015 05:27",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">If I have some for, if, while, w/e-statements that are nested and contain similar code, I would like to have a &quot;Refactor statement&quot;-option.<br/>I imagine this function to help rewrite duplicate code to make it more effective. I realise this is quite hard to do though. <br/>But as an example:<br/><pre class=""wikicode prettyprint"">for(int i=0; i&lt;n; i++){<br/>  if(x == k){<br/>    doStuff();<br/>  }<br/>}</pre><br/>This for-loop shouldn&#39;t have to run if x != k, so the refactor function should <em>suggest</em> the alternative<br/><br/><pre class=""wikicode prettyprint"">if(x == k){<br/>  for(int i=0; i&lt;n; i++){<br/>    doStuff();<br/>  }<br/>}</pre><br/>This is a very basic example, but it could be very handy when you have an unwieldy block of code that you need to make sense of (like in my instance when you have legacy code from 2003 that you need to clean up...). Or when you are trying to weed out bottlenecks.</div>
","0"
"IDEA-138913","IntelliJ IDEA","","Why cant I perform a simple directory move within the Project window without IntelliJ screwing everything up?","Nick Pratt","07/04/2015 19:36","24/04/2015 08:13",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">This issue has been around for years.  When is it going to be addressed?<br/><br/>Take a single directory in the project window within a single module in a multi module project.  Drag it somewhere else within the same module.<br/><br/>IntelliJ screws this up every time - it either wants to rename and move the entire project tree, affecting similarly named packages in <strong>all</strong> modules, or it performs some screwed up move and leaves all the class packages and references to the moved classes with the old package name.  Every single time I try to do some as simple as this I end up having to revert the change set and drop to the command line and then process all the package names manually. </div>
","0"
"IDEA-139229","IntelliJ IDEA","","Move annotation within class hierarchy refactoring","Павлухин Иван","15/04/2015 05:05","15/04/2015 05:05",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Hi,<br/><br/>Recently I have faced a problem to move annotations from interface to implementation. Unfortunately I could not find such possibility in Intellij IDEA.<br/><div class=""java code title"">Example</div><pre class=""wikicode prettyprint"">public interface Interface {<br/>  @Secured(&quot;ROLE_ADMIN&quot;)<br/>  void foo();<br/>}<br/>public class Implementation implements Interface {<br/>  public void foo() {}<br/>}</pre>And a desired feature is an possibility to select a method and choose something like &quot;Push annotations down&quot; from Refactor menu. The expected result is:<br/><div class=""java code title"">After refactoring</div><pre class=""wikicode prettyprint"">public interface Interface {<br/>  void foo();<br/>}<br/>public class Implementation implements Interface {<br/>  @Secured(&quot;ROLE_ADMIN&quot;)<br/>  public void foo() {}<br/>}</pre>Also it is not only about annotations on methods, but there could be a same refactoring for annotation on class/interface level and for annotated method arguments.<br/>Such refactoring could extremely simplify cases when you need to move lots of annotations in, for example, Spring based projects. Good candidates for such refactoring could be annotations @Component, @Service, @Secured.</div>
","0"
"IDEABKL-7176","IntelliJ IDEA: Backlog","","Don't show 'Rename base method action' for overridden method if the base method is located in third-party jar outside of project","Сергей Цыпанов","01/04/2015 05:10","01/04/2015 06:41",,"Normal","Cosmetics","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">subj</div>
","0"
"IDEA-138379","IntelliJ IDEA","","Add new refactoring: Delegate method to field","David Frank","27/03/2015 10:36","28/03/2015 10:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Assume, you have a class which has reference to another class and contains one or more methods/attributes.<br/><br/><pre class=""wikicode prettyprint"">class MyController {<br/>    private static final int ANSWER = 42;<br/>    private MyService service;<br/><br/>    public int getAnswer() {<br/>        return ANSWER;<br/>    }<br/>}</pre><br/>In this situation a very useful refactoring would be if one could easily move the logic of getAnswer to MyService, while MyController.getAnswer would change to:<br/><br/><pre class=""wikicode prettyprint"">public int getAnswer() {<br/>    return service.getAnswer();<br/>}</pre><br/>Of course, if the method has dependencies (static field ANSWER in the above case), those should be moved as well. The IDE could find the transitive closure and mark all involved fields and methods, similarly to the current Extract delegate class refactoring.</div>
","0"
"IDEA-137817","IntelliJ IDEA","javadoc","ChangeSignature refactoring: parameter propagating should update javadoc for all affected methods","Irina Petrovskaya","18/03/2015 10:02","18/03/2015 10:02",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">141.174.3<br/><br/><pre class=""wikicode prettyprint"">     /**<br/>     * method m1:<br/>     */<br/>    public void m1() {<br/><br/>    }<br/><br/>    /**<br/>     * method m2:<br/>     */<br/>    public void m2() {<br/>        m1();<br/>    }</pre>use Change Signature refactoring to add parameter to m1(); select also to propagate this parameter to m2().<br/>Results: parameter is added to both methods, but @param tag is inserted to the m1() method javadoc only<br/><pre class=""wikicode prettyprint"">/**<br/>     * method m1:<br/>     * @param arg1<br/>     */<br/>    public void m1(int arg1) {<br/><br/>    }<br/><br/>    /**<br/>     * method m2:<br/>     */<br/>    public void m2(int arg1) {<br/>        m1(arg1);<br/>    }</pre></div>
","0"
"IDEA-135819","IntelliJ IDEA","","Deep Make Static: ""Replace instance qualifier with class reference"" works only for the first level of depth","Victoria Dumova","30/01/2015 13:05","13/03/2015 11:21",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build 140.2032</strong><br/><br/><pre class=""wikicode prettyprint"">public class DeepDeepReplaceInstance {<br/>    public void callee() {}<br/>}<br/><br/>class Test {<br/>    public void caller(DeepDeepReplaceInstance clazz) {<br/>        new DeepDeepReplaceInstance().callee();<br/>        clazz.callee();<br/>    }<br/>    public void callCaller(Test clazz) {<br/>        new Test().caller(null);<br/>        clazz.caller(null);<br/>    }<br/>}</pre><br/>Do Refactor -&gt; Make Static for <strong>callee</strong>.<br/>Agree to replace instance qualifiers.<br/>Select <strong>caller</strong> and <strong>callCaller</strong> to propagate static.<br/><br/>Result - instance qualifiers are replaced only in <strong>caller</strong>:<br/><br/><pre class=""wikicode prettyprint"">public class DeepDeepReplaceInstance {<br/>    public static void callee() {}<br/>}<br/><br/>class Test {<br/>    public static void caller(DeepDeepReplaceInstance clazz) {<br/>        DeepDeepReplaceInstance.callee();<br/>        DeepDeepReplaceInstance.callee();<br/>    }<br/>    public static void callCaller(Test clazz) {<br/>        new Test().caller(null);<br/>        clazz.caller(null);<br/>    }<br/>}</pre></div>
","1"
"IDEA-137580","IntelliJ IDEA","","MakeStatic intention could perform cascade refactoring","Irina Petrovskaya","12/03/2015 13:11","13/03/2015 10:37",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">141.132<br/><br/>if you invoke Refactor/makeStatic for the m1() method, you get prompted to select methods m2() and m3() to propagate static.<br/>However, if you invoke MakeStatic intention for the m1() call in main(), you get no such possibility<br/><pre class=""wikicode prettyprint"">public void m1() {}<br/><br/>    public void m2() { m1(); }<br/><br/>    public void m3() { m2();}<br/><br/>    public static void main(String[] args) { <br/>         m1();<br/>    }</pre></div>
","0"
"IDEABKL-7166","IntelliJ IDEA: Backlog","","Refactoring preview changes to find preview after altering action settings","Diego Vilar","04/03/2015 16:21","10/03/2015 13:37",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">When previewing the changes of a refactor/rename action, as in<br/><br/><div class=""wiki picture""><img src=""[](image.png)""/></div><br/><br/>... if we try to edit the settings of the action to, for instance, limit to a given scope, as in<br/><br/><div class=""wiki picture""><img src=""[](image2.png)""/></div><br/><div class=""wiki picture""><img src=""[](image3.png)""/></div><br/><br/>... the results window is of a search operation, and thus the refactoring controls are not presented anymore, as in the image below<br/><br/><div class=""wiki picture""><img src=""[](image4.png)""/></div></div>
","0"
"IDEABKL-7161","IntelliJ IDEA: Backlog","","change signagure when extracting method","Chad Daniels","13/02/2015 14:51","23/02/2015 09:20",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Please add the ability to change the method signature when extracting a method.</div>
","0"
"IDEA-135759","IntelliJ IDEA","reproduced","Safe Delete: Deep Delete Parameter is not suggested for vararg parameters","Victoria Dumova","29/01/2015 08:35","29/01/2015 10:21",,"Minor","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>Build 140.2013</strong><br/><br/><pre class=""wikicode prettyprint"">void calleeVararg(String... names) {}<br/><br/>void caller(String... names) {<br/>    calleeVararg(names);<br/>}</pre><br/>Safe delete <strong>calleeVararg</strong> parameter - it will be deleted without suggestion to propagate parameter deletion to <strong>caller</strong>.</div>
","0"
"IDEABKL-7144","IntelliJ IDEA: Backlog","","Ctrl+Alt+N hit on a constructor should attempt to inline that constructor, not class","Yuriy Yatsyk","07/01/2015 15:46","08/01/2015 09:02",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">If the constructor is only invoked locally (private), it should be possible to inline it by hitting Ctrl+Alt+N.</div>
","0"
"IDEA-42396","IntelliJ IDEA","","Refactoring / Extract include file creates files in default encoding, not in container file's encoding","Alexander Chernikov","25/12/2007 15:24","29/12/2014 13:30",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Create a JSP in non-default encoding (tested UTF-16BE). I believe, the way to set encoding does not play a part here.<br/>Select some non-ASCII text (like Russian) and do Refactor / Extract include file.<br/>Resulted file is created with default encoding (UTF-8 in my case).<br/>In runtime, the text of extracted fragment, included into main page is not readable. Bug.<br/>So, Refactor / Extract include file should better create files in the same encoding like in parent file. The later actions are up to user.<br/><br/>Notice, that this request is correct for JSP, but not for Java. Java &quot;extract&quot; refactorings are working the same way now, but this is Ok, I think.</div>
","0"
"IDEA-134817","IntelliJ IDEA","","Improve ""Create constant"" action","Сергей Цыпанов","26/12/2014 12:35","29/12/2014 09:51",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have several equal string literals in my code. When I try to make them private static final with Ctrl+Alt+C IDEA replaces only selected literal.<br/><br/>Shouldn&#39;t it replace all occurrences of equal literals with constant field?</div>
","0"
"IDEA-59908","IntelliJ IDEA","","Change signature: choose methods to propagate parameters/exceptions: use JB Tree with background loading instead of JTree","Kirill Safonov","15/10/2010 12:18","23/12/2014 15:35",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">currently callers are calculated in EDT</div>
","0"
"IDEABKL-7136","IntelliJ IDEA: Backlog","","Allow multi-extract/inline variables","david denton","20/11/2014 15:46","18/12/2014 15:33",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Context: When using the extract method refactoring, it&#39;s common to extract variables before doing extract methods, so that IntelliJ knows how the new method should be parameterised and find similar code blocks to replace with calls to the new method.  <br/><br/>To make this process easier and quicker, allow the user to widen the scope to include multiple variables (Ctrl+W), then perform an extract variable (Ctrl+V). IntelliJ would just extract all of the variables to the lines directly above the selection, using the existing &quot;name extracted variable&quot; flow. After the method extraction, user selects all of the extracted args and inlines them in a single operation (Ctrl+N).<br/><br/>An example:<br/><br/>Beer beer = getBeer(2, &quot;Pale Ale&quot;);<br/>beer.drink();<br/>Beer beer = getBeer(3, &quot;Guiness&quot;);<br/>beer.drink();<br/><br/>&lt;User selects &#39;2, &quot;Pale Ale&quot;&#39; and hits Ctrl+V - names each var in turn&gt; <br/><br/>int numberOfPints = 2;<br/>String beerName = &quot;Pale Ale&quot;;<br/>Beer beer1 = getBeer(numberOfPints, beerName);<br/>beer1.drink();<br/>Beer beer2 = getBeer(3, &quot;Guinness&quot;);<br/>beer2.drink();<br/><br/>&lt;User can then extract method (Ctrl+M) and use the auto-replace (getAndDrinkBeer(int, String) - not shown)&gt;<br/><br/>int numberOfPints = 2;<br/>String beerName = &quot;Pale Ale&quot;;<br/>getAndDrinkBeer(numberOfPints, beerName);<br/>getAndDrinkBeer(3, &quot;Guinness&quot;);<br/><br/>&lt;User selects &#39;numberOfPints, beerName&#39; and hits Ctrl+N&gt;<br/><br/>getAndDrinkBeer(2, &quot;Pale Ale&quot;);<br/>getAndDrinkBeer(3, &quot;Guinness&quot;);</div>
","9"
"IDEA-133829","IntelliJ IDEA","","Drag-and-drop parameters in Refactor Method Signature messes up parameter order","Andrey Dernov","03/12/2014 10:47","03/12/2014 11:19",,"Normal","Bug",,"kb","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Drag-and-dropping parameters in a method Change Signature refactor window messes up the order of the parameters.<br/><br/>Example: <br/>1) method signature is now &quot;public void demo(Object filter, Object object1, Object object2);&quot; <br/>2) I want to move the filter parameter to the end <br/>3) right click on method, Refactor, Change Signature <br/>4) Parameters tab shows a list with &quot;Object filter&quot;, &quot;Object object1&quot;, &quot;Object object2&quot;, in this order <br/>5) Drag &quot;Object filter&quot; and drop it at the end of the list<br/><br/>Expected: Parameter tab shows the new list order &quot;Object object1&quot;, &quot;Object object2&quot;, &quot;Object filter&quot; <br/>Actual: Parameter tab shows the new list order &quot;Object object2&quot;, &quot;Object object1&quot;, &quot;Object filter&quot; (note that object1 and object2 positions were flipped)</div>
","1"
"IDEA-133022","IntelliJ IDEA","","Refactor -> Rename doesn't receive focus","Igor Stamatovski","17/11/2014 15:54","25/11/2014 08:27",,"Normal","Bug",,"Sergey_Malenkov","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">To reproduce use ubuntu and screen resolution 1366x768.<br/>Right click on a class from the project explorer.<br/>Choose Refactor from the context menu (second context menu appears and draws itself little above active Intellij window)<br/>on the second context menu &#39;Rename&#39; is first item in the menu and is unselectable.<br/>Every other menu item is sellectable.<br/><br/>This doesnt happen if screen resolution is larger like FHD because there is plentu of space for the seccond menu to be drawn well below active intellij window.<br/><br/>Couldnt get any screenshot while the menu was active since it takes over the keyboard.</div>
","0"
"IDEABKL-7120","IntelliJ IDEA: Backlog","","Generate javadoc for builder class","Yaroslav Bedrov","08/11/2014 07:04","14/11/2014 14:11",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">It would be good to be able to autogenerate a Javadoc comment for the generated Builder class. Even something simple like &quot;Builder class for {<a href=""https://youtrack.jetbrains.com/users/link"" title=""link"" data-user-id=""11-5340"">Ilya Kazakevich</a> BaseClass}&quot; would be nice.</div>
","0"
"IDEA-122471","IntelliJ IDEA","","Can't extract variable","Dumitru Postoronca","19/03/2014 10:30","23/10/2014 11:40",,"Normal","Bug",,"roman.shevchenko","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">// this works:<br/>new ZipFile(&quot;file.zip&quot;).getInputStream()&lt;caret&gt;<br/><br/>// this doesn&#39;t suggest anything<br/>try (new ZipFile(&quot;file.zip&quot;).getInputStream()&lt;caret&gt;) {<br/>}</pre></div>
","1"
"IDEA-131184","IntelliJ IDEA","","Offer to rename variable on method usages after renaming a parameter","Áxel Costas Pena","12/10/2014 16:38","12/10/2014 16:38",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Have class A:<br/><pre class=""wikicode prettyprint"">class A {<br/>    public foo(String bar, String baz) {<br/>    }<br/>}</pre>and class B which calls A&#39;s method:<br/><pre class=""wikicode prettyprint"">class B {<br/>    public afoo() {<br/>        A a = new A();<br/>        String bar = &quot;bar&quot;;<br/>        String baz = &quot;baz&quot;;<br/>        a.foo(bar, baz);<br/>    }<br/>}</pre><br/>Invoke rename on class A, method foo, parameter bar. Rename bar to anotherbar.<br/>While renaming it could be shown a tooltip with a checkbox (simmilar to what is shown on screenshot) which offers to rename related variables on mathod invocations.<br/>If the user checks the checkbox, any method call which uses a variable which has the same variable name as the parameter name will be renamed.<br/><br/>Result:<br/><pre class=""wikicode prettyprint"">class A {<br/>    public foo(String anotherbar, String baz) {<br/>    }<br/>}</pre>and class B which calls A&#39;s method:<br/><pre class=""wikicode prettyprint"">class B {<br/>    public afoo() {<br/>        A a = new A();<br/>        String anotherbar= &quot;bar&quot;;<br/>        String baz = &quot;baz&quot;;<br/>        a.foo(anotherbar, baz);<br/>    }<br/>}</pre></div>
","1"
"IDEA-129773","IntelliJ IDEA","reproduced","Drag-and-drop Java packages UX is a little confusing","Kevin Connor Arpe","12/09/2014 05:29","29/09/2014 03:48",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The third attached image is confusing.  If I did a drag-and-drop, why is IntelliJ asking me about the destination directory?  It should be obvious.  Every new user that I train on IntelliJ looks confused and nervous the first time they see this dialog. &quot;Did I do something wrong?&quot;  &quot;Why is IntelliJ asking me for the destination folder in a drag-and-drop action?&quot;</div>
","0"
"IDEA-129330","IntelliJ IDEA","","Allow multiple methods to be moved at the same time during Move Instance Methods refactoring","Matt Nathan","01/09/2014 10:38","01/09/2014 10:41",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It would save a lot of time if it were possible to move more than one method at a time from one instance to another. Specifically I&#39;d like to move an instance method and all called methods from one class to another.<br/><br/>Without this feature a lot of visibility changes and manual code cleanup is needed to undo code needed when only one method is moved but not needed when all associated methods are all in the same class.<br/><br/>Something like the dialog for pull member up would be great.</div>
","2"
"IDEA-127294","IntelliJ IDEA","","Exception in IDEA Core","Сергей Цыпанов","14/07/2014 17:25","15/07/2014 14:52",,"Normal","Auto-reported Exception",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">After this error occured pressing Alt+Enter just moves carret into the next string and no auto-complete is showed.<br/><br/>Also see diagnostics.txt<br/><br/>Element: class com.intellij.psi.impl.source.PsiClassImpl because: parent is null<br/>invalidated at: see attachment<br/>com.intellij.psi.PsiInvalidElementAccessException: Element: class com.intellij.psi.impl.source.PsiClassImpl because: parent is null<br/>invalidated at: see attachment<br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">&nbsp;<b>at</b> com.intellij.psi.impl.PsiElementBase.getContainingFile(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiElementBase.java"" lne=""236"" title=""Open in IDE"">PsiElementBase.java:236</a>)</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(<a class=""dsLink"" txt=""com/intellij/extapi/psi/StubBasedPsiElementBase.java"" lne=""187"" title=""Open in IDE"">StubBasedPsiElementBase.java:187</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiElementBase.getContainingFile(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiElementBase.java"" lne=""237"" title=""Open in IDE"">PsiElementBase.java:237</a>)<br/>&nbsp;<b>at</b> com.intellij.extapi.psi.StubBasedPsiElementBase.getContainingFile(<a class=""dsLink"" txt=""com/intellij/extapi/psi/StubBasedPsiElementBase.java"" lne=""187"" title=""Open in IDE"">StubBasedPsiElementBase.java:187</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.util.PsiUtilCore.getVirtualFile(<a class=""dsLink"" txt=""com/intellij/psi/util/PsiUtilCore.java"" lne=""358"" title=""Open in IDE"">PsiUtilCore.java:358</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.changeSignature.ChangeSignatureGestureDetector.isChangeSignatureAvailable(<a class=""dsLink"" txt=""com/intellij/refactoring/changeSignature/ChangeSignatureGestureDetector.java"" lne=""93"" title=""Open in IDE"">ChangeSignatureGestureDetector.java:93</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.changeSignature.ChangeSignaturePassFactory$ChangeSignaturePass.doCollectInformation(<a class=""dsLink"" txt=""com/intellij/refactoring/changeSignature/ChangeSignaturePassFactory.java"" lne=""87"" title=""Open in IDE"">ChangeSignaturePassFactory.java:87</a>)<br/>&nbsp;<b>at</b> com.intellij.codeHighlighting.TextEditorHighlightingPass.collectInformation(<a class=""dsLink"" txt=""com/intellij/codeHighlighting/TextEditorHighlightingPass.java"" lne=""62"" title=""Open in IDE"">TextEditorHighlightingPass.java:62</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass$1$1.run(<a class=""dsLink"" txt=""com/intellij/codeInsight/daemon/impl/PassExecutorService.java"" lne=""424"" title=""Open in IDE"">PassExecutorService.java:424</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.tryRunReadAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""1180"" title=""Open in IDE"">ApplicationImpl.java:1180</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass$1.run(<a class=""dsLink"" txt=""com/intellij/codeInsight/daemon/impl/PassExecutorService.java"" lne=""415"" title=""Open in IDE"">PassExecutorService.java:415</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.ProgressManager.executeProcessUnderProgress(<a class=""dsLink"" txt=""com/intellij/openapi/progress/ProgressManager.java"" lne=""218"" title=""Open in IDE"">ProgressManager.java:218</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(<a class=""dsLink"" txt=""com/intellij/openapi/progress/impl/ProgressManagerImpl.java"" lne=""220"" title=""Open in IDE"">ProgressManagerImpl.java:220</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.doRun(<a class=""dsLink"" txt=""com/intellij/codeInsight/daemon/impl/PassExecutorService.java"" lne=""412"" title=""Open in IDE"">PassExecutorService.java:412</a>)<br/>&nbsp;<b>at</b> com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.run(<a class=""dsLink"" txt=""com/intellij/codeInsight/daemon/impl/PassExecutorService.java"" lne=""388"" title=""Open in IDE"">PassExecutorService.java:388</a>)<br/>&nbsp;<b>at</b> com.intellij.concurrency.JobLauncherImpl$VoidForkJoinTask.exec(<a class=""dsLink"" txt=""com/intellij/concurrency/JobLauncherImpl.java"" lne=""193"" title=""Open in IDE"">JobLauncherImpl.java:193</a>)<br/>&nbsp;<b>at</b> jsr166e.ForkJoinTask.doExec(<a class=""dsLink"" txt=""jsr166e/ForkJoinTask.java"" lne=""260"" title=""Open in IDE"">ForkJoinTask.java:260</a>)<br/>&nbsp;<b>at</b> jsr166e.ForkJoinPool$WorkQueue.runTask(<a class=""dsLink"" txt=""jsr166e/ForkJoinPool.java"" lne=""858"" title=""Open in IDE"">ForkJoinPool.java:858</a>)<br/>&nbsp;<b>at</b> jsr166e.ForkJoinPool.scan(<a class=""dsLink"" txt=""jsr166e/ForkJoinPool.java"" lne=""1687"" title=""Open in IDE"">ForkJoinPool.java:1687</a>)<br/>&nbsp;<b>at</b> jsr166e.ForkJoinPool.runWorker(<a class=""dsLink"" txt=""jsr166e/ForkJoinPool.java"" lne=""1642"" title=""Open in IDE"">ForkJoinPool.java:1642</a>)<br/>&nbsp;<b>at</b> jsr166e.ForkJoinWorkerThread.run(<a class=""dsLink"" txt=""jsr166e/ForkJoinWorkerThread.java"" lne=""109"" title=""Open in IDE"">ForkJoinWorkerThread.java:109</a>)</pre></details></div></div>
","0"
"IDEA-126855","IntelliJ IDEA","","Add a ""select dependencies"" button in ""pull members up/down"" dialog","Jan Thomä","03/07/2014 05:02","03/07/2014 05:02",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When you pull members up and down and mark an entry, the dependencies of this entry are marked in red in the dialog, so you can see that you will probably have to pull these as well. It would be nice if the dialog had a button &quot;select dependencies&quot; or something like this, which would select all dependencies in one click.</div>
","0"
"IDEA-126685","IntelliJ IDEA","","Rename entry should cache renamed pairs","Сергей Цыпанов","28/06/2014 11:27","28/06/2014 11:27",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Sometimes when doing refactoring I change the name of the same entry into one and the same value. Maybe Shift+F6 dialogue should have a cache of pairs &quot;item before&quot; - &quot;item after&quot; and propose suitable names in a popup?</div>
","0"
"IDEA-118423","IntelliJ IDEA","reproduced","Inline method: should not inline method calls of non-pure methods","Anna Kozlova","18/12/2013 09:57","29/05/2014 09:27",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">class Test{<br/>    int i = 0;<br/>    boolean m(int a, int b) {<br/>        return (a == 1 &amp;&amp; b == 7);<br/>    }<br/>    <br/>    {<br/>        <br/>        boolean k = m(1, foo());<br/>    }<br/><br/>    private int foo() {<br/>        i = 8;<br/>        return 0;<br/>    }<br/><br/>}</pre><br/>foo should not be inlined</div>
","1"
"IDEA-112577","IntelliJ IDEA","reproduced","Introduce Parameter allows me to extract parameter which depends on lambda expression parameter","Dmitry Jemerov","23/08/2013 06:03","19/05/2014 11:28",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">    public static List&lt;Person&gt; eligibleVoters(List&lt;Person&gt; potentialVoters, int legalAgeOfVoting) {<br/>        return potentialVoters<br/>                .stream()<br/>                .filter(person -&gt; person.getAge() &gt;= legalAgeOfVoting)<br/>                .collect(Collectors.&lt;Person&gt;toList());<br/>  }</pre><br/>If I invoke Introduce Parameter on person.getAge(), it adds the age parameter to eligibleVoters, and puts person.getAge() into the calls. This doesn&#39;t make sense and should not be allowed</div>
","2"
"IDEA-125042","IntelliJ IDEA","","Productivity Guide doesn't count actions properly","Fedor Korotkov","12/05/2014 14:26","12/05/2014 15:14",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">My productivity guide says I&#39;ve used introduce variable refactoring only twice in the last two weeks. That is not true for sure! Believe me. ;-)<br/><br/>Could you please check that it&#39;s working properly?</div>
","0"
"IDEA-124207","IntelliJ IDEA","reproduced","Extract variable: ""Declare final"" and ""Change type"" functionalities interact badly","Andrey Dernov","21/04/2014 07:12","21/04/2014 07:12",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Steps to reproduce:<br/><br/>1. Extract variable from a method. <br/>[Declare final isn&#39;t set.] <br/>2. Set Declare final. <br/>[keyword final appeared] <br/>3. Press shit-tab to change type of the variable <br/>4. Select any superclass (i.e. Object) <br/>[keyword final disappeared even though &quot;Declare final&quot; checkbox is still set.] <br/>Expected: keyworld final is present when &quot;Declare final&quot; is set. <br/>5. Unset &quot;Declare final&quot; checkbox <br/>[variable type is truncated] <br/>Expected: nothing should happen in this case</div>
","0"
"IDEABKL-7039","IntelliJ IDEA: Backlog","","AutoSuggest should look at String contents","Ernst de Haan","03/04/2014 17:23","09/04/2014 16:55",,"Normal","Bug","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">Prerequisites:<br/><ul class=""wiki-list0""><li> I used IDEA 13.1.1 on OS X 10.9</li></ul><br/>Steps to reproduce<br/><ul class=""wiki-list0""><li> Have a Java class like this:</li></ul><pre class=""wikicode prettyprint"">import java.util.HashMap;<br/>import java.util.Map;<br/><br/>class Foo {<br/>    String test1() {<br/>        return &quot;hello&quot;;<br/>    }<br/><br/>    void test2() {<br/>        Map&lt;String, String&gt; m = new HashMap&lt;&gt;();<br/>        m.put(&quot;fooBar&quot;, test1());<br/>    }<br/>}</pre><ul class=""wiki-list0""><li> Inside the test2() method, select the text <span class=""monospace"">test1()</span><br/></li><li> Press Alt-Cmd-V to introduce a variable for this</li></ul><br/>Expected result:<br/><ul class=""wiki-list0""><li> AutoSuggest shows a number of suggestions.<br/></li><li> One of the suggestions (the top one preferably) is “fooBar” as that is in the string on the left hand side.</li></ul><br/>Actual result:<br/><ul class=""wiki-list0""><li> AutoSuggest shows a number of suggestions. (OK)<br/></li><li> There is no suggestion for “fooBar” (NOK)<br/></li></ul></div>
","0"
"IDEA-75897","IntelliJ IDEA","","Copy classes / inline classes with a destination: inline ","Muescha","24/10/2011 13:46","08/04/2014 07:45",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><strong>when</strong><br/><br/>if i have an inline class and put the cursor on the classname<br/><br/><br/><strong>what</strong><br/><br/>i hit F5 for copy. then it suggest me to copy the outer class<br/><br/><br/><br/><strong>expected</strong><br/><br/>make a copy of the inline class to an new inline class<br/><br/><br/>(or additional copy inlince class to a outer class like the move command)</div>
","1"
"IDEA-123495","IntelliJ IDEA","reply needed","Idea should offer target directory by default to the same directory from which ""Create class"" was executed","Tomasz Bartczak","04/04/2014 09:56","04/04/2014 10:48",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I write new NewClass() in class that is in src/test/java.<br/><br/>I use quick-fix, and selected target directory is src/main/java.<br/><br/>It should always be the directory from which quick fix refactoring was initialized</div>
","0"
"IDEA-123185","IntelliJ IDEA","","Rename packages named similarly but with different prefixes","Tim Wright","31/03/2014 09:25","31/03/2014 09:26",,"Normal","Task",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">One feature i would like is an improvement to package renaming<br/><br/>I tend to have a convension for test pacakged like:<br/><br/>com.a.b.c - production code<br/>unittest.a.b.c - unit tests<br/>integration.a.b.c - integration tests<br/>scaffoling.a.b.c - Test scafolling and fixtures<br/><br/>When I renamed com.a.b.c to com.a.b.d, it would be good if could rename the unittest, scaffoling and integraiton tests packages too....</div>
","0"
"IDEA-120406","IntelliJ IDEA","reply needed","Inline renaming type sometimes glitches","Tomasz Krakowiak","06/02/2014 09:48","04/03/2014 10:25",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Red box is shifted few characters left. And cursor is also shifted in relation where it is displayed.</div>
","0"
"IDEA-120722","IntelliJ IDEA","","Provide a key shortcut for Rename file, and the possibility to rename whether the active element is the editor (with file opened) or class in package explorer","Antonel","13/02/2014 07:25","13/02/2014 13:02",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently if one wants to rename , say, a java class (e.g.: to get rid of of all compilation exceptions a class generates in order to run the application) have to:<br/><ul class=""wiki-list0""><li> grab the mouse, <br/></li><li> open the file in editor, <br/></li><li> right click on editor header <br/></li><li> and choose Rename file... </li></ul>This is against the productivity (4 steps). <br/>Moreover I noticed there is no action associated to this (Ctrl+Shift+A) and no shortcut. <br/>So basically the above steps to rename a file is the only way of accomplish the file renaming.<br/><br/>So my proposal is:<br/><ul class=""wiki-list0""><li> add the action for File Rename... when the selection in IDE is a valid one<br/></li><li> add a key-shortcut for File Rename...<br/></li><li> the possibility to invoke that action when the File|Class is selected in package explorer or the editor with the file is opened and current</li></ul><br/>Regards<br/>  <br/>  </div>
","0"
"IDEA-120471","IntelliJ IDEA","","Support unwrap code from generic parameter","Kirill Likhodedov","08/02/2014 10:21","08/02/2014 10:21",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">0. Having a code like that:<br/><pre class=""wikicode prettyprint"">Collection&lt;String&gt;</pre>1. Place the cursor inside &quot;&lt;&gt;&quot;.<br/>2. Invoke &quot;Unwrap Code&quot;.<br/>Wanted: <br/><pre class=""wikicode prettyprint"">String</pre></div>
","1"
"IDEA-120044","IntelliJ IDEA","not reproduced","Inplace ""Introduce variable"" balloon is displaced when it is invoked on one of the first lines of document","Evgeny Gerashchenko","29/01/2014 11:48","29/01/2014 11:48",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">class Foo { void f() {<br/>        555;<br/>    }<br/>}</pre><br/><div class=""wiki picture""><img src=""[](screenshot.png)""/></div><br/><br/>If you try to type something in place of variable name, balloon will move lower and lower, step by step (it must be at least 10 symbols to reproduce)</div>
","0"
"IDEA-119787","IntelliJ IDEA","java7,reproduced","""inline"" refactoring makes bad code with generics with contravariance","Alex Dommasch","23/01/2014 14:52","29/01/2014 04:56",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">see attached file Example.java - if &quot;entryOf&quot; (line 36) is inlined, the result is red and won&#39;t compile</div>
","0"
"IDEA-119872","IntelliJ IDEA","","Rename package locks up Idea","Nick Pratt","26/01/2014 14:39","27/01/2014 05:53",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Stack dump attach.<br/><br/>I renamed (or tried to rename) the &quot;com&quot; package in a module to &quot;org&quot;.  Rename seemed to run, but then locked up.  Waited ~5 mins and Idea did not unfreeze.</div>
","0"
"IDEA-119357","IntelliJ IDEA","not reproduced","'Move to package' refactoring does not work for multiselect","Азис Мразиш","14/01/2014 02:55","14/01/2014 07:05",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Select 2 classes =&gt; move to package =&gt; onyl one class is moved<br/>Please disable multiselect or make it work as expected by user.</div>
","0"
"IDEA-119014","IntelliJ IDEA","","Change signature requires caret be on method name and doesn't work on its modifiers","Kirill Likhodedov","03/01/2014 09:20","03/01/2014 09:20",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">IDEA says &quot;Caret should be positioned at the name of method or class to be refactored&quot;, although it surely can understand that it is a modifier of a method.</div>
","1"
"IDEABKL-6992","IntelliJ IDEA: Backlog","","Create field for parameter when default constructor exists","Leszek Gruchała","30/12/2013 11:15","31/12/2013 08:14",,"Normal","Usability Problem","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">If I write first default no-argument constructor (needed for Spring&#39;s CGLIB) and I wish to create fields for parameters of another constructor, those fields are created with &#39;final&#39; key modifier. In such case, they should not.</div>
","0"
"IDEA-118199","IntelliJ IDEA","","No option to refactor unused variable","Alexander Buzmakoff","13/12/2013 13:26","16/12/2013 05:03",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><div class=""java code title"">Snippet</div><pre class=""wikicode prettyprint"">public class SomeClass {<br/>  // ...<br/>  // ...<br/>  public void doSomeLogic() {<br/>    User savedUserEntity = userRepository.saveAndFlush(userEntity);<br/>    // .. some other code which does not required the variable: savedUserEntity <br/>    doAnotherLogic();<br/>  }<br/>}</pre><br/>Assume that after my refactoring or somehow occasionally I declared the unused variable: savedUserEntity .<br/><br/>Ok, I&#39;m pressing Alt+Enter combination to &quot;simplify it&quot; but what I can see is only that I can remove the whole line (expression, invocation): <br/><br/><pre class=""wikicode prettyprint"">User savedUserEntity = userRepository.saveAndFlush(userEntity);</pre><br/> or split declaration and assignment option.<br/><br/>But what I really need is the option to remove the variable declaration only but not the whole invocation.<br/>I really would like to see this option :)!<br/><br/>Thank you guys.</div>
","0"
"IDEA-117451","IntelliJ IDEA","","Change Signature Refactoring Dialog: remember that I prefer to use empty default value","Kirill Likhodedov","03/12/2013 10:00","03/12/2013 10:00",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Almost always I prefer not specify empty default value for new method parameter, to make sure that I review all usages and supply correct value there.<br/><br/>However, each time I have to remove the default value by hands.<br/><br/>It would be cool if the dialog remembers that I used empty default value in the previous refactoring, and doesn&#39;t propose default value to me next time. Or it can be a checkbox that makes the dialog behave this way.</div>
","0"
"IDEA-116723","IntelliJ IDEA","","What is correct, easy, intended way of moving classes between modules?","Irina Chernushina","19/11/2013 13:03","22/11/2013 06:43",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Suppose your project develops and reach the step of (again) re-composition.<br/>You re-think it&#39;s component structure, form new &quot;very base&quot; modules or other &quot;purpose-grouped&quot; modules.<br/><br/>During this not easy process when you re-arrange lots of stuff inside you project, you naturally find classes that are not within its place, like those that should be utilities.<br/><br/>You think  - ok, I&#39;ll move them to other module.<br/><br/>You use Move Class refactoring, where<br/><ul class=""wiki-list0""><li> you see that only available candidate modules are those which contain the same package<br/></li><li> if you cut ok to the shortest project package like &quot;com.jetbrains.upsource&quot;, you get the ability to select the module of your choice, but you still cannot change the package name after that since it changes back to initial when you type in package. So it requires 2 actions at least</li></ul><br/>I understand that these &quot;defaults&quot; serves some other case (I am not aware of sorry), but I really don;t understand how I should have done my refactoring just quickly and without troubles</div>
","1"
"IDEA-39147","IntelliJ IDEA","","Refactoring / Inline class: reject inline of library class","Alexander Chernikov","08/06/2007 09:16","22/11/2013 05:50",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Open a library class, which sources are attached. E.g. you can attach the JDK sources and open java.util.zip.CheckedOutputStream.java.<br/>Try Refactor / Rename class. It is immediately rejected: &quot;Class is not inside the project&quot;. Ok.<br/>Try Refactor / Inline class. The refactoring dialog opens, and preview can be opened. (I did not look further.) Would be better to display analogous message: &quot;Class is not inside the project&quot; and do not show any more UI.</div>
","1"
"IDEA-115614","IntelliJ IDEA","reply needed","""Change signature"" new parameter chooser - missing option","Alexander Kirillin","29/10/2013 09:29","29/10/2013 16:32",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">See the screenshot. I want the 4th option - the same as 3rd, but with &quot;context&quot; instead of &quot;null&quot;</div>
","1"
"IDEA-115613","IntelliJ IDEA","","Missing ""add constructor parameter for super constructor"" quick fix","Alexander Kirillin","29/10/2013 09:21","29/10/2013 14:10",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">class A {<br/>    int x;<br/><br/>    A(int x) {<br/>        this.x = x;<br/>    }<br/>}<br/><br/>class B extends A {<br/>    B() { //I want a quick fix, that will add &quot;int x&quot; to the B() signature<br/>        <br/>    }<br/>}</pre></div>
","1"
"IDEA-73721","IntelliJ IDEA","","Inplace introduce field: impossible to choose proposed variant other then the first one together with choosing options in appeared tooltip","Yulia Zozulya","30/08/2011 09:19","28/10/2013 05:21",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><ol class=""wiki-list0""><li>If you select proposed variant by arrows and then choose option in the tooltip, then anyway the first variant would be chosen.<br/></li><li>If you select proposed variant by enter, option tooltip would disappear.<br/></li><li>If you select option at first, variants list would disappear and it wouldn&#39;t be possible to bring it back.</li></ol><br/>PY-108.1109</div>
","5"
"IDEABKL-6947","IntelliJ IDEA: Backlog","","Pull Member up may include inherited but not overridden methods","Eugene Petrenko","17/10/2013 10:52","22/10/2013 08:49",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">I have the similar code:<br/><pre class=""wikicode prettyprint""> class SomeServiceBaseWithManyMethods { ... }<br/> interface MyInterface {}<br/><br/> class SystemComponent extends SomeServiceBaseWithManyMethods implements MyInterface {<br/>    ///here I try pull member up<br/>  }<br/>}</pre><br/>The thing is I may have a number of useful public methods in SomeServiceBaseWithManyMethods  that I like to extract to MyInterface. <br/><br/>The workaround for non-final methods is to temporary override the method to be able to pull it up. This does not work for final methods.</div>
","0"
"IDEABKL-6937","IntelliJ IDEA: Backlog","","Safe Delete listener in refactoring API","Dmitry Jemerov","12/12/2007 06:45","14/10/2013 10:49",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Open",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped""></div>
","0"
"IDEABKL-6915","IntelliJ IDEA: Backlog","","Type Migration in .form","Fedor Korotkov","14/12/2011 09:41","11/10/2013 13:07",,"Normal","Feature","No Fix versions","anet","Java. Refactorings","Not specified","No Fixed in build","Submitted",,,,,,,,,,,"Unknown","<div class=""wiki text prewrapped"">It would be nice to change type in .form file too.</div>
","0"
"IDEA-114778","IntelliJ IDEA","","IntelliJ: add ""locate multiple occurrence""","Patrick Wright","11/10/2013 06:12","11/10/2013 07:13",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It often happens that during refactoring, in particular inlining method calls, I end up, within a method, retrieving a value from a object more than once via a method call. If I refactor to extract variable, IntelliJ will prompt me if I want to &#39;replace multiple occurrences&quot;. What I would like is an analysis that shows, on a per-method level, where I might be extract multiple occurrences into variables for the method - e.g. shows me candidates for this refactoring.<br/><br/>Example<br/>void foo(File dir) {<br/>   File out = new File(dir, dir.getName() + &quot;.txt&quot;);<br/>   Files.write(out.toPath(), &quot;TODO&quot;.getBytes());<br/>   System.out.println(&quot;wrote in &quot; + dir.getName() + &quot; new file &quot; + out.toPath(): <br/>}<br/><br/>In this example, the analysis would locate &quot;dir.getName()&quot; and &quot;out.toPath()&quot; and prompt me to extract these to a new variables.<br/><br/>void foo(File dir) {<br/>   String dirName = dir.getName();<br/>   File out = new File(dir, dirName + &quot;.txt&quot;);<br/>   Path outPath = out.toPath();<br/>   Files.write(outPath, &quot;TODO&quot;.getBytes());<br/>   System.out.println(&quot;wrote in &quot; + dir.getName() + &quot; new file &quot; + outPath: <br/>}<br/><br/>Sorry I don&#39;t have a more emotionally compelling example. :)<br/><br/>I realize this refactoring can&#39;t be applied automatically as the editor can&#39;t always know (except perhaps in simple cases) whether the call is idempotent. Thus it would have to be a sort of analysis + inspection prompt.</div>
","0"
"IDEA-82189","IntelliJ IDEA","","IDEA doesn't find duplicate constants in static method when introducing field from instance method","Oleg Stepanov","02/03/2012 18:55","09/10/2013 12:33",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Run introduce field on &quot;foo&quot; in i1. IDEA will only find two occurrences. Instead it should suggest to use either two occurrences in instance methods and introduce instance field or all three occurrences and introduce static field.<br/><br/><pre class=""wikicode prettyprint"">  static class C {<br/>    String i1() {<br/>      return &quot;foo&quot;;<br/>    }<br/>    String i2() {<br/>      return &quot;foo&quot;;<br/>    }    <br/>    static String s() {<br/>      return &quot;foo&quot;;<br/>    } <br/>  }</pre></div>
","0"
"IDEA-114603","IntelliJ IDEA","reproduced","Declaration and assignment splited when introducing new method","Michal Lipski","08/10/2013 14:02","09/10/2013 10:32",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Problem described in example:<br/><br/><a href=""https://gist.github.com/michal-lipski/6887828"" target=""_blank"" rel=""noopener noreferrer"">https://gist.github.com/michal-lipski/6887828</a><br/><br/>I would like to have declaration and initialization in one line in this case.<br/>The other thing is that there is no context tip to move assignment to variable declaration.<br/><br/>I am using: idea-IU-129.1359<br/><br/>br,<br/>Michał</div>
","1"
"IDEA-113480","IntelliJ IDEA","","In-place Introduce variable: typing is eaten every time I use refactoring","Anton Makeev","11/09/2013 09:14","08/10/2013 11:12",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I invoke &#39;Introduce Variable&#39; (Alt+Ctrl+V) and quickly start typing a new name, the first several characters are not registered (see the screencast).<br/><br/>This happens avery time and it&#39;s quite annoying</div>
","3"
"IDEA-114312","IntelliJ IDEA","","Drag class to resource directory: inconsistent ""Target destination"" value suggested","Alexander Chernikov","01/10/2013 11:55","01/10/2013 11:57",,"Minor","Usability Problem",,"nik","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Create a module with source root S, resource root R and a not-any-root directory D.<br/>Provide a java source J in the S: it is parsed and shown as a class, all is Ok.<br/>Drag J from S to R to move (or Ctrl+Drag to copy: the effect is similar).<br/>On dropping to R the &quot;Move (Copy) Class&quot; dialog appears.<br/>Check its &quot;Target destination directory&quot; field: it shows &quot;Leave in the same source root&quot;. That&#39;s a lie.<br/><br/>On drag to D not &quot;Move (Copy) Class&quot;, but &quot;Move (Copy) File&quot; dialog appears. Maybe it should be the same for R.<br/>132.474.</div>
","1"
"IDEA-112998","IntelliJ IDEA","","Moving an Spring configuration XML file does not change <import> tags properly","Amir Pashazadeh","31/08/2013 03:08","16/09/2013 10:37",,"Normal","Bug",,"sergeyv","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have a package containing some classes and an Spring XML configuration file which contains an import tag as:<br/><pre class=""wikicode prettyprint"">&lt;import resource=&quot;../../path/to/another/xml.xml&quot;&gt;</pre><br/>I moved the whole package to another location, well everything goes fine, except the Spring configuration file:  the relative path to the other resource did not updated.</div>
","0"
"IDEA-113371","IntelliJ IDEA","","Incorrect error message when refactoring complex flow IDs","Elena Matokhina","08/09/2013 08:46","09/09/2013 05:08",,"Normal","Bug",,"sergeyv","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">OS: Mac OS X (10.8.4)<br/>IntelliJ IDEA: 132.106<br/><br/>Steps to reproduce:<br/>1. Set an ID for some JSF flow in a complex way, e.g. as it&#39;s shown in this screencast: <a href=""http://www.screenr.com/SyI7"" target=""_blank"" rel=""noopener noreferrer"">http://www.screenr.com/SyI7</a> or in a screenshot attached.<br/>2. Use code completion to set this flow name to an action (see screenshot);<br/>3. Try to refactor this action.<br/><br/>Result: an error is displayed: &quot;Cannot perform refactoring. The caret should be positioned at the symbol to be renamed.&quot; - which is a misleading message, because the caret is positioned in the right place.<br/>Expected result: &quot;Cannot perform refactoring. The variable is a composite element.&quot; or something like that.</div>
","1"
"IDEA-112999","IntelliJ IDEA","","Moving Spring XML configuration files does not change @ContextConfiguration config","Amir Pashazadeh","31/08/2013 03:39","05/09/2013 08:24",,"Normal","Bug",,"sergeyv","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I did what I described in <a href=""/issue/IDEA-112998"" target=""_self"" data-issue-id=""25-606302"" title=""Moving an Spring configuration XML file does not change &lt;import&gt; tags properly"">IDEA-112998</a>  and now I see @ContextConfiguration (on an AbstractTransactionalTestNGSpringContextTests) file does not updated too.<br/><br/>May be a duplicate of <a href=""/issue/IDEA-58991"" class=""issue-resolved"" target=""_self"" data-issue-id=""25-207889"" title=""Spring: resource reference is broken on container package rename/move"">IDEA-58991</a> (which is marked as resolved).</div>
","0"
"IDEA-93977","IntelliJ IDEA","","Hotkey is not working in detached editor tab","Alexei Zhukov","31/10/2012 10:55","12/08/2013 06:45",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Invoke &quot;Introduce parameter&quot; refactoring and try to set an option &quot;with delegated method&quot; with keyboard.<br/><br/>Also, text in the hint is corrupted.</div>
","2"
"IDEA-110973","IntelliJ IDEA","","Offer alternative refactoring for annon inner class accessing non-final var","Nick Pratt","24/07/2013 10:42","24/07/2013 11:46",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In the following code, Idea offers to replace the &#39;a&#39; var with an array.  If it could also offer to replace the a var with one of the AtomicXYZ classes that would be nice.<br/><br/><pre class=""wikicode prettyprint"">int a = 5;<br/><br/>Something b = new Something() {<br/><br/>    @Override<br/>    public void c() {<br/>        a += 1;<br/>    }<br/>};</pre></div>
","1"
"IDEA-70457","IntelliJ IDEA","","It would be really cool if pressing mnemonics several times will actually switch the combo values in introduce field inplace popup","Alexey Pegov","31/05/2011 10:15","15/07/2013 11:47",,"Normal","Feature",,"kb","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I.e. pressing Option+I will change the selected value from &quot;current method&quot; to &quot;field declaration&quot; and then to &quot;contructor&quot; and then again to &quot;field declaration&quot;, etc.</div>
","3"
"IDEA-109964","IntelliJ IDEA","","delete all invalid run configurations action","Cristian Vasile Mocanu","03/07/2013 05:08","05/07/2013 11:14",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When deleting a class with a main method, also delete all run configuration of type &quot;Application&quot; which were running that class, because they are now invalid.</div>
","0"
"IDEA-109989","IntelliJ IDEA","","Implement missing methods","Igor Baltiyskiy","03/07/2013 08:32","03/07/2013 10:41",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Suppose there is a type T. Some usages of T call methods that are not declared in T. Feature: add methods called on T to the standard &quot;Implement Methods&quot; dialog invoked when the caret is inside the declaration of T.<br/><br/>This allows for top-bottom development, when it&#39;s clear that T is needed, and first its usages are implemented, then T is implemented with the resulting interface. This feature would automate the process of adding the methods to implement.</div>
","1"
"IDEA-109611","IntelliJ IDEA","","'Refactor / Inline' could process the redundant assignments to a parameter","Dmitry Cherniachenko","26/06/2013 05:57","26/06/2013 05:57",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Here is the code:<br/><pre class=""wikicode prettyprint"">public boolean myFunction(int param)<br/>{<br/>    param = doSomeCalculations(param);<br/><br/>    return checkValue(param);<br/>}</pre>When the cursor is at &#39;<span class=""monospace"">param = ...</span>&#39; pressing Ctrl+Alt+N just shows a popup &quot;Cannot find constant initializer for parameter&quot;.<br/><br/>Instead it could have &#39;inlined the assignment&#39; and changed the code to:<br/><pre class=""wikicode prettyprint"">public boolean myFunction(int param)<br/>{<br/>    return checkValue(doSomeCalculations(param));<br/>}</pre><br/>P.S. This snippet could also trigger inspection like &#39;Assignment is redundant&#39; and suggest to inline it.</div>
","1"
"IDEA-107638","IntelliJ IDEA","reproduced","add parameter should copy generic parameters (otherwise it produces uncompilable code)","Cristian Vasile Mocanu","22/05/2013 05:23","22/05/2013 05:23",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider the following code:<br/><pre class=""wikicode prettyprint"">public &lt;T extends Serializable&gt; void save(final T cache, final String cacheName) throws CacheRepositoryException {<br/>    try {<br/>        tryToSave(cache, cacheName);<br/>    } catch (Exception e) {<br/>        throw new CacheRepositoryException(&quot;an error occurred while trying to save cache [&quot; + cacheName + &quot;]&quot;, e);<br/>    }<br/>}<br/><br/>private void tryToSave(final String cacheName) throws IOException {<br/><br/>}</pre>Notice that tryToSave has only one parameter, but we are calling it with 2 parameters.<br/>Invoke &quot;add parameter&quot; on the call. The new signature is uncompilable:<br/><pre class=""wikicode prettyprint"">private void tryToSave(final T cache, final String cacheName) throws IOException</pre><br/>The correct signature should include the generics parameter:<br/><pre class=""wikicode prettyprint"">private &lt;T extends Serializable&gt; void tryToSave(final T cache, final String cacheName) throws IOException</pre><br/>The problem is not reproducible for &quot;Create method&quot;. It&#39;s only when adding for the first time a generic parameter to a existing method.</div>
","0"
"IDEA-107045","IntelliJ IDEA","reproduced","Erroneous override analysis with default methods","Brian Goetz","12/05/2013 19:44","13/05/2013 11:42",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In<br/><br/>public class BadDefaults {<br/>    interface I&lt;T_ARR&gt; {<br/>        T_ARR makeArray(int len);<br/>    }<br/><br/>    interface OfInt extends I&lt;int[]&gt; {<br/>        default int[] makeArray(int len) { return new int[len]; }<br/>    }<br/><br/>    static abstract class A&lt;T_ARR&gt; {<br/>        public abstract T_ARR makeArray(int size);<br/>    }<br/><br/>    static class B extends A&lt;int[]&gt; {<br/>        public int[] makeArray(int len) { return new int[len]; }<br/>    }<br/><br/>    static class C extends B implements OfInt { }<br/><br/>    public static void main(String[] args) {<br/>        new B().makeArray(3);<br/>        new C().makeArray(3);<br/>    }<br/>}<br/><br/>The &quot;override&quot; icon in the left gutter bar suggests that B.makeArray() overrides OfInt.makeArray(), even though the types are unrelated.</div>
","0"
"IDEA-105702","IntelliJ IDEA","","Rename refactor: rename java class could sujjest rename of its *.properties, *.ftl, other files with same name (not extension) in directory","Artem Morozov","18/04/2013 12:17","18/04/2013 12:17",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have some amount of java classes, with properties files and *.ftl files, named exactly as related classes.<br/><br/>AbstractClassA.java<br/><br/>ClassB.java // derived from AbstractClassA<br/>ClassB.properties<br/>ClassB.ftl<br/>...<br/><br/>It could be usefull for me, may be for other developers, to support sujjestion of renaming all related project files too.</div>
","0"
"IDEA-102275","IntelliJ IDEA","","copy pasteing classes between projects fails dependency analysis","teemu kanstren","01/03/2013 13:21","01/03/2013 13:21",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have project A and project B. Project B builds on project A. Project B references the output dir of project A on its classpath. Sources of project A are linked to the classes in project B classpath. Meaning that project B does not contain the source of project A but it has the compiled classes from project A on the classpath and when browsing the classes of project A from project B I have used the option &quot;link sources&quot; to be able to view them when required.<br/><br/>Now I created two classes C1 and C2 in project B. These classes only refer to each other and to classes in project A. But they are part of project B. I now choose to move these to project A. I highlight these source files in project B, right-click and choose &quot;cut&quot; in the popup menu. I then move to project A, and paste these classes in the project A source tree. Since they only refer to classes in project A and to each other, there should be no problem. Yet IntelliJ lists two pages of errors I should expect after the operation. Mostly that in my new module some classes will not be available, which are actually part of project A should this is exactly where they will be available. Just not as compiled but as part of the same source tree. I click &quot;continue anyway&quot; and the result is that the classes C1 and C2 (or their source code) are pasted to project A and as expected there are zero errors in the project after (as before). <br/><br/>So, I assume the problem is that IntelliJ bases its problem reporting on some idea that in the project B these classes references bunch of stuff visible for project B (through the classpath). It does not check that all these are actually available in project A as part of the source tree, or in general in the build path.</div>
","0"
"IDEA-88121","IntelliJ IDEA","","rename class doesn't rename bean name in jsp","Michael Krumpholz","02/07/2012 04:06","01/03/2013 02:35",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I renamed a class and the rename variables dialog showed only a instance in another java class. Then the refactoring preview showed all occurences in the jsp file. That looked correct as far as i could see. The jsp code and result of refactoring is as follows:<br/><pre class=""wikicode prettyprint"">jsp before renaming:<br/>&lt;jsp:useBean id=&quot;testBean&quot; type=&quot;com.somepackage.test.TestBean&quot; scope=&quot;request&quot; /&gt;<br/><br/><br/>jsp after renaming:<br/>&lt;jsp:useBean id=&quot;testBean2&quot; type=&quot;com.somepackage.test.TestBean2&quot; scope=&quot;request&quot; /&gt;<br/><br/>&lt;p&gt;response: ${testBean.response}&lt;/p&gt;</pre>The occurences in the jsp (EL) were not renamed and marked as not resolvable then.</div>
","1"
"IDEA-101853","IntelliJ IDEA","reproduced","Replace method duplicates","akram ajouli","25/02/2013 18:31","27/02/2013 10:04",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I would like to announce a bug in the use of the refactoring operation Replace Method duplicate in the following case:<br/><br/> <br/><br/>public  &lt;T&gt; T m(V&lt;T&gt; v) {<br/><div><pre class=""wiki-exception-title"">&nbsp;<b>return</b> v.visit(this)</pre></div>;<br/>    }<br/><br/> <br/><br/>    public  &lt;T&gt; T n (V&lt;T&gt; v) {<br/><div><pre class=""wiki-exception-title"">&nbsp;<b>return</b> v.visit(this)</pre></div>;<br/>    }<br/><br/> <br/><br/>I would like to find duplicate for the method m and normally it should be found in the body of n but the operation does not detect it.<br/><br/> <br/><br/>Is there some body who know what is the problem here.<br/><br/> <br/><br/>Yours Faithfully,</div>
","0"
"IDEA-101830","IntelliJ IDEA","","Add ability to visually compare files in Copy/file already exists (diff/preview)","Alexey Gopachenko","24/07/2009 13:14","27/02/2013 10:02",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown",,"4"
"IDEA-100757","IntelliJ IDEA","","New refactoring ""Replace by Strategy""","Brice Dutheil","08/02/2013 14:33","11/02/2013 06:28",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">We have already the <strong>extract method object</strong> refactoring, while great some time we would prefer a strategy instead.<br/>What do you think if the refactorings menu added support to replace by a strategy pattern.</div>
","0"
"IDEA-85952","IntelliJ IDEA","","Refactor->Rename: lower priority or exclude variants containing spelling errors","Yann Cebron","11/05/2012 14:13","30/01/2013 10:03",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">usually I want to rename it completely or fix a spelling-error and not create another variation of it<br/><br/><pre class=""wikicode prettyprint"">public class A {<br/>    String abcdefghijklmn = &quot;asodi&quot;;<br/>}</pre><br/>rename field &quot;abcde...&quot;<br/><br/>118.419</div>
","0"
"IDEA-99563","IntelliJ IDEA","reproduced","Inline class doesn't work correctly","Sergey Ignatov","23/01/2013 04:52","23/01/2013 04:52",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">import java.util.Arrays;<br/>import java.util.List;<br/><br/>public class Processor {<br/>    static class Fixer&lt;T extends Processor&gt; {}<br/><br/>    static class ProcessorExt extends Processor {}<br/><br/>    static class GrFixer extends Fixer&lt;ProcessorExt&gt; {}<br/><br/>    static class Fixer1 extends GrFixer {}<br/>    static class Fixer2 extends GrFixer {}<br/><br/>    public static List&lt;GrFixer&gt; a = Arrays.asList(new Fixer1(), new Fixer2());<br/>}</pre>Try to inline GrFixer.</div>
","0"
"IDEA-61140","IntelliJ IDEA","","When attempting to pull members up, no indication is given in case of error","Alex Gitelman","11/11/2010 21:37","30/12/2012 08:43",,"Normal","Bug",,"kb","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">In 98.311<br/>I put together a class with few methods. Then I wanted to have interface that this class implements. So I created interface class but forgot to add &#39;implements&#39; clause. Then I could not figure why nothing happens when I try to pull members up.<br/>So I reverted to 98.187 and tried it and there it showed tooltip saying that there is no class to pull methods to.<br/>The tooltip appears to be missing in 98.311.</div>
","1"
"IDEA-97786","IntelliJ IDEA","not reproduced","Cannot end rename refactoring on IDEA 12.0","Tony Lovell","18/12/2012 16:23","19/12/2012 09:57",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am using IDEA 12<br/> <br/>I press enter (as I used to, long ago, with prior versions of IDEA) and what now happens is that the refactoring does not complete &ndash; a linebreak is inserted within the new identifier I am choosing.  Because no identifier can have a linebreak in it, this should just not be permitted.  I&#39;d think the context of the input event&#39;s handling is not correct.<br/> <br/>I have altered some of the keymappings to make IDEA more Mac-like.  I enclose a PDF of my exported keymap</div>
","1"
"IDEA-92738","IntelliJ IDEA","we'd better shelve it","Rename parameter in implementation doesn't change it in declarion","Maciej Matys","10/10/2012 10:13","08/11/2012 18:11",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">We have one interface with one method declaration which have one parameter and class implementing this interface.<br/>Renaming parameter name in class(Shift+F6) doesn&#39;t change it in interface.</div>
","0"
"IDEA-92803","IntelliJ IDEA","reproduced","Inplace rename for method referenced as bean property","Sergey_Vasiliev","11/10/2012 11:25","11/10/2012 11:41",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Please, please : )) don&#39;t rename properties )))<br/><br/><a href=""http://www.screenr.com/8vw8"" target=""_blank"" rel=""noopener noreferrer"">http://www.screenr.com/8vw8</a></div>
","0"
"IDEA-90792","IntelliJ IDEA","","Implement generified ""move up"" refactoring.","Davide Baroncelli","29/08/2012 17:54","12/09/2012 19:22",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It frequently happens that while developing I spot generification opportunities in a class. When that happens, I introduce a generified superclass, and I start moving up stuff. This is currently annoying, though, because I have to manually correct everything to introduce generification, e.g. from:<br/><br/><br/>  @Override<br/>  public void getChildren(Entity parent, ChildrenLoadedCallback&lt;Entity&gt; callback) {<br/>    if (!filters.isEmpty()) {<br/>      ChildrenLoadedCallback&lt;Entity&gt; cb = newFilteringCallback(callback);<br/>      doGetFilter(parent, cb);<br/>    } else {<br/>      doGetFilter(parent, callback);<br/>    }<br/>  }<br/><br/>to:<br/><br/><br/>  @Override<br/>  public void getChildren(T parent, ChildrenLoadedCallback&lt;T&gt; callback) {<br/>    if (!filters.isEmpty()) {<br/>      ChildrenLoadedCallback&lt;T&gt; cb = newFilteringCallback(callback);<br/>      doGetFilter(parent, cb);<br/>    } else {<br/>      doGetFilter(parent, callback);<br/>    }<br/>  }<br/><br/>IDEA should do that for me, clearly. ;)</div>
","0"
"IDEA-90435","IntelliJ IDEA","","Drag&nDrop in project view of directory located in sources does not offer ""move to another source root""","Yann Cebron","22/08/2012 05:14","22/08/2012 07:22",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">whereas the refactoring does<br/><br/>Trunk</div>
","0"
"IDEA-87569","IntelliJ IDEA","not reproduced","Can not move number of packages","Alexander Konstantinov","19/06/2012 09:33","19/06/2012 09:33",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">On last screenshot you can see that 4 packages of 5 didn&#39;t move. And that moved package became broken</div>
","0"
"IDEA-86534","IntelliJ IDEA","","Refactor error during Pull Members Down results in a broken IDE state, can no longer undo","Phil Shapiro","23/05/2012 15:25","08/06/2012 03:41",,"Major","Exception",,"anet","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have a class that I&#39;m trying to use Pull Members Down on. The first time I used the interface I had forgotten to remove the &quot;final&quot; modifier from the class declaration, so I had to cancel the operation and start from scratch. After selecting all the elements I wanted to push down, I entered the name of the new subclass to create in the UI. When I completed the process, the new subclass source file was opened in the editor, but it was an empty class; there were no members. Oddly, the list of imports for the file was appended to the end on a single line and the file itself was no longer editable.<br/><br/>Going back to the original file, the pushed down members were deleted. I tried to Undo but it had no effect.<br/><br/>Looking at the Intellij log files, the IDE must&#39;ve been in an error loop as it generated &gt;5M of log file data before I killed the process.<br/><br/>Here&#39;s the first error I could find in the logs that refers to the refactor operation:<br/><br/><br/>2012-05-23 14:04:04,851 [51525483]  ERROR - impl.PsiToDocumentSynchronizer - Attempt to modify PSI for non-committed Document! <br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.Throwable</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> com.intellij.openapi.diagnostic.Logger.error(<a class=""dsLink"" txt=""com/intellij/openapi/diagnostic/Logger.java"" lne=""54"" title=""Open in IDE"">Logger.java:54</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.a(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""84"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:84</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.childAdded(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""108"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:108</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiManagerImpl.a(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiManagerImpl.java"" lne=""441"" title=""Open in IDE"">PsiManagerImpl.java:441</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiManagerImpl.childAdded(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiManagerImpl.java"" lne=""326"" title=""Open in IDE"">PsiManagerImpl.java:326</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.wrappers.PsiEventWrapperAspect.a(<a class=""dsLink"" txt=""com/intellij/pom/wrappers/PsiEventWrapperAspect.java"" lne=""93"" title=""Open in IDE"">PsiEventWrapperAspect.java:93</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.wrappers.PsiEventWrapperAspect.update(<a class=""dsLink"" txt=""com/intellij/pom/wrappers/PsiEventWrapperAspect.java"" lne=""49"" title=""Open in IDE"">PsiEventWrapperAspect.java:49</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.core.impl.PomModelImpl.runTransaction(<a class=""dsLink"" txt=""com/intellij/pom/core/impl/PomModelImpl.java"" lne=""161"" title=""Open in IDE"">PomModelImpl.java:161</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.ChangeUtil.prepareAndRunChangeAction(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/ChangeUtil.java"" lne=""177"" title=""Open in IDE"">ChangeUtil.java:177</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addChild(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""673"" title=""Open in IDE"">CompositeElement.java:673</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addChildren(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""780"" title=""Open in IDE"">CompositeElement.java:780</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.codeStyle.CodeEditUtil.addChildren(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/codeStyle/CodeEditUtil.java"" lne=""84"" title=""Open in IDE"">CodeEditUtil.java:84</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addInternal(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""530"" title=""Open in IDE"">CompositeElement.java:530</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.java.ClassElement.addInternal(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/java/ClassElement.java"" lne=""150"" title=""Open in IDE"">ClassElement.java:150</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.JavaStubPsiElement.add(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/JavaStubPsiElement.java"" lne=""79"" title=""Open in IDE"">JavaStubPsiElement.java:79</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.PushDownProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/PushDownProcessor.java"" lne=""362"" title=""Open in IDE"">PushDownProcessor.java:362</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.PushDownProcessor.performRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/PushDownProcessor.java"" lne=""143"" title=""Open in IDE"">PushDownProcessor.java:143</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$7.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""444"" title=""Open in IDE"">BaseRefactoringProcessor.java:444</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""902"" title=""Open in IDE"">ApplicationImpl.java:902</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""441"" title=""Open in IDE"">BaseRefactoringProcessor.java:441</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.access$000(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor/access.java"" lne=""70"" title=""Open in IDE"">BaseRefactoringProcessor.java:70</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$3.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""299"" title=""Open in IDE"">BaseRefactoringProcessor.java:299</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""117"" title=""Open in IDE"">CommandProcessorImpl.java:117</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""93"" title=""Open in IDE"">CommandProcessorImpl.java:93</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.execute(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""295"" title=""Open in IDE"">BaseRefactoringProcessor.java:295</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.doRun(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""219"" title=""Open in IDE"">BaseRefactoringProcessor.java:219</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""516"" title=""Open in IDE"">BaseRefactoringProcessor.java:516</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog.invokeRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""170"" title=""Open in IDE"">RefactoringDialog.java:170</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.PushDownDialog.doAction(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/PushDownDialog.java"" lne=""120"" title=""Open in IDE"">PushDownDialog.java:120</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog.doRefactorAction(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""85"" title=""Open in IDE"">RefactoringDialog.java:85</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog$RefactorAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""144"" title=""Open in IDE"">RefactoringDialog.java:144</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2028"" title=""Open in IDE"">AbstractButton.java:2028</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton$Handler.actionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2351"" title=""Open in IDE"">AbstractButton.java:2351</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""387"" title=""Open in IDE"">DefaultButtonModel.java:387</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.setPressed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""242"" title=""Open in IDE"">DefaultButtonModel.java:242</a>)<br/>&nbsp;<b>at</b> javax.swing.plaf.basic.BasicButtonListener.mouseReleased(<a class=""dsLink"" txt=""javax/swing/plaf/basic/BasicButtonListener.java"" lne=""236"" title=""Open in IDE"">BasicButtonListener.java:236</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processMouseEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6375"" title=""Open in IDE"">Component.java:6375</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processMouseEvent(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""3267"" title=""Open in IDE"">JComponent.java:3267</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6140"" title=""Open in IDE"">Component.java:6140</a>)<br/>&nbsp;<b>at</b> java.awt.Container.processEvent(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2083"" title=""Open in IDE"">Container.java:2083</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4737"" title=""Open in IDE"">Component.java:4737</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2141"" title=""Open in IDE"">Container.java:2141</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4565"" title=""Open in IDE"">Component.java:4565</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.retargetMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4619"" title=""Open in IDE"">Container.java:4619</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.processMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4280"" title=""Open in IDE"">Container.java:4280</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.dispatchEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4210"" title=""Open in IDE"">Container.java:4210</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2127"" title=""Open in IDE"">Container.java:2127</a>)<br/>&nbsp;<b>at</b> java.awt.Window.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Window.java"" lne=""2482"" title=""Open in IDE"">Window.java:2482</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4565"" title=""Open in IDE"">Component.java:4565</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""684"" title=""Open in IDE"">EventQueue.java:684</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$000(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""85"" title=""Open in IDE"">EventQueue.java:85</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""643"" title=""Open in IDE"">EventQueue.java:643</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""641"" title=""Open in IDE"">EventQueue.java:641</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""87"" title=""Open in IDE"">AccessControlContext.java:87</a>)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""98"" title=""Open in IDE"">AccessControlContext.java:98</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$2.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""657"" title=""Open in IDE"">EventQueue.java:657</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$2.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""655"" title=""Open in IDE"">EventQueue.java:655</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""87"" title=""Open in IDE"">AccessControlContext.java:87</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""654"" title=""Open in IDE"">EventQueue.java:654</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.e(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""699"" title=""Open in IDE"">IdeEventQueue.java:699</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""534"" title=""Open in IDE"">IdeEventQueue.java:534</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.b(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""420"" title=""Open in IDE"">IdeEventQueue.java:420</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""378"" title=""Open in IDE"">IdeEventQueue.java:378</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""296"" title=""Open in IDE"">EventDispatchThread.java:296</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""211"" title=""Open in IDE"">EventDispatchThread.java:211</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""205"" title=""Open in IDE"">EventDispatchThread.java:205</a>)<br/>&nbsp;<b>at</b> java.awt.Dialog$1.run(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1044"" title=""Open in IDE"">Dialog.java:1044</a>)<br/>&nbsp;<b>at</b> java.awt.Dialog$3.run(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1096"" title=""Open in IDE"">Dialog.java:1096</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.awt.Dialog.show(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1094"" title=""Open in IDE"">Dialog.java:1094</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.a(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""742"" title=""Open in IDE"">DialogWrapperPeerImpl.java:742</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""738"" title=""Open in IDE"">DialogWrapperPeerImpl.java:738</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""426"" title=""Open in IDE"">DialogWrapperPeerImpl.java:426</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.DialogWrapper.showAndGetOk(<a class=""dsLink"" txt=""com/intellij/openapi/ui/DialogWrapper.java"" lne=""1382"" title=""Open in IDE"">DialogWrapper.java:1382</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.DialogWrapper.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/DialogWrapper.java"" lne=""1367"" title=""Open in IDE"">DialogWrapper.java:1367</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.JavaPushDownHandler.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/JavaPushDownHandler.java"" lne=""105"" title=""Open in IDE"">JavaPushDownHandler.java:105</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.JavaPushDownHandler.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/JavaPushDownHandler.java"" lne=""61"" title=""Open in IDE"">JavaPushDownHandler.java:61</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/actions/BaseRefactoringAction.java"" lne=""89"" title=""Open in IDE"">BaseRefactoringAction.java:89</a>)<br/>&nbsp;<b>at</b> com.intellij.ui.popup.PopupFactoryImpl$ActionPopupStep$1.run(<a class=""dsLink"" txt=""com/intellij/ui/popup/PopupFactoryImpl.java"" lne=""619"" title=""Open in IDE"">PopupFactoryImpl.java:619</a>)<br/>&nbsp;<b>at</b> com.intellij.ui.popup.AbstractPopup$17.run(<a class=""dsLink"" txt=""com/intellij/ui/popup/AbstractPopup.java"" lne=""1162"" title=""Open in IDE"">AbstractPopup.java:1162</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.a(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""615"" title=""Open in IDE"">FocusManagerImpl.java:615</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.g(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""596"" title=""Open in IDE"">FocusManagerImpl.java:596</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.e(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""566"" title=""Open in IDE"">FocusManagerImpl.java:566</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.access$200(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl/access.java"" lne=""55"" title=""Open in IDE"">FocusManagerImpl.java:55</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl$IdleRunnable.runEdt(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""102"" title=""Open in IDE"">FocusManagerImpl.java:102</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.util.EdtRunnable$1.run(<a class=""dsLink"" txt=""com/intellij/openapi/util/EdtRunnable.java"" lne=""28"" title=""Open in IDE"">EdtRunnable.java:28</a>)<br/>&nbsp;<b>at</b> java.awt.event.InvocationEvent.dispatch(<a class=""dsLink"" txt=""java/awt/event/InvocationEvent.java"" lne=""209"" title=""Open in IDE"">InvocationEvent.java:209</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""682"" title=""Open in IDE"">EventQueue.java:682</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$000(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""85"" title=""Open in IDE"">EventQueue.java:85</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""643"" title=""Open in IDE"">EventQueue.java:643</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""641"" title=""Open in IDE"">EventQueue.java:641</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""87"" title=""Open in IDE"">AccessControlContext.java:87</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""652"" title=""Open in IDE"">EventQueue.java:652</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.e(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""699"" title=""Open in IDE"">IdeEventQueue.java:699</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""538"" title=""Open in IDE"">IdeEventQueue.java:538</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.b(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""420"" title=""Open in IDE"">IdeEventQueue.java:420</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""378"" title=""Open in IDE"">IdeEventQueue.java:378</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""296"" title=""Open in IDE"">EventDispatchThread.java:296</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""211"" title=""Open in IDE"">EventDispatchThread.java:211</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""196"" title=""Open in IDE"">EventDispatchThread.java:196</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""188"" title=""Open in IDE"">EventDispatchThread.java:188</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""122"" title=""Open in IDE"">EventDispatchThread.java:122</a>)</pre></details></div>2012-05-23 14:04:04,852 [51525484]  ERROR - impl.PsiToDocumentSynchronizer - IntelliJ IDEA 11.1.2  Build #IU-117.418 <br/>2012-05-23 14:04:04,852 [51525484]  ERROR - impl.PsiToDocumentSynchronizer - JDK: 1.6.0_31 <br/>2012-05-23 14:04:04,852 [51525484]  ERROR - impl.PsiToDocumentSynchronizer - VM: Java HotSpot(TM) 64-Bit Server VM <br/>2012-05-23 14:04:04,852 [51525484]  ERROR - impl.PsiToDocumentSynchronizer - Vendor: Apple Inc. <br/>2012-05-23 14:04:04,852 [51525484]  ERROR - impl.PsiToDocumentSynchronizer - OS: Mac OS X <br/>2012-05-23 14:04:04,852 [51525484]  ERROR - impl.PsiToDocumentSynchronizer - Last Action: EditorLineEnd <br/><br/>There was another exception after this that looked like it might be interesting:<br/><br/><br/>2012-05-23 14:04:04,853 [51525485]  ERROR - impl.PsiToDocumentSynchronizer - Current Command: Push Members Down <br/>2012-05-23 14:04:04,853 [51525485]  ERROR - tellij.psi.impl.PsiManagerImpl - start 130, end 130, s.length() 39 <br/><div><details class=""wiki-details"" open><summary><pre class=""wiki-exception-title"">java.lang.IndexOutOfBoundsException: start 130, end 130, s.length() 39</pre></summary><span class=""wiki-hellip wiki-hidden"">&hellip;</span><pre class=""wiki-exception"">&nbsp;<b>at</b> java.lang.AbstractStringBuilder.append(<a class=""dsLink"" txt=""java/lang/AbstractStringBuilder.java"" lne=""453"" title=""Open in IDE"">AbstractStringBuilder.java:453</a>)<br/>&nbsp;<b>at</b> java.lang.StringBuilder.append(<a class=""dsLink"" txt=""java/lang/StringBuilder.java"" lne=""179"" title=""Open in IDE"">StringBuilder.java:179</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer$DocumentChangeTransaction.b(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""395"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:395</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer$DocumentChangeTransaction.replace(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""300"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:300</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.insertString(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""161"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:161</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer$2.syncDocument(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""111"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:111</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer$1.run(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""91"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:91</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.TextBlock.performAtomically(<a class=""dsLink"" txt=""com/intellij/psi/impl/TextBlock.java"" lne=""102"" title=""Open in IDE"">TextBlock.java:102</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.a(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""88"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:88</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiToDocumentSynchronizer.childAdded(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiToDocumentSynchronizer.java"" lne=""108"" title=""Open in IDE"">PsiToDocumentSynchronizer.java:108</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiManagerImpl.a(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiManagerImpl.java"" lne=""441"" title=""Open in IDE"">PsiManagerImpl.java:441</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.PsiManagerImpl.childAdded(<a class=""dsLink"" txt=""com/intellij/psi/impl/PsiManagerImpl.java"" lne=""326"" title=""Open in IDE"">PsiManagerImpl.java:326</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.wrappers.PsiEventWrapperAspect.a(<a class=""dsLink"" txt=""com/intellij/pom/wrappers/PsiEventWrapperAspect.java"" lne=""93"" title=""Open in IDE"">PsiEventWrapperAspect.java:93</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.wrappers.PsiEventWrapperAspect.update(<a class=""dsLink"" txt=""com/intellij/pom/wrappers/PsiEventWrapperAspect.java"" lne=""49"" title=""Open in IDE"">PsiEventWrapperAspect.java:49</a>)<br/>&nbsp;<b>at</b> com.intellij.pom.core.impl.PomModelImpl.runTransaction(<a class=""dsLink"" txt=""com/intellij/pom/core/impl/PomModelImpl.java"" lne=""161"" title=""Open in IDE"">PomModelImpl.java:161</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.ChangeUtil.prepareAndRunChangeAction(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/ChangeUtil.java"" lne=""177"" title=""Open in IDE"">ChangeUtil.java:177</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addChild(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""673"" title=""Open in IDE"">CompositeElement.java:673</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addChildren(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""780"" title=""Open in IDE"">CompositeElement.java:780</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.codeStyle.CodeEditUtil.addChildren(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/codeStyle/CodeEditUtil.java"" lne=""84"" title=""Open in IDE"">CodeEditUtil.java:84</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.CompositeElement.addInternal(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/CompositeElement.java"" lne=""530"" title=""Open in IDE"">CompositeElement.java:530</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.tree.java.ClassElement.addInternal(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/tree/java/ClassElement.java"" lne=""150"" title=""Open in IDE"">ClassElement.java:150</a>)<br/>&nbsp;<b>at</b> com.intellij.psi.impl.source.JavaStubPsiElement.add(<a class=""dsLink"" txt=""com/intellij/psi/impl/source/JavaStubPsiElement.java"" lne=""79"" title=""Open in IDE"">JavaStubPsiElement.java:79</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.PushDownProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/PushDownProcessor.java"" lne=""362"" title=""Open in IDE"">PushDownProcessor.java:362</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.PushDownProcessor.performRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/PushDownProcessor.java"" lne=""143"" title=""Open in IDE"">PushDownProcessor.java:143</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$7.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""444"" title=""Open in IDE"">BaseRefactoringProcessor.java:444</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(<a class=""dsLink"" txt=""com/intellij/openapi/application/impl/ApplicationImpl.java"" lne=""902"" title=""Open in IDE"">ApplicationImpl.java:902</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.a(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""441"" title=""Open in IDE"">BaseRefactoringProcessor.java:441</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.access$000(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor/access.java"" lne=""70"" title=""Open in IDE"">BaseRefactoringProcessor.java:70</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor$3.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""299"" title=""Open in IDE"">BaseRefactoringProcessor.java:299</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""117"" title=""Open in IDE"">CommandProcessorImpl.java:117</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(<a class=""dsLink"" txt=""com/intellij/openapi/command/impl/CommandProcessorImpl.java"" lne=""93"" title=""Open in IDE"">CommandProcessorImpl.java:93</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.execute(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""295"" title=""Open in IDE"">BaseRefactoringProcessor.java:295</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.doRun(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""219"" title=""Open in IDE"">BaseRefactoringProcessor.java:219</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.BaseRefactoringProcessor.run(<a class=""dsLink"" txt=""com/intellij/refactoring/BaseRefactoringProcessor.java"" lne=""516"" title=""Open in IDE"">BaseRefactoringProcessor.java:516</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog.invokeRefactoring(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""170"" title=""Open in IDE"">RefactoringDialog.java:170</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.PushDownDialog.doAction(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/PushDownDialog.java"" lne=""120"" title=""Open in IDE"">PushDownDialog.java:120</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog.doRefactorAction(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""85"" title=""Open in IDE"">RefactoringDialog.java:85</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.ui.RefactoringDialog$RefactorAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/ui/RefactoringDialog.java"" lne=""144"" title=""Open in IDE"">RefactoringDialog.java:144</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2028"" title=""Open in IDE"">AbstractButton.java:2028</a>)<br/>&nbsp;<b>at</b> javax.swing.AbstractButton$Handler.actionPerformed(<a class=""dsLink"" txt=""javax/swing/AbstractButton.java"" lne=""2351"" title=""Open in IDE"">AbstractButton.java:2351</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.fireActionPerformed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""387"" title=""Open in IDE"">DefaultButtonModel.java:387</a>)<br/>&nbsp;<b>at</b> javax.swing.DefaultButtonModel.setPressed(<a class=""dsLink"" txt=""javax/swing/DefaultButtonModel.java"" lne=""242"" title=""Open in IDE"">DefaultButtonModel.java:242</a>)<br/>&nbsp;<b>at</b> javax.swing.plaf.basic.BasicButtonListener.mouseReleased(<a class=""dsLink"" txt=""javax/swing/plaf/basic/BasicButtonListener.java"" lne=""236"" title=""Open in IDE"">BasicButtonListener.java:236</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processMouseEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6375"" title=""Open in IDE"">Component.java:6375</a>)<br/>&nbsp;<b>at</b> javax.swing.JComponent.processMouseEvent(<a class=""dsLink"" txt=""javax/swing/JComponent.java"" lne=""3267"" title=""Open in IDE"">JComponent.java:3267</a>)<br/>&nbsp;<b>at</b> java.awt.Component.processEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""6140"" title=""Open in IDE"">Component.java:6140</a>)<br/>&nbsp;<b>at</b> java.awt.Container.processEvent(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2083"" title=""Open in IDE"">Container.java:2083</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4737"" title=""Open in IDE"">Component.java:4737</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2141"" title=""Open in IDE"">Container.java:2141</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4565"" title=""Open in IDE"">Component.java:4565</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.retargetMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4619"" title=""Open in IDE"">Container.java:4619</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.processMouseEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4280"" title=""Open in IDE"">Container.java:4280</a>)<br/>&nbsp;<b>at</b> java.awt.LightweightDispatcher.dispatchEvent(<a class=""dsLink"" txt=""java/awt/LightweightDispatcher.java"" lne=""4210"" title=""Open in IDE"">Container.java:4210</a>)<br/>&nbsp;<b>at</b> java.awt.Container.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Container.java"" lne=""2127"" title=""Open in IDE"">Container.java:2127</a>)<br/>&nbsp;<b>at</b> java.awt.Window.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/Window.java"" lne=""2482"" title=""Open in IDE"">Window.java:2482</a>)<br/>&nbsp;<b>at</b> java.awt.Component.dispatchEvent(<a class=""dsLink"" txt=""java/awt/Component.java"" lne=""4565"" title=""Open in IDE"">Component.java:4565</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""684"" title=""Open in IDE"">EventQueue.java:684</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$000(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""85"" title=""Open in IDE"">EventQueue.java:85</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""643"" title=""Open in IDE"">EventQueue.java:643</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""641"" title=""Open in IDE"">EventQueue.java:641</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""87"" title=""Open in IDE"">AccessControlContext.java:87</a>)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""98"" title=""Open in IDE"">AccessControlContext.java:98</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$2.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""657"" title=""Open in IDE"">EventQueue.java:657</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$2.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""655"" title=""Open in IDE"">EventQueue.java:655</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""87"" title=""Open in IDE"">AccessControlContext.java:87</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""654"" title=""Open in IDE"">EventQueue.java:654</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.e(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""699"" title=""Open in IDE"">IdeEventQueue.java:699</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""534"" title=""Open in IDE"">IdeEventQueue.java:534</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.b(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""420"" title=""Open in IDE"">IdeEventQueue.java:420</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""378"" title=""Open in IDE"">IdeEventQueue.java:378</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""296"" title=""Open in IDE"">EventDispatchThread.java:296</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""211"" title=""Open in IDE"">EventDispatchThread.java:211</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""205"" title=""Open in IDE"">EventDispatchThread.java:205</a>)<br/>&nbsp;<b>at</b> java.awt.Dialog$1.run(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1044"" title=""Open in IDE"">Dialog.java:1044</a>)<br/>&nbsp;<b>at</b> java.awt.Dialog$3.run(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1096"" title=""Open in IDE"">Dialog.java:1096</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.awt.Dialog.show(<a class=""dsLink"" txt=""java/awt/Dialog.java"" lne=""1094"" title=""Open in IDE"">Dialog.java:1094</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.a(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""742"" title=""Open in IDE"">DialogWrapperPeerImpl.java:742</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""738"" title=""Open in IDE"">DialogWrapperPeerImpl.java:738</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/impl/DialogWrapperPeerImpl.java"" lne=""426"" title=""Open in IDE"">DialogWrapperPeerImpl.java:426</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.DialogWrapper.showAndGetOk(<a class=""dsLink"" txt=""com/intellij/openapi/ui/DialogWrapper.java"" lne=""1382"" title=""Open in IDE"">DialogWrapper.java:1382</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.ui.DialogWrapper.show(<a class=""dsLink"" txt=""com/intellij/openapi/ui/DialogWrapper.java"" lne=""1367"" title=""Open in IDE"">DialogWrapper.java:1367</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.JavaPushDownHandler.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/JavaPushDownHandler.java"" lne=""105"" title=""Open in IDE"">JavaPushDownHandler.java:105</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.memberPushDown.JavaPushDownHandler.invoke(<a class=""dsLink"" txt=""com/intellij/refactoring/memberPushDown/JavaPushDownHandler.java"" lne=""61"" title=""Open in IDE"">JavaPushDownHandler.java:61</a>)<br/>&nbsp;<b>at</b> com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(<a class=""dsLink"" txt=""com/intellij/refactoring/actions/BaseRefactoringAction.java"" lne=""89"" title=""Open in IDE"">BaseRefactoringAction.java:89</a>)<br/>&nbsp;<b>at</b> com.intellij.ui.popup.PopupFactoryImpl$ActionPopupStep$1.run(<a class=""dsLink"" txt=""com/intellij/ui/popup/PopupFactoryImpl.java"" lne=""619"" title=""Open in IDE"">PopupFactoryImpl.java:619</a>)<br/>&nbsp;<b>at</b> com.intellij.ui.popup.AbstractPopup$17.run(<a class=""dsLink"" txt=""com/intellij/ui/popup/AbstractPopup.java"" lne=""1162"" title=""Open in IDE"">AbstractPopup.java:1162</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.a(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""615"" title=""Open in IDE"">FocusManagerImpl.java:615</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.g(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""596"" title=""Open in IDE"">FocusManagerImpl.java:596</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.e(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""566"" title=""Open in IDE"">FocusManagerImpl.java:566</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl.access$200(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl/access.java"" lne=""55"" title=""Open in IDE"">FocusManagerImpl.java:55</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.wm.impl.FocusManagerImpl$IdleRunnable.runEdt(<a class=""dsLink"" txt=""com/intellij/openapi/wm/impl/FocusManagerImpl.java"" lne=""102"" title=""Open in IDE"">FocusManagerImpl.java:102</a>)<br/>&nbsp;<b>at</b> com.intellij.openapi.util.EdtRunnable$1.run(<a class=""dsLink"" txt=""com/intellij/openapi/util/EdtRunnable.java"" lne=""28"" title=""Open in IDE"">EdtRunnable.java:28</a>)<br/>&nbsp;<b>at</b> java.awt.event.InvocationEvent.dispatch(<a class=""dsLink"" txt=""java/awt/event/InvocationEvent.java"" lne=""209"" title=""Open in IDE"">InvocationEvent.java:209</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEventImpl(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""682"" title=""Open in IDE"">EventQueue.java:682</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.access$000(<a class=""dsLink"" txt=""java/awt/EventQueue/access.java"" lne=""85"" title=""Open in IDE"">EventQueue.java:85</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""643"" title=""Open in IDE"">EventQueue.java:643</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue$1.run(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""641"" title=""Open in IDE"">EventQueue.java:641</a>)<br/>&nbsp;<b>at</b> java.security.AccessController.doPrivileged(Native Method)<br/>&nbsp;<b>at</b> java.security.AccessControlContext$1.doIntersectionPrivilege(<a class=""dsLink"" txt=""java/security/AccessControlContext.java"" lne=""87"" title=""Open in IDE"">AccessControlContext.java:87</a>)<br/>&nbsp;<b>at</b> java.awt.EventQueue.dispatchEvent(<a class=""dsLink"" txt=""java/awt/EventQueue.java"" lne=""652"" title=""Open in IDE"">EventQueue.java:652</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.e(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""699"" title=""Open in IDE"">IdeEventQueue.java:699</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue._dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""538"" title=""Open in IDE"">IdeEventQueue.java:538</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.b(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""420"" title=""Open in IDE"">IdeEventQueue.java:420</a>)<br/>&nbsp;<b>at</b> com.intellij.ide.IdeEventQueue.dispatchEvent(<a class=""dsLink"" txt=""com/intellij/ide/IdeEventQueue.java"" lne=""378"" title=""Open in IDE"">IdeEventQueue.java:378</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpOneEventForFilters(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""296"" title=""Open in IDE"">EventDispatchThread.java:296</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForFilter(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""211"" title=""Open in IDE"">EventDispatchThread.java:211</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEventsForHierarchy(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""201"" title=""Open in IDE"">EventDispatchThread.java:201</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""196"" title=""Open in IDE"">EventDispatchThread.java:196</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.pumpEvents(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""188"" title=""Open in IDE"">EventDispatchThread.java:188</a>)<br/>&nbsp;<b>at</b> java.awt.EventDispatchThread.run(<a class=""dsLink"" txt=""java/awt/EventDispatchThread.java"" lne=""122"" title=""Open in IDE"">EventDispatchThread.java:122</a>)</pre></details></div></div>
","0"
"IDEA-86755","IntelliJ IDEA","reproduced","Use interface where possible doesn't change explicit type params","Anna Kozlova","28/05/2012 11:51","28/05/2012 11:51",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">interface Int {}<br/>class Impl implements Int {<br/><br/>}<br/><br/>class Usage {<br/>   void f(List&lt;Impl&gt; l){}<br/>    void bar() {<br/>        f(Collections.&lt;Impl&gt;emptyList());<br/>    }<br/>}</pre></div>
","0"
"IDEA-86034","IntelliJ IDEA","","Java refactoring: Improve 'field rename' processing","Denis Zhdanov","14/05/2012 09:19","14/05/2012 10:07",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider the following code:<br/><pre class=""wikicode prettyprint"">class Test {<br/><br/>    private int field;<br/><br/>    Test(int field) {<br/>        this.field = field;<br/>    }<br/><br/>    void test() {<br/>        field = 1;<br/>    }<br/>}</pre><br/>Suppose a user invokes<em> &#39;Rename&#39; </em>refactoring against the<em> &#39;field&#39; </em>and types<em> &#39;myField&#39; </em>as a new value.<br/><br/>It would be really cool if the IDE offers to remove unnecessary<em> &#39;this.&#39; </em>qualification at least from the constructor.</div>
","0"
"IDEA-85820","IntelliJ IDEA","","Java refactoring: Improve 'find and replace code duplicates' processing for string literals","Denis Zhdanov","09/05/2012 07:39","09/05/2012 07:39",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><em> &#39;Find and replace code duplicates&#39; </em>refactoring fails to process string literals with partial match.<br/><br/>Example:<br/><br/><pre class=""wikicode prettyprint"">package org.denis;<br/><br/>public class BrokenAlignment {<br/><br/>    public static final String PATH = &quot;$ROOT$&quot;;<br/><br/>    public static void main(String[] args) throws InterruptedException {<br/>        System.out.println(&quot;$ROOT$/other.xml&quot;);<br/>    }<br/>}</pre><br/>The refactoring is called against the &#39;PATH&#39; constant. Expected result is below, however, the file stays unchanged:<br/><br/><pre class=""wikicode prettyprint"">package org.denis;<br/><br/>public class BrokenAlignment {<br/><br/>    public static final String PATH = &quot;$ROOT$&quot;;<br/><br/>    public static void main(String[] args) throws InterruptedException {<br/>        System.out.println(PATH + &quot;/other.xml&quot;);<br/>    }<br/>}</pre></div>
","2"
"IDEA-84761","IntelliJ IDEA","","Problem with renaming module, package and switching to package path with IDEA and Perforce","Serge Baranov","17/04/2012 08:41","08/05/2012 17:49",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Support feedback:<br/><br/>I wonder what the best workflow would be to rename one of our Java<br/>applications (that is a module in an IntelliJ project) from &quot;Monitor&quot; to<br/>&quot;Profiler&quot; using IntelliJ IDEA Ultimate with Perforce VCS support and, if<br/>needed, Perforce programs (eg. P4V and p4.exe). I&#39;ve read up and watched<br/>videos about IntelliJ&#39;s refactor, move and copy support, and have used P4 a<br/>lot, but would appreciate some guidance for what order and which features to<br/>use for the following tasks.:<br/><br/>I need to:<br/><br/>A. Change package name (eg. from foo.monitor to bar.profiler)<br/><br/>B. Move source root directory (eg. from c:\src\monitor\java to c:\src<br/>\profiler\java)<br/><br/>C. Switch from non-package directories to package directories (eg. from<br/>java*.java to java\bar\profiler*.java).<br/><br/>In other words, A, B, and C will move source from:<br/>        c:\src\monitor\java*.java<br/>to:<br/>        c:\src\profiler\java\bar\profiler*.java<br/><br/>D. Rename a lot of classes, methods, variables, etc.<br/><br/>A &amp; D seem straightforward in IDEA, and I know how to do B and C with P4.<br/>Can you suggest a workflow to perform A, B &amp; C in IDEA that maintains VCS<br/>lineage?<br/><br/>FYI, the Java files are built externally from IDEA, and so far we don&#39;t keep<br/>IDEA files under VCS.<br/><br/><hr/><br/>Works for renaming module (from MLMonitor to MLProfiler), but can&#39;t be<br/>undone in Local History, and more importantly rename directory does not<br/>work!<br/><br/><ul class=""wiki-list0""><li> If I choose the Rename Package option, it asks if I want to change package</li></ul>&quot;foo.monitor&quot; but just searches for &quot;monitor&quot; (which is the default choice<br/>in the field).<br/><br/><ul class=""wiki-list0""><li> If I choose the Rename Directory option, it asks if I want to change</li></ul>directory &quot;java&quot;. It won&#39;t let me change:<br/>      c:\src\monitor\java<br/>to<br/>      c:\src\profiler\java<br/><br/><hr/>I want to:<br/><br/><ul class=""wiki-list0""><li> Change the package from &quot;foo.monitor&quot; to &quot;bar.profiler&quot;<br/><br/></li><li> Change the content root from &quot;c:\src\users\user\monitor\java&quot; to &quot;c:\src</li></ul>\users\user\profiler\java&quot;<br/><br/><ul class=""wiki-list0""><li> Change from having all (non-resource) Java files right in the java folder,</li></ul>to be in package-path folders under the java folder (so I would no longer<br/>need to specify a package prefix for the java folder).<br/><br/><ul class=""wiki-list0""><li> The module name in IDEA isn&#39;t critical, but I would like to change it from</li></ul>foo to bar.<br/><br/>Once those are done (and added to pending Peforce changes) I would do more<br/>straightforward renaming of classes, methods, variables, etc.<br/><br/><hr/><br/>FYI, I&#39;ve found that Refactor&gt;Move in the Commander is much closer to what<br/>I&#39;m after, but seems to be hung up by using a package prefix. Eg. when I<br/>create a new package called &quot;bar.profiler&quot; to be under the highest level<br/>folder it lets me access (which has package prefix &quot;foo.monitor&quot;), the new<br/>package created is &quot;foo.monitor.bar.profiler&quot;.<br/><br/>Another issue seems to be that IDEA seems to only work on one level of a<br/>package name, eg. when it prompts for a new package it says the name is<br/>invalid if it has a period in it.</div>
","0"
"IDEA-85662","IntelliJ IDEA","","push-down method and pull-up method refactorings do not take the change in the type of ""this"" into account","Julien Cohen","04/05/2012 10:36","04/05/2012 10:36",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The push-down method changes the behavior of programs when the static type of &quot;this&quot; matters. I give below an example where the behavior is changed, and the expected result if we want to preserve the behavior.<br/><br/>&ndash; Initial Program (prints 1)<br/><br/>class A {<br/>    <br/>    static int m(A x){ return 1;}<br/>    static int m(B x){ return 2;}<br/><br/>    int n(){<br/><div><pre class=""wiki-exception-title"">&nbsp;<b>return</b> A.m(this)</pre></div>;<br/>    }<br/>}<br/><br/>class B extends A {<br/>}<br/><br/>class Client {<br/>    <br/>    public static void main(String[] args) {<br/>        System.out.println(new B().n());<br/>    }<br/>}<br/><br/><br/>&ndash; Result program after push-down method n (prints 2)<br/><br/>class A {<br/>    <br/>    static int m(A x){ return 1;}<br/>    static int m(B x){ return 2;}<br/><br/>}<br/><br/>class B extends A {<br/>    int n(){<br/><div><pre class=""wiki-exception-title"">&nbsp;<b>return</b> A.m(this)</pre></div>;<br/>    }<br/>}<br/><br/>class Client {<br/>    <br/>    public static void main(String[] args) {<br/>        System.out.println(new B().n());<br/>    }<br/>}<br/><br/>&ndash; Expected result (so that the behavior is preserved)<br/><br/>class B extends A {<br/>    int n(){<br/><div><pre class=""wiki-exception-title"">&nbsp;<b>return</b> A.m((A)</pre></div>this);<br/>    }<br/>}<br/><br/><br/>The bug also occurs in the opposite way, with pull-up method refactoring. Consider the second program above (the one without the cast, that prints 2) and apply pull-up method on n, you will get the first program as a result, which is also a change in the semantics.</div>
","0"
"IDEA-85509","IntelliJ IDEA","","When extracting a String variable from a method that's @NonNls, annotate the variable as @NonNls","Anders Wallgren","01/05/2012 16:21","01/05/2012 16:21",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When extracting a String variable from a method that&#39;s @NonNls, annotate the variable as @NonNls.</div>
","0"
"IDEA-26372","IntelliJ IDEA","","Refactoring: Move of multiple files","Alexander Wajda","30/11/2009 11:43","30/03/2012 11:25",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">See <a href=""http://youtrack.jetbrains.net/issue/IDEADEV-33013"" target=""_blank"" rel=""noopener noreferrer"">http://youtrack.jetbrains.net/issue/IDEADEV-33013</a><br/>That was not fixed. In build #9952 it is still broken.<br/>I&#39;m attaching the animation recorded from my desktop.<br/>Thanks.</div>
","0"
"IDEA-83322","IntelliJ IDEA","","Improved rename of variable for boolean variables (is, has - variant)","Gabriel","22/03/2012 10:54","22/03/2012 10:54",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">See the attached screenshot</div>
","0"
"IDEA-83169","IntelliJ IDEA","","Tweak rename dropdown suggestions","Martyn Haigh","20/03/2012 09:48","20/03/2012 09:58",,"Normal","Cosmetics",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I propose a slight tweak to the rename intelligent suggestions.  If there are continuous uppercase characters next to each other, keep the first letter uppercase and make the rest lower case, unless followed by other lower case characters in which case the last upper case character is preserved.  If at the start of a var then the initial upper case character should be lower case.<br/><br/>For example:<br/>  fileAPI<br/><br/>should also have the suggestion:<br/>  fileApi<br/><br/>Another type:<br/>  APIClient<br/><br/>should also have the suggestion<br/>  apiClient</div>
","0"
"IDEA-82664","IntelliJ IDEA","","refactoring: move inner to upper level: pass individual fields, not the outer class","Cristian Vasile Mocanu","13/03/2012 08:28","13/03/2012 11:30",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">For non-static inner classes the &quot;Move inner to upper level&quot; class refactoring offers to pass outer class&#39; instance as parameter.<br/><br/>This is not very useful in my opinion.<br/><br/>Replace this option (or add another mutually exclusive option) to pass each individual referenced field from the outer class instead of the outer class itself.<br/><br/>This will really help in isolating dependencies between classes.</div>
","0"
"IDEA-81915","IntelliJ IDEA","","Move Method could be aware of Logger references","Hamlet D'Arcy","27/02/2012 05:36","28/02/2012 05:48",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It would be nice if the Move Method refactoring were aware of Logger static fields. <br/><br/>For example, consider moving the method &quot;myMethod&quot; to a different class. You start with this code: <br/><pre class=""wikicode prettyprint"">class MyClass {<br/>    private static final Logger LOGGER = Logger.getLogger(MyClass.class);<br/><br/>    void myMethod() {<br/>        LOGGER.info(&quot;my method called...&quot;); <br/>    }<br/>}<br/><br/>class MyOtherClass {<br/><br/>}</pre><br/>And I would like to be able to have this code be the refactoring output: <br/><pre class=""wikicode prettyprint"">class MyClass {<br/>    private static final Logger LOGGER = Logger.getLogger(MyClass.class);<br/><br/>    void myMethod() {<br/>        LOGGER.info(&quot;my method called...&quot;); <br/>    }<br/>}<br/><br/>class MyOtherClass {<br/>    private static final Logger LOGGER = Logger.getLogger(MyOtherClass.class);<br/><br/>    void myMethod() {<br/>        LOGGER.info(&quot;my method called...&quot;); <br/>    }<br/>}</pre><br/>The important part here is that IDEA knew the LOGGER field was a Logger and did a copy on that field not a move. And the initializationExpression of the Logger has the correct static class reference. <br/><br/>I think the Move Method refactoring should be aware of these Logger classes. If IDEA sees one then it can ask the user if he wants to leave the Logger reference or create a copy of a new Logger in the destination class. </div>
","1"
"IDEA-81389","IntelliJ IDEA","jax-rs","Proposed refactoring : move annotation(s) on method / class definition to parent or child","Brice Dutheil","15/02/2012 11:24","17/02/2012 14:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Proposed refactoring<br/><ol class=""wiki-list0""><li> When placing the cursor on an annotation, propose to move this annotation to the parent class or interface<br/></li><li> When placing the cursor on the method or class definition, propose to move all / chosen annotations to parent or child</li></ol><br/><u>Example on a method :</u><br/><pre class=""wikicode prettyprint"">class A implement Letter { @GET void method() { ... } }</pre>to<br/><pre class=""wikicode prettyprint"">class A implement Letter { void method() { ... } }<br/>interface Letter { @GET void method(); }</pre><br/><u>more agressive example when selecting all annotations of the class, and selecting which one of the two interfaces if there is ambiguity :</u><br/><pre class=""wikicode prettyprint"">@Produces(...) @Path(...) class A implement Letter, Case { @GET void method() { ... } }</pre>to<br/><pre class=""wikicode prettyprint"">class A implement Letter { void method() { ... } }<br/>interface Case { }<br/>@Produces(...) @Path(...) interface Letter { @GET void method(); }</pre><br/><br/>Of course if the annotation is already present it doesn&#39;t make sense.<br/><br/>What do you think about that one ? Maybe the aggressive is to aggressive, so it could be first implemented on <em>annotation by annotation</em> basis.</div>
","0"
"IDEA-68835","IntelliJ IDEA","","inline refactorings: completion list should not cover inline dialog","Cristian Vasile Mocanu","27/04/2011 04:05","19/01/2012 10:12",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When invoking an inline refactoring, IntellIj should make sure that the completion list does not cover the inline dialog.<br/><br/>See screenshot.</div>
","1"
"IDEA-79200","IntelliJ IDEA","","""Convert to instance method"" could also propose to add an instance field of the type that own the static method","Brice Dutheil","21/12/2011 12:47","03/01/2012 08:35",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Could it be possible to extend to power of this refactoring to static methods declared in other types.<br/><br/>Say I have this kind of code : <br/><br/><pre class=""wikicode prettyprint"">class CXFUtils {<br/>    public static String extractSomeInformations(...) { }<br/>}<br/><br/>class TypeHandler {<br/>   public Response toResponse(...) {<br/>       Response.ok().entity(CXFUtils.extractSomeInformations(...)).build();<br/>   }<br/>}</pre><br/>The CXFUtils classs might be or might not be in the same module, but open for modification. <br/>Today the &quot;Convert to instance method&quot; refactoring won&#39;t work in these cases. What could be cool is to propose the <span class=""monospace"">CXFUtils</span> as an instance field of <span class=""monospace"">TypeHandler</span>.<br/><br/>Although there might be some challenges to make sure that CXFUtils is tranformed in an instance class, removing static keywords from methods, removing abstract keyword, maybe checking that the constructor is not provate.<br/><br/><br/>Writing this I feel like this new refactoring could be named &quot;Convert static util class to instance class&quot;.<br/><br/>What do you think of this enhancement/feature ?</div>
","1"
"IDEA-19077","IntelliJ IDEA","","Usability: merge ""delete getters/setters?"" dialog with ""remove field"" dialog","Patrick Wright","11/08/2008 12:12","13/10/2011 13:36",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">1) place cursor over/highlight a field in a class<br/>2) trigger safe delete<br/>=&gt; prompted once for safe delete, and if there is a getter/setter, prompted again to remove those as well<br/><br/>Suggestion: merge the second prompt (for getters and setters) into the primary safe delete dialog<br/><br/>Rationale: there are a number of cases where IDEA is still too modal in prompts&ndash;this is one of them. When I&#39;m in rapid-design more, I will add, rename, move, and delete fields very often. The second dialog causes an interruption for individual &quot;safe delete&quot; action.<br/><br/><br/>Thanks!</div>
","0"
"IDEA-75027","IntelliJ IDEA","","Moving lib file doesn't fix the iml configuration","Kirill Likhodedov","30/09/2011 05:38","01/10/2011 22:28",,"Normal","Bug",,"nik","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">0. I&#39;ve got a module level library, in a <span class=""monospace"">lib</span> folder inside the module directory. A link to it is written in the iml file of the module.<br/>1. I&#39;ve moved the jar file to a subfolder of <span class=""monospace"">lib/</span><br/>Expected: iml file is updated with new destination of the lib.<br/>Actual: iml file is not updated, the lib is no more connected to the module.</div>
","0"
"IDEA-74379","IntelliJ IDEA","","Switch between single and multiple return statements refactoring/intention","Tomasz Nurkiewicz","16/09/2011 07:26","20/09/2011 13:04",,"Normal","Feature",,"basleijdekkers","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Very often I see code with the following structure:<br/><br/><pre class=""wikicode prettyprint"">int foo() {<br/>  int result;<br/>  if(bar)<br/>    result = 5;<br/>  else<br/>    result = 42;<br/>  return result;<br/>}</pre><br/>It would be nice if IntelliJ provided an intention to refactor it to the following structure:<br/><br/><pre class=""wikicode prettyprint"">int foo() {<br/>  if(bar)<br/>    return 5;<br/>  else<br/>    return 42;<br/>}</pre><br/>Of course the opposite intention would be nice as well for those being unhappy with multiple return statements.</div>
","0"
"IDEA-54542","IntelliJ IDEA","","""Make Static"" should have an option of selecting supertype when creating parameter for 'this'","Dmitry Jemerov","30/04/2010 13:46","16/09/2011 11:46",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I invoke &quot;Make Static&quot; on an instance method that uses &#39;this&#39;, it offers me to create a parameter to replace &#39;this&#39;, and prompts for its name. However, its type will always be the same as the type of the containing class, even if a superclass would be valid for the method. I&#39;d like to have the possibility to choose the exact type, like in &quot;Introduce Variable&quot; refactoring.</div>
","0"
"IDEA-72898","IntelliJ IDEA","","""Push members down"" with ""make abstract"" should create anonymous inner classes where the source class is instantiated","Dmitry Jemerov","04/08/2011 15:18","04/08/2011 15:18",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">class C {<br/>  void foo() { System.out.println(&quot;bar&quot;); }<br/>}<br/><br/>class X {<br/>  void client() {<br/>    C c = new C();<br/>  }<br/>}</pre><br/>Push &quot;foo&quot; down with &quot;keep abstract&quot; checked. Currently the &quot;new C()&quot; call is unchanged. Would be better to change it to:<br/><br/><pre class=""wikicode prettyprint"">class X {<br/>  void client() {<br/>    C c = new C() {<br/>      void foo() { System.out.println(&quot;bar&quot;); }<br/>    };<br/>  }<br/>}</pre></div>
","0"
"IDEA-71780","IntelliJ IDEA","reproduced","Encapsulate fields: wrong getter name suggestion","Thomas Singer","05/07/2011 05:46","18/07/2011 13:47",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">IDEA suggests for the variable <span class=""monospace"">xOffset</span> the getter name <span class=""monospace"">getxOffset</span> instead of <span class=""monospace"">getXOffset</span>.</div>
","0"
"IDEA-71805","IntelliJ IDEA","","Rename method does not replace in Strings / Comments in another class","Zak Wessels","05/07/2011 12:42","08/07/2011 10:30",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When renaming a method, it only searches in comments and strings in the class that the method is contained in.<br/><br/>The same method declared in a string field in <strong>another</strong> class does not get renamed<br/><br/>Steps to re-produce:<br/><br/><ul class=""wiki-list0""><li> HelloWorld class<br/></li><li> HelloWorldTestCase class</li></ul><br/>HelloWorld class declares a method private method, <span class=""monospace"">sayHelloWorld();</span><br/><br/>HelloWorldTestCase invokes the private method via Reflection, and as a parameter passing in the name of the method, <br/><br/><span class=""monospace"">ReflectionUtil.invokeMethod(helloWorld,&quot;sayHelloWorld&quot;);</span><br/><br/>Renaming the method in HelloWorld from <span class=""monospace"">sayHelloWorld();</span> to <span class=""monospace"">sayHelloToRealWorld();</span> does not cause the method to be named to : <span class=""monospace"">ReflectionUtil.invokeMethod(helloworld,&quot;sayHelloToRealWorld&quot;);</span> , rather it stays as <span class=""monospace"">ReflectionUtil.invokeMethod(helloWorld,&quot;sayHelloWorld&quot;);</span><br/><br/>If the renaming is done in the same class, then it works as expected, however as soon as it is declared in another class it does not</div>
","0"
"IDEA-71369","IntelliJ IDEA","","Usability: Pull members up always chooses superclass","Anders Wallgren","23/06/2011 17:59","24/06/2011 04:01",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I find that I nearly always want to move a method from an Impl class to the relevant interface, not to the superclass.<br/><br/>It would be nice to have the option to default to the Foo when pulling members up from FooImpl.<br/><br/>Alternatively, it would be nice if the choice were sticky, at least for the session, so that once I&#39;ve chosen the interface to pull up to, that I don&#39;t have redo that selection next time.</div>
","0"
"IDEA-71090","IntelliJ IDEA","","XML refactoring: Sorting selected  XML Schema by xsd:element name","Rob Leland","16/06/2011 17:21","21/06/2011 11:56",,"Normal","Feature",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I am using IntelliJ to write a schema for a web service.<br/><br/>The file itself is about 1500 lines long and its hard to manually sort the element names:<br/><br/>It would be nice is I could highlight a section of code such as:<br/><br/><div class=""java code title"">Code</div><pre class=""wikicode prettyprint"">  &lt;xsd:element name=&quot;A&quot; type=&quot;xsd:integer&quot; nillable=&quot;false&quot;&gt;<br/>    &lt;xsd:annotation&gt;<br/>      &lt;xsd:documentation&gt;A Comment about A&lt;/xsd:documentation&gt;<br/>    &lt;/xsd:annotation&gt;<br/>  &lt;/xsd:element&gt;<br/>  &lt;xsd:element name=&quot;C&quot; type=&quot;xsd:integer&quot; nillable=&quot;false&quot;&gt;<br/>    &lt;xsd:annotation&gt;<br/>      &lt;xsd:documentation&gt;A comment about C&lt;/xsd:documentation&gt;<br/>    &lt;/xsd:annotation&gt;<br/>  &lt;/xsd:element&gt;<br/>  &lt;xsd:element name=&quot;B&quot; type=&quot;xsd:integer&quot; nillable=&quot;false&quot;&gt;<br/>    &lt;xsd:annotation&gt;<br/>      &lt;xsd:documentation&gt;A comment about B&lt;/xsd:documentation&gt;<br/>    &lt;/xsd:annotation&gt;<br/>  &lt;/xsd:element&gt;<br/>}</pre><br/>Then select &#39;Sort&#39; which would produce:<br/><div class=""java code title"">Code</div><pre class=""wikicode prettyprint"">   &lt;xsd:element name=&quot;A&quot; type=&quot;xsd:integer&quot; nillable=&quot;false&quot;&gt;<br/>    &lt;xsd:annotation&gt;<br/>      &lt;xsd:documentation&gt;A Comment about A&lt;/xsd:documentation&gt;<br/>    &lt;/xsd:annotation&gt;<br/>  &lt;/xsd:element&gt;<br/>  &lt;xsd:element name=&quot;B&quot; type=&quot;xsd:integer&quot; nillable=&quot;false&quot;&gt;<br/>    &lt;xsd:annotation&gt;<br/>      &lt;xsd:documentation&gt;A comment about B&lt;/xsd:documentation&gt;<br/>    &lt;/xsd:annotation&gt;<br/>  &lt;/xsd:element&gt;<br/>  &lt;xsd:element name=&quot;C&quot; type=&quot;xsd:integer&quot; nillable=&quot;false&quot;&gt;<br/>    &lt;xsd:annotation&gt;<br/>      &lt;xsd:documentation&gt;A comment about C&lt;/xsd:documentation&gt;<br/>    &lt;/xsd:annotation&gt;<br/>  &lt;/xsd:element&gt;<br/>}</pre><br/>Not sure how this would be done using AST bit with XSLT something like xsl:sort could be used </div>
","0"
"IDEA-70954","IntelliJ IDEA","","While introducing a method parameter, be able to move it left/right in the list with alt+left/right","Melv Ng","14/06/2011 06:40","14/06/2011 07:23",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Easier to select the order of a newly introduced parameter.</div>
","0"
"IDEA-70782","IntelliJ IDEA","","Fatal false detection when migrating type  [long vs. java.lang.Object]  (probably causes hangup)","Gabriel","08/06/2011 10:33","08/06/2011 11:37",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Never managed to refactor. 10x hangup.</div>
","0"
"IDEA-70207","IntelliJ IDEA","","Move instance method: allow move to arbitrary class","Cristian Vasile Mocanu","25/05/2011 10:51","26/05/2011 07:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I should be able to use the &quot;Move instance method&quot; to move a method to any class in the project.<br/><br/>If I don&#39;t want to choose an instance parameter, allow me to select an existing class (or enter a class name that will be created) and move the instance method into that class.<br/><br/>The method will become a static method, with the old &quot;this&quot; passed as the first parameter.<br/><br/>Of course, if the instance method is using any private methods or fields, I will be warned and given the option to continue, show in view or cancel (just like it works currently).<br/><br/>Affected version: 107.105 (10.5 release)</div>
","1"
"IDEA-69718","IntelliJ IDEA","","feature request: offer lazy init when introducing a field from an expression and selecting ""inititalize in current method""","dennis haupt","16/05/2011 10:32","16/05/2011 11:47",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">before:<br/><br/>return x;<br/><br/>after refactoring:<br/><br/>this.x = x;<br/>return this.x;<br/><br/>currently, i have to manually surround the generated code with if (x == null) {&lt;the assignment&gt;}</div>
","0"
"IDEA-68903","IntelliJ IDEA","","Refactor XML Element Name To Different Case","opticyclic","27/04/2011 12:44","28/04/2011 08:59",,"Normal","Feature",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Some useful quick fixes in XML refactoring would be to be able to change the case of an element/attribute etc<br/>See here for 4 different types of case<br/><a href=""http://stackoverflow.com/questions/1074447/case-conventions-on-element-names"" target=""_blank"" rel=""noopener noreferrer"">http://stackoverflow.com/questions/1074447/case-conventions-on-element-names</a></div>
","0"
"IDEA-20893","IntelliJ IDEA","","Create Constant - Allow Pascal-Case Suggestion","Jan Thomä","27/11/2008 09:49","19/04/2011 02:17",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Currently, when you create a constant from a String, the constant&#39;s name is all upper case. It would be helpful if one could select in the project&#39;s code style that constant names should be pascal cased or all upppercase. E.g.<br/><br/>&quot;my constant string&quot;  -&gt; create constant<br/><br/>When pascal casing is set, the variable name suggested would be &quot;MyConstantString&quot;. When all upper case is selected, the variable name suggested would be &quot;MY_CONSTANT_STRING&quot;. </div>
","1"
"IDEA-67962","IntelliJ IDEA","","rename refactor for folder in web resource directories doesn't work","Anton","12/04/2011 10:10","12/04/2011 11:17",,"Normal","Bug",,"nik","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">rename refactor for folder in web resource directories doesn&#39;t work<br/><br/>Reproduce steps on screenshots:</div>
","0"
"IDEA-64347","IntelliJ IDEA","","HTML file names inserted in empty HREF's","Julien Phalip","18/01/2011 20:42","19/01/2011 05:51",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">As originally reported in <a href=""http://devnet.jetbrains.net/thread/293020"" target=""_blank"" rel=""noopener noreferrer"">http://devnet.jetbrains.net/thread/293020</a> and confirmed as a bug by Dmitry Jemerov.<br/><br/>I&#39;m using Pycharm to work on Django projects. Sometimes, when I move an HTML template from one folder to another, PyCharm automatically inserts the name of the file (e.g. article.html) in the &lt;A&gt; tags that have an empty HREF (or that contains just &#39;#&#39;), for example:<br/> <br/>&lt;a href=&quot;article.html#&quot;&gt;Click me&lt;/a&gt;</div>
","0"
"IDEA-64116","IntelliJ IDEA","","Add a preview panel when refactoring with ""Extract Superclass"" or ""Extract Interface""","Clément Denis","12/01/2011 15:09","17/01/2011 12:15",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I extract a superclass or an interface from an existing class, I would like to see exactly what code I&#39;m extracting.<br/>As the dialog is modal, I can&#39;t see the code of the class I&#39;m refactoring.<br/>CTRL+SHIFT+I (quick definition) works, but only on the first selected method or field.<br/><br/>Maybe you could provide the same kind of preview as in the Find Usages panel ?</div>
","0"
"IDEA-63089","IntelliJ IDEA","","Refactoring: Rename folder doesn't change folder names for attached classes in appended module library","deleted","15/12/2010 04:46","15/12/2010 09:44",,"Normal","Bug",,"nik","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Refactoring Rename Module works as wanted but rename project folder does not. The appended module library will not fully be refactored.<br/>The source files points to the correct renamed project folder like the JavaDoc but the classes doesn&#39;t.<br/>Please find the attached Screenshot.<br/><br/>The project was originally located under<br/>/home/fibric/Documents/Projects/work/wsp-srv/<br/><br/>I used refactoring to rename the project folder from wsp-srv to wsp.<br/><br/>The project is now located unter<br/>/home/fibric/Documents/Projects/work/wsp/</div>
","0"
"IDEA-11539","IntelliJ IDEA","","introduce variable from write usage: needs copy assignment","Eugene Vigdorchik","14/02/2007 18:04","10/12/2010 08:48",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">&lt;selection&gt;primaryExpr&lt;/selection&gt; = expr;<br/><br/>Upon introducing variable var the folowing code should be produced:<br/><br/>Type var = expr;<br/>primaryExpr = var; //code logic breaks without this assignment<br/><br/>Note that in case of primaryExpr being itself a reference to local, it could be further inlined by &quot;inline variable assignment&quot; </div>
","0"
"IDEA-62752","IntelliJ IDEA","","Add a Refactoring which is based on Structure101 Transformations","Leif Hanack","09/12/2010 06:30","09/12/2010 06:37",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">With S101 you can define &quot;Transformations&quot; and virtually try out refactorings. Such a transformation looks like:<br/><br/>From: myproject.common.fit.*<br/>To: myproject.fit.{1}<br/><br/>or<br/><br/>From: myproject.components.*.*Fixture<br/>To: myproject.fit.fixture.{1}.{2}Fixture<br/><br/>It would be cool, if IDEA supports to make this virtual refactoring real!</div>
","0"
"IDEA-38342","IntelliJ IDEA","","Generate visitor support for class hierarchy","Exception Robot","27/04/2007 09:20","26/11/2010 05:16",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><ul class=""wiki-list0""><li> Generate visitor code<br/></li><li> Validate and suggest update on hierarchy change<br/></li></ul></div>
","2"
"IDEA-60227","IntelliJ IDEA","","Extract interface: replace usages with interface usage: can't quickly understand the place","Irina Chernushina","22/10/2010 08:11","29/10/2010 13:32",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When doing extract interface, and further, replacement of class usages with interface usages,<br/>can we show class names for the places renames of parameters/members are going to happen?<br/><br/>can we unite them with refactoring preview?<br/><br/>see picture</div>
","0"
"IDEA-36434","IntelliJ IDEA","","New refactoring: Introduce class...","Dave Yost","21/01/2007 23:07","27/09/2010 03:56",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">With code like this<br/><br/>      layeredPane = new JLayeredPane();<br/>      layeredPane.setPreferredSize(new Dimension(300, 310));<br/>      layeredPane.setBorder(BorderFactory.createTitledBorder(<br/>          &quot;Move the Mouse to Move Duke&quot;));<br/>      layeredPane.addMouseMotionListener(this);<br/>      ....<br/>    }<br/>  }<br/><br/>you should be able to point at layeredPane and ask IDEA to introduce a new class to encapsulate code relating to it.<br/><br/>      layeredPane = new OurLayeredPane(this);<br/>      ....<br/>    }<br/>  }<br/>  <br/>  class OurLayeredPane extends JLayeredPane {<br/>    OurLayeredPane(MouseMotionListener listener) {<br/>      setPreferredSize(new Dimension(300, 310));<br/>      setBorder(BorderFactory.createTitledBorder(&quot;Move the Mouse to Move Duke&quot;));<br/>      addMouseMotionListener(listener);<br/>    }<br/>  }<br/><br/>IDEA should do its best to drag along as much code as possible into the new class,<br/>soliciting confirmation on code you might not want to move.<br/><br/>The above extract is from the Java Tutorial LayeredPaneDemo.<br/>This tarball contains the original, my refactoring,<br/>and IDEA project and module files.<br/><a href=""http://Yost.com/computers/java/LayeredPaneDemo/LayeredPaneDemoRefactored.tgz"" target=""_blank"" rel=""noopener noreferrer"">http://Yost.com/computers/java/LayeredPaneDemo/LayeredPaneDemoRefactored.tgz</a></div>
","2"
"IDEA-58962","IntelliJ IDEA","","Extract JSP Tag does not add attributes for needed EL variables or taglibs","Norris Shelton","21/09/2010 10:08","22/09/2010 09:43",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I have this in a file, when I get a new requirement to also display this in another page:<br/><pre class=""wikicode prettyprint"">&lt;%--@elvariable id=&quot;revenueList&quot; type=&quot;java.util.List&quot;--%&gt;<br/>&lt;%@ taglib prefix=&quot;executiveTags&quot; tagdir=&quot;/WEB-INF/tags/executive&quot; %&gt;<br/><br/>...<br/>&lt;fieldset style=&quot;border: solid #000000 1px;&quot;&gt;<br/>    &lt;legend align=&quot;left&quot; class=&quot;text-header&quot;&gt;<br/>        Revenue<br/>    &lt;/legend&gt;<br/>    &lt;div style=&quot;padding-left:1em;&quot;&gt;<br/>        &lt;c:forEach var=&quot;revenue&quot; items=&quot;${revenueList}&quot;&gt;<br/>            &lt;executiveTags:revenueContent revenue=&quot;${revenue}&quot;/&gt;<br/>            &lt;br/&gt;<br/>        &lt;/c:forEach&gt;<br/>    &lt;/div&gt;<br/>&lt;/fieldset&gt;<br/>...</pre><br/>I extract the lines into /WEB-INF/tags/executive/revenue.tag, which places the following in my original file:<br/><pre class=""wikicode prettyprint"">&lt;executiveTags:revenue/&gt;</pre><br/>The entire contents of the tag file are:<br/><pre class=""wikicode prettyprint"">&lt;fieldset style=&quot;border: solid #000000 1px;&quot;&gt;<br/>    &lt;legend align=&quot;left&quot; class=&quot;text-header&quot;&gt;<br/>        Revenue<br/>    &lt;/legend&gt;<br/>    &lt;div style=&quot;padding-left:1em;&quot;&gt;<br/>        &lt;c:forEach var=&quot;revenue&quot; items=&quot;${revenueList}&quot;&gt;<br/>            &lt;executiveTags:revenueContent revenue=&quot;${revenue}&quot;/&gt;<br/>            &lt;br/&gt;<br/>        &lt;/c:forEach&gt;<br/>    &lt;/div&gt;<br/>&lt;/fieldset&gt;</pre><br/>The tag <strong>should</strong> have been:<br/><pre class=""wikicode prettyprint"">&lt;executiveTags:revenue revenueList=&quot;${revenueList}&quot;/&gt;</pre><br/>and the conents of the extracted tag file <strong>should</strong> have been:<br/><pre class=""wikicode prettyprint"">&lt;%@ attribute name=&quot;revenueList&quot; required=&quot;true&quot; type=&quot;java.util.List&quot; %&gt;<br/><br/>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;<a href=""http://java.sun.com/jsp/jstl/core"" target=""_blank"" rel=""noopener noreferrer"">http://java.sun.com/jsp/jstl/core</a>&quot; %&gt;<br/>&lt;%@ taglib prefix=&quot;executiveTags&quot; tagdir=&quot;/WEB-INF/tags/executive&quot; %&gt;<br/><br/>&lt;fieldset style=&quot;border: solid #000000 1px;&quot;&gt;<br/>    &lt;legend align=&quot;left&quot; class=&quot;text-header&quot;&gt;<br/>        Revenue<br/>    &lt;/legend&gt;<br/>    &lt;div style=&quot;padding-left:1em;&quot;&gt;<br/>        &lt;c:forEach var=&quot;revenue&quot; items=&quot;${revenueList}&quot;&gt;<br/>            &lt;executiveTags:revenueContent revenue=&quot;${revenue}&quot;/&gt;<br/>            &lt;br/&gt;<br/>        &lt;/c:forEach&gt;<br/>    &lt;/div&gt;<br/>&lt;/fieldset&gt;</pre></div>
","0"
"IDEA-55460","IntelliJ IDEA","reply needed","Deleting a package is not contained within the module","Maarten Billemont","02/06/2010 06:04","24/07/2010 14:55",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When you delete a package in a multi-module project, the package is deleted from any and all modules.<br/><br/>This may seem like common sense, but is in fact extremely counter-intuitive.  I don&#39;t see the package in my other modules when I press delete in one of them.<br/><br/>This has caused a lot of grief already, loosing uncommitted work in the package from other modules when deleting the package in one module.</div>
","3"
"IDEA-56350","IntelliJ IDEA","","Introduce Variable/Parameter on value of type Class uses too restricted type argument","Dmitry Jemerov","08/07/2010 07:27","08/07/2010 09:08",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">When I introduce parameter on a value of type Class (for example, PyFunction.class), it always gets the most restricted possible type (Class&lt;PyFunction&gt;). This is almost never what I want, and I need to change it manually to something like Class&lt;? extends PsiElement&gt;. There should be an option of selecting the necessary supertype in the Type combobox.</div>
","0"
"IDEA-56171","IntelliJ IDEA","","Extract interface: allow to check non-public members","Kirill Safonov","30/06/2010 07:47","30/06/2010 07:47",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">currently these are not visible</div>
","0"
"IDEA-54550","IntelliJ IDEA","","Attempting to move a small number of files to another package results in OOME","Anders Wallgren","30/04/2010 22:35","07/05/2010 15:07",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">See attached screenshot and log file.</div>
","0"
"IDEA-52731","IntelliJ IDEA","","New Refactoring - Introduce Return Value","Nick Pratt","08/03/2010 14:24","09/03/2010 10:17",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">With a void method, I would like to be able to put the caret over a variable and &quot;introduce return value&quot;, which would modify the method signature, and insert a return foo; statement (where appropriate).<br/><br/>With a method that already returned some object, I would like the refactoring to propose to introduce a return value object that wraps the existing return value along with the selected value (basically make a getFoo() method).</div>
","0"
"IDEA-52010","IntelliJ IDEA","","IDEA is removing path information from Spring context file on a rename of a configured placeholders file","Mark Vedder","03/02/2010 14:12","18/02/2010 09:25",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I had some Spring placeholders files in a nested directory. In my Spring Application Context file I had those files configured in a PropertyPlaceholderConfigurer. When I did a rename on the placeholders file, IDEA renamed the file in the context file, but removed the path information. So &quot;spring/myapp/original-name.properties&quot; became &quot;new-name.properties.&quot;  See the attached screenshot for an example.</div>
","0"
"IDEA-22826","IntelliJ IDEA","","Inline class","Eugene Petrenko","05/05/2009 11:59","09/02/2010 14:46",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I need a simpliest case where class is nested and private. I would expect to inline it&#39;s body into all inheritors. Constructors may be substituted or simply added with private modifier.<br/><br/>I was needed to flatten classes hierarchy. For my case there was only one inheritor created as anonymous class.</div>
","0"
"IDEA-52128","IntelliJ IDEA","reproduced","Use interface where possible","Anna Kozlova","09/02/2010 06:50","09/02/2010 06:50",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">interface I {}<br/>interface II extends I {}<br/>class IImpl implements II {<br/>  void foo(I i){}<br/>  void foo(II i){}<br/>  void bar(IImpl impl){<br/>    foo(impl);<br/>  }<br/>}</pre><br/>Use I where possible should suggest to use another overload method: instead of foo(II), foo(I) can be used.</div>
","1"
"IDEA-17352","IntelliJ IDEA","","Safe delete field should be able to remove the unused binding from UI form automatically","Eugene Vigdorchik","10/03/2008 09:29","22/01/2010 14:37",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">I.e. this is a safe to delete usage</div>
","0"
"IDEA-39392","IntelliJ IDEA","","Allow visibility selection in 'move class to outer' refactoring","Anton Makeev","25/06/2007 11:13","22/01/2010 14:28",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""></div>
","0"
"IDEA-20665","IntelliJ IDEA","reproduced","Added qualifiers to avoid shadowing during renaming can lead to uncompilable code","Max Schaefer","14/11/2008 07:11","20/01/2010 17:02",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Test case:<br/><br/>import static java.lang.Math.PI;<br/><br/>class Indiana {<br/>    static double myPI = 3.2;<br/>    class Math { }<br/>    class java { }<br/>    static double circle_area(double r) {<br/>        return PI *r*r;<br/>    }<br/>}<br/><br/>When renaming <span class=""monospace"">Indiana.myPI</span> to <span class=""monospace"">PI</span>, IDEA notices that this would shadow the access in method <span class=""monospace"">circle_area</span>, so it tries to add qualifiers. It again notices that <span class=""monospace"">Math.PI</span> would not work, so it decides to use <span class=""monospace"">java.lang.Math.PI</span>, but the example is set up so that this results in uncompilable code (of course, the example is easily extended so that the resulting code would still compile but behave differently).</div>
","0"
"IDEA-36400","IntelliJ IDEA","","Refactoring result preview","Konstantin Solomatov","18/01/2007 07:04","20/01/2010 16:51",,"Normal","Usability Problem",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">After I press do refactor button, usages view disappear, which isn&#39;t very good, because sometimes it&#39;s a good idea too look at refactoring results.</div>
","0"
"IDEA-24663","IntelliJ IDEA","","Introduce Field - initialize in: new setter","Serge Baranov","16/09/2009 18:00","17/01/2010 14:19",,"Normal","Feature",,"anet","Java. Refactorings","Not specified",,"Submitted","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Support feedback:<br/><br/>It would be nice if the Introduce Field dialog had an initialization option for a new setter method.  This comes up a lot if your application is wired together with Spring.</div>
","0"
"IDEA-50289","IntelliJ IDEA","","Ability to rename multiple Java files to .groovy","Peter Niederwieser","31/08/2009 16:55","17/01/2010 14:19",,"Normal","Feature",,"maxmedvedev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">It would be nice to have a way to rename multiple .java files to .groovy in one step. Maybe &quot;Rename to Groovy&quot; should be moved into the &quot;Refactor&quot; menu.</div>
","0"
"IDEA-46255","IntelliJ IDEA","reproduced","Extract Class doesn't handle name conflicts","Dmitry Jemerov","22/10/2008 08:28","17/01/2010 14:07",,"Normal","Bug",,"anet","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped""><pre class=""wikicode prettyprint"">import java.awt.Point;<br/><br/>abstract class A {<br/>  public int x;<br/>  public int y;<br/><br/>  abstract Point getRelativePoint();<br/>}</pre><br/>Extract fields x and y into a new class in the same package, called Point. The getRelativePoint() return type is not updated, so it now resolves to the newly extracted Point rather than java.awt.Point</div>
","0"
"IDEA-43629","IntelliJ IDEA","","Refactoring class location not updated in Spring MVC ResourceBundleViewResolver's properties file","Richard Bondi","21/04/2008 20:21","17/01/2010 14:00",,"Normal","Bug",,"yole","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">To reproduct:<br/><br/><ul class=""wiki-list0""><li> Create some class, like a Spring MVV View, com.x.y.MyView.java <br/></li><li> Create foo.properties in WEB-INF/classes<br/></li><li> In foo.properties, specify: some-view-or-other.class=com.x.y.MyView.java<br/></li><li> Refactory MyView.java to be in com.a.b.c (instead of com.x.y)<br/></li><li> Look at foo.properties: it will not have been updated.</li></ul><br/><br/><br/>Environment: osx</div>
","0"
"IDEA-39779","IntelliJ IDEA","","Extract superclass with successive class rename results in code loss","Eugene Zhuravlev","17/07/2007 13:24","17/01/2010 13:49",,"Normal","Bug",,"yole","Java. Refactorings","Not specified",,"Reopened","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">Consider:<br/>1) extract super-class B from class A<br/>2) make changes in A and B<br/>3) Rename A -&gt; NewA<br/>4) Rename B -&gt; A<br/><br/>When renaming B-&gt;A, a (rather confusing) dialog appears saying there were changes on memory and on disk. Select &quot;keep memory  changes&quot;.<br/>You will end up with the one file &quot;A&quot; containing the previous content of file &quot;A&quot;<br/><br/>Note that the code was under Perforce VCS.</div>
","0"
"IDEA-37077","IntelliJ IDEA","","*.iml file move is not UNDOable operation","Mikhail Gedzberg","13/02/2007 08:26","17/01/2010 13:42",,"Normal","Bug",,"yole","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">1) move *.iml from module root to any folder (or package) located inside the module (using drag and drag for example)<br/>2) press Ctrl + Z to come file back. it does nothing!</div>
","0"
"IDEA-21043","IntelliJ IDEA","","""Introduce Variable"" refactoring within JSP custom tag puts generated code to invalid place","Mischa Koelliker","04/12/2008 13:33","25/12/2008 14:55",,"Normal","Bug",,"davdeev","Java. Refactorings","Not specified",,"Open","Not specified","No tester","No","No","Not specified","Not specified","Not specified","No zendesk mentions",,"No assigned support","Unknown","<div class=""wiki text prewrapped"">The code generated by the &quot;Introduce Variable&quot; refactoring within a JSP is inserted at a wrong position. <br/>The snipped to be extracted as a variable is an expression within a custom JSP-tag-attribute (see screenshot &#39;before_introduce_var.png&#39;)<br/><br/>For the result of the refactoring, see screenshot &#39;after_introduce_var.png&#39;<br/><br/>The bug applies to 8.0.1 too.<br/><br/>Environment: WinXP, Weblogic 8.1.3</div>
","0"